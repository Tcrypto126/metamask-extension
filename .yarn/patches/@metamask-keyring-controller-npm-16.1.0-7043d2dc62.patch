diff --git a/dist/KeyringController.js b/dist/KeyringController.js
index 03a6cecff820613ada02f40d3f88edb93c3fe6ed..a690f825be4d66eb48aec945c8e853a66c68ab94 100644
--- a/dist/KeyringController.js
+++ b/dist/KeyringController.js
@@ -7,7 +7,7 @@
 
 
 
-var _chunkBRS27QHFjs = require('./chunk-BRS27QHF.js');
+var _chunkL4UUWIZAjs = require('./chunk-L4UUWIZA.js');
 require('./chunk-NOCGQCUM.js');
 
 
@@ -18,5 +18,5 @@ require('./chunk-NOCGQCUM.js');
 
 
 
-exports.AccountImportStrategy = _chunkBRS27QHFjs.AccountImportStrategy; exports.KeyringController = _chunkBRS27QHFjs.KeyringController; exports.KeyringTypes = _chunkBRS27QHFjs.KeyringTypes; exports.SignTypedDataVersion = _chunkBRS27QHFjs.SignTypedDataVersion; exports.default = _chunkBRS27QHFjs.KeyringController_default; exports.getDefaultKeyringState = _chunkBRS27QHFjs.getDefaultKeyringState; exports.isCustodyKeyring = _chunkBRS27QHFjs.isCustodyKeyring; exports.keyringBuilderFactory = _chunkBRS27QHFjs.keyringBuilderFactory;
+exports.AccountImportStrategy = _chunkL4UUWIZAjs.AccountImportStrategy; exports.KeyringController = _chunkL4UUWIZAjs.KeyringController; exports.KeyringTypes = _chunkL4UUWIZAjs.KeyringTypes; exports.SignTypedDataVersion = _chunkL4UUWIZAjs.SignTypedDataVersion; exports.default = _chunkL4UUWIZAjs.KeyringController_default; exports.getDefaultKeyringState = _chunkL4UUWIZAjs.getDefaultKeyringState; exports.isCustodyKeyring = _chunkL4UUWIZAjs.isCustodyKeyring; exports.keyringBuilderFactory = _chunkL4UUWIZAjs.keyringBuilderFactory;
 //# sourceMappingURL=KeyringController.js.map
\ No newline at end of file
diff --git a/dist/KeyringController.mjs b/dist/KeyringController.mjs
index 58ef8b875e01d8b09ec3880af35f43acdc40f406..7d315f91917002b37edabe91ab7c710e202a4e4e 100644
--- a/dist/KeyringController.mjs
+++ b/dist/KeyringController.mjs
@@ -7,7 +7,7 @@ import {
   getDefaultKeyringState,
   isCustodyKeyring,
   keyringBuilderFactory
-} from "./chunk-STFS4REY.mjs";
+} from "./chunk-7A7D7THR.mjs";
 import "./chunk-F64I344Z.mjs";
 export {
   AccountImportStrategy,
diff --git a/dist/chunk-7A7D7THR.mjs b/dist/chunk-7A7D7THR.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..42d34b71f245ca1a9e2e019a945df795a6a603c2
--- /dev/null
+++ b/dist/chunk-7A7D7THR.mjs
@@ -0,0 +1,1506 @@
+import {
+  __privateAdd,
+  __privateGet,
+  __privateMethod,
+  __privateSet
+} from "./chunk-F64I344Z.mjs";
+
+// src/KeyringController.ts
+import { isValidPrivate, toBuffer, getBinarySize } from "@ethereumjs/util";
+import { BaseController } from "@metamask/base-controller";
+import * as encryptorUtils from "@metamask/browser-passworder";
+import HDKeyring from "@metamask/eth-hd-keyring";
+import { normalize as ethNormalize } from "@metamask/eth-sig-util";
+import SimpleKeyring from "@metamask/eth-simple-keyring";
+import {
+  add0x,
+  assertIsStrictHexString,
+  bytesToHex,
+  hasProperty,
+  isObject,
+  isStrictHexString,
+  isValidHexAddress,
+  isValidJson,
+  remove0x
+} from "@metamask/utils";
+import { Mutex } from "async-mutex";
+import Wallet, { thirdparty as importers } from "ethereumjs-wallet";
+var name = "KeyringController";
+var KeyringTypes = /* @__PURE__ */ ((KeyringTypes2) => {
+  KeyringTypes2["simple"] = "Simple Key Pair";
+  KeyringTypes2["hd"] = "HD Key Tree";
+  KeyringTypes2["qr"] = "QR Hardware Wallet Device";
+  KeyringTypes2["trezor"] = "Trezor Hardware";
+  KeyringTypes2["ledger"] = "Ledger Hardware";
+  KeyringTypes2["lattice"] = "Lattice Hardware";
+  KeyringTypes2["snap"] = "Snap Keyring";
+  return KeyringTypes2;
+})(KeyringTypes || {});
+var isCustodyKeyring = (keyringType) => {
+  return keyringType.startsWith("Custody");
+};
+var AccountImportStrategy = /* @__PURE__ */ ((AccountImportStrategy2) => {
+  AccountImportStrategy2["privateKey"] = "privateKey";
+  AccountImportStrategy2["json"] = "json";
+  return AccountImportStrategy2;
+})(AccountImportStrategy || {});
+var SignTypedDataVersion = /* @__PURE__ */ ((SignTypedDataVersion2) => {
+  SignTypedDataVersion2["V1"] = "V1";
+  SignTypedDataVersion2["V3"] = "V3";
+  SignTypedDataVersion2["V4"] = "V4";
+  return SignTypedDataVersion2;
+})(SignTypedDataVersion || {});
+function keyringBuilderFactory(KeyringConstructor) {
+  const builder = () => new KeyringConstructor();
+  builder.type = KeyringConstructor.type;
+  return builder;
+}
+var defaultKeyringBuilders = [
+  keyringBuilderFactory(SimpleKeyring),
+  keyringBuilderFactory(HDKeyring)
+];
+var getDefaultKeyringState = () => {
+  return {
+    isUnlocked: false,
+    keyrings: []
+  };
+};
+function assertHasUint8ArrayMnemonic(keyring) {
+  if (!(hasProperty(keyring, "mnemonic") && keyring.mnemonic instanceof Uint8Array)) {
+    throw new Error("Can't get mnemonic bytes from keyring");
+  }
+}
+function assertIsExportableKeyEncryptor(encryptor) {
+  if (!("importKey" in encryptor && typeof encryptor.importKey === "function" && "decryptWithKey" in encryptor && typeof encryptor.decryptWithKey === "function" && "encryptWithKey" in encryptor && typeof encryptor.encryptWithKey === "function")) {
+    throw new Error("KeyringController - The encryptor does not support encryption key export." /* UnsupportedEncryptionKeyExport */);
+  }
+}
+function assertIsValidPassword(password) {
+  if (typeof password !== "string") {
+    throw new Error("KeyringController - Password must be of type string." /* WrongPasswordType */);
+  }
+  if (!password || !password.length) {
+    throw new Error("KeyringController - Password cannot be empty." /* InvalidEmptyPassword */);
+  }
+}
+function isSerializedKeyringsArray(array) {
+  return typeof array === "object" && Array.isArray(array) && array.every((value) => value.type && isValidJson(value.data));
+}
+async function displayForKeyring(keyring) {
+  const accounts = await keyring.getAccounts();
+  return {
+    type: keyring.type,
+    // Cast to `string[]` here is safe here because `accounts` has no nullish
+    // values, and `normalize` returns `string` unless given a nullish value
+    accounts: accounts.map(normalize)
+  };
+}
+function isEthAddress(address) {
+  return (
+    // NOTE: This function only checks for lowercased strings
+    isStrictHexString(address.toLowerCase()) && // This checks for lowercased addresses and checksum addresses too
+    isValidHexAddress(address)
+  );
+}
+function normalize(address) {
+  return isEthAddress(address) ? ethNormalize(address) : address;
+}
+var _controllerOperationMutex, _vaultOperationMutex, _keyringBuilders, _keyrings, _unsupportedKeyrings, _password, _encryptor, _cacheEncryptionKey, _qrKeyringStateListener, _registerMessageHandlers, registerMessageHandlers_fn, _getKeyringBuilderForType, getKeyringBuilderForType_fn, _addQRKeyring, addQRKeyring_fn, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn, _getUpdatedKeyrings, getUpdatedKeyrings_fn, _getSerializedKeyrings, getSerializedKeyrings_fn, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn, _unlockKeyrings, unlockKeyrings_fn, _updateVault, updateVault_fn, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn, _newKeyring, newKeyring_fn, _clearKeyrings, clearKeyrings_fn, _restoreKeyring, restoreKeyring_fn, _destroyKeyring, destroyKeyring_fn, _removeEmptyKeyrings, removeEmptyKeyrings_fn, _checkForDuplicate, checkForDuplicate_fn, _setUnlocked, setUnlocked_fn, _persistOrRollback, persistOrRollback_fn, _withRollback, withRollback_fn, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn, _withControllerLock, withControllerLock_fn, _withVaultLock, withVaultLock_fn;
+var KeyringController = class extends BaseController {
+  /**
+   * Creates a KeyringController instance.
+   *
+   * @param options - Initial options used to configure this controller
+   * @param options.encryptor - An optional object for defining encryption schemes.
+   * @param options.keyringBuilders - Set a new name for account.
+   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.
+   * @param options.messenger - A restricted controller messenger.
+   * @param options.state - Initial state to set on this controller.
+   */
+  constructor(options) {
+    const {
+      encryptor = encryptorUtils,
+      keyringBuilders,
+      messenger,
+      state
+    } = options;
+    super({
+      name,
+      metadata: {
+        vault: { persist: true, anonymous: false },
+        isUnlocked: { persist: false, anonymous: true },
+        keyrings: { persist: false, anonymous: false },
+        encryptionKey: { persist: false, anonymous: false },
+        encryptionSalt: { persist: false, anonymous: false }
+      },
+      messenger,
+      state: {
+        ...getDefaultKeyringState(),
+        ...state
+      }
+    });
+    /**
+     * Constructor helper for registering this controller's messaging system
+     * actions.
+     */
+    __privateAdd(this, _registerMessageHandlers);
+    /**
+     * Get the keyring builder for the given `type`.
+     *
+     * @param type - The type of keyring to get the builder for.
+     * @returns The keyring builder, or undefined if none exists.
+     */
+    __privateAdd(this, _getKeyringBuilderForType);
+    /**
+     * Add qr hardware keyring.
+     *
+     * @returns The added keyring
+     * @throws If a QRKeyring builder is not provided
+     * when initializing the controller
+     */
+    __privateAdd(this, _addQRKeyring);
+    /**
+     * Subscribe to a QRKeyring state change events and
+     * forward them through the messaging system.
+     *
+     * @param qrKeyring - The QRKeyring instance to subscribe to
+     */
+    __privateAdd(this, _subscribeToQRKeyringEvents);
+    __privateAdd(this, _unsubscribeFromQRKeyringsEvents);
+    /**
+     * Create new vault with an initial keyring
+     *
+     * Destroys any old encrypted storage,
+     * creates a new encrypted store with the given password,
+     * creates a new wallet with 1 account.
+     *
+     * @fires KeyringController:unlock
+     * @param password - The password to encrypt the vault with.
+     * @param keyring - A object containing the params to instantiate a new keyring.
+     * @param keyring.type - The keyring type.
+     * @param keyring.opts - Optional parameters required to instantiate the keyring.
+     * @returns A promise that resolves to the state.
+     */
+    __privateAdd(this, _createNewVaultWithKeyring);
+    /**
+     * Get the updated array of each keyring's type and
+     * accounts list.
+     *
+     * @returns A promise resolving to the updated keyrings array.
+     */
+    __privateAdd(this, _getUpdatedKeyrings);
+    /**
+     * Serialize the current array of keyring instances,
+     * including unsupported keyrings by default.
+     *
+     * @param options - Method options.
+     * @param options.includeUnsupported - Whether to include unsupported keyrings.
+     * @returns The serialized keyrings.
+     */
+    __privateAdd(this, _getSerializedKeyrings);
+    /**
+     * Restore a serialized keyrings array.
+     *
+     * @param serializedKeyrings - The serialized keyrings array.
+     */
+    __privateAdd(this, _restoreSerializedKeyrings);
+    /**
+     * Unlock Keyrings, decrypting the vault and deserializing all
+     * keyrings contained in it, using a password or an encryption key with salt.
+     *
+     * @param password - The keyring controller password.
+     * @param encryptionKey - An exported key string to unlock keyrings with.
+     * @param encryptionSalt - The salt used to encrypt the vault.
+     * @returns A promise resolving to the deserialized keyrings array.
+     */
+    __privateAdd(this, _unlockKeyrings);
+    /**
+     * Update the vault with the current keyrings.
+     *
+     * @returns A promise resolving to `true` if the operation is successful.
+     */
+    __privateAdd(this, _updateVault);
+    /**
+     * Retrieves all the accounts from keyrings instances
+     * that are currently in memory.
+     *
+     * @returns A promise resolving to an array of accounts.
+     */
+    __privateAdd(this, _getAccountsFromKeyrings);
+    /**
+     * Create a new keyring, ensuring that the first account is
+     * also created.
+     *
+     * @param type - Keyring type to instantiate.
+     * @param opts - Optional parameters required to instantiate the keyring.
+     * @returns A promise that resolves if the operation is successful.
+     */
+    __privateAdd(this, _createKeyringWithFirstAccount);
+    /**
+     * Instantiate, initialize and return a new keyring of the given `type`,
+     * using the given `opts`. The keyring is built using the keyring builder
+     * registered for the given `type`.
+     *
+     *
+     * @param type - The type of keyring to add.
+     * @param data - The data to restore a previously serialized keyring.
+     * @returns The new keyring.
+     * @throws If the keyring includes duplicated accounts.
+     */
+    __privateAdd(this, _newKeyring);
+    /**
+     * Remove all managed keyrings, destroying all their
+     * instances in memory.
+     */
+    __privateAdd(this, _clearKeyrings);
+    /**
+     * Restore a Keyring from a provided serialized payload.
+     * On success, returns the resulting keyring instance.
+     *
+     * @param serialized - The serialized keyring.
+     * @returns The deserialized keyring or undefined if the keyring type is unsupported.
+     */
+    __privateAdd(this, _restoreKeyring);
+    /**
+     * Destroy Keyring
+     *
+     * Some keyrings support a method called `destroy`, that destroys the
+     * keyring along with removing all its event listeners and, in some cases,
+     * clears the keyring bridge iframe from the DOM.
+     *
+     * @param keyring - The keyring to destroy.
+     */
+    __privateAdd(this, _destroyKeyring);
+    /**
+     * Remove empty keyrings.
+     *
+     * Loops through the keyrings and removes the ones with empty accounts
+     * (usually after removing the last / only account) from a keyring.
+     */
+    __privateAdd(this, _removeEmptyKeyrings);
+    /**
+     * Checks for duplicate keypairs, using the the first account in the given
+     * array. Rejects if a duplicate is found.
+     *
+     * Only supports 'Simple Key Pair'.
+     *
+     * @param type - The key pair type to check for.
+     * @param newAccountArray - Array of new accounts.
+     * @returns The account, if no duplicate is found.
+     */
+    __privateAdd(this, _checkForDuplicate);
+    /**
+     * Set the `isUnlocked` to true and notify listeners
+     * through the messenger.
+     *
+     * @fires KeyringController:unlock
+     */
+    __privateAdd(this, _setUnlocked);
+    /**
+     * Execute the given function after acquiring the controller lock
+     * and save the keyrings to state after it, or rollback to their
+     * previous state in case of error.
+     *
+     * @param fn - The function to execute.
+     * @returns The result of the function.
+     */
+    __privateAdd(this, _persistOrRollback);
+    /**
+     * Execute the given function after acquiring the controller lock
+     * and rollback keyrings and password states in case of error.
+     *
+     * @param fn - The function to execute atomically.
+     * @returns The result of the function.
+     */
+    __privateAdd(this, _withRollback);
+    /**
+     * Assert that the controller mutex is locked.
+     *
+     * @throws If the controller mutex is not locked.
+     */
+    __privateAdd(this, _assertControllerMutexIsLocked);
+    /**
+     * Lock the controller mutex before executing the given function,
+     * and release it after the function is resolved or after an
+     * error is thrown.
+     *
+     * This wrapper ensures that each mutable operation that interacts with the
+     * controller and that changes its state is executed in a mutually exclusive way,
+     * preventing unsafe concurrent access that could lead to unpredictable behavior.
+     *
+     * @param fn - The function to execute while the controller mutex is locked.
+     * @returns The result of the function.
+     */
+    __privateAdd(this, _withControllerLock);
+    /**
+     * Lock the vault mutex before executing the given function,
+     * and release it after the function is resolved or after an
+     * error is thrown.
+     *
+     * This ensures that each operation that interacts with the vault
+     * is executed in a mutually exclusive way.
+     *
+     * @param fn - The function to execute while the vault mutex is locked.
+     * @returns The result of the function.
+     */
+    __privateAdd(this, _withVaultLock);
+    __privateAdd(this, _controllerOperationMutex, new Mutex());
+    __privateAdd(this, _vaultOperationMutex, new Mutex());
+    __privateAdd(this, _keyringBuilders, void 0);
+    __privateAdd(this, _keyrings, void 0);
+    __privateAdd(this, _unsupportedKeyrings, void 0);
+    __privateAdd(this, _password, void 0);
+    __privateAdd(this, _encryptor, void 0);
+    __privateAdd(this, _cacheEncryptionKey, void 0);
+    __privateAdd(this, _qrKeyringStateListener, void 0);
+    __privateSet(this, _keyringBuilders, keyringBuilders ? defaultKeyringBuilders.concat(keyringBuilders) : defaultKeyringBuilders);
+    __privateSet(this, _encryptor, encryptor);
+    __privateSet(this, _keyrings, []);
+    __privateSet(this, _unsupportedKeyrings, []);
+    __privateSet(this, _cacheEncryptionKey, Boolean(options.cacheEncryptionKey));
+    if (__privateGet(this, _cacheEncryptionKey)) {
+      assertIsExportableKeyEncryptor(encryptor);
+    }
+    __privateMethod(this, _registerMessageHandlers, registerMessageHandlers_fn).call(this);
+  }
+  /**
+   * Adds a new account to the default (first) HD seed phrase keyring.
+   *
+   * @param accountCount - Number of accounts before adding a new one, used to
+   * make the method idempotent.
+   * @returns Promise resolving to the added account address.
+   */
+  async addNewAccount(accountCount) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
+      if (!primaryKeyring) {
+        throw new Error("No HD keyring found");
+      }
+      const oldAccounts = await primaryKeyring.getAccounts();
+      if (accountCount && oldAccounts.length !== accountCount) {
+        if (accountCount > oldAccounts.length) {
+          throw new Error("Account out of sequence");
+        }
+        const existingAccount = oldAccounts[accountCount];
+        if (!existingAccount) {
+          throw new Error(`Can't find account at index ${accountCount}`);
+        }
+        return existingAccount;
+      }
+      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
+      await this.verifySeedPhrase();
+      return addedAccountAddress;
+    });
+  }
+  /**
+   * Adds a new account to the specified keyring.
+   *
+   * @param keyring - Keyring to add the account to.
+   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.
+   * @returns Promise resolving to the added account address
+   */
+  async addNewAccountForKeyring(keyring, accountCount) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const oldAccounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      if (accountCount && oldAccounts.length !== accountCount) {
+        if (accountCount > oldAccounts.length) {
+          throw new Error("Account out of sequence");
+        }
+        const existingAccount = oldAccounts[accountCount];
+        assertIsStrictHexString(existingAccount);
+        return existingAccount;
+      }
+      await keyring.addAccounts(1);
+      const addedAccountAddress = (await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this)).find(
+        (selectedAddress) => !oldAccounts.includes(selectedAddress)
+      );
+      assertIsStrictHexString(addedAccountAddress);
+      return addedAccountAddress;
+    });
+  }
+  /**
+   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.
+   *
+   * @returns Promise resolving to the added account address.
+   */
+  async addNewAccountWithoutUpdate() {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
+      if (!primaryKeyring) {
+        throw new Error("No HD keyring found");
+      }
+      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
+      await this.verifySeedPhrase();
+      return addedAccountAddress;
+    });
+  }
+  /**
+   * Effectively the same as creating a new keychain then populating it
+   * using the given seed phrase.
+   *
+   * @param password - Password to unlock keychain.
+   * @param seed - A BIP39-compliant seed phrase as Uint8Array,
+   * either as a string or an array of UTF-8 bytes that represent the string.
+   * @returns Promise resolving when the operation ends successfully.
+   */
+  async createNewVaultAndRestore(password, seed) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      assertIsValidPassword(password);
+      await __privateMethod(this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
+        type: "HD Key Tree" /* hd */,
+        opts: {
+          mnemonic: seed,
+          numberOfAccounts: 1
+        }
+      });
+    });
+  }
+  /**
+   * Create a new primary keychain and wipe any previous keychains.
+   *
+   * @param password - Password to unlock the new vault.
+   * @returns Promise resolving when the operation ends successfully.
+   */
+  async createNewVaultAndKeychain(password) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const accounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      if (!accounts.length) {
+        await __privateMethod(this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
+          type: "HD Key Tree" /* hd */
+        });
+      }
+    });
+  }
+  /**
+   * Adds a new keyring of the given `type`.
+   *
+   * @param type - Keyring type name.
+   * @param opts - Keyring options.
+   * @throws If a builder for the given `type` does not exist.
+   * @returns Promise resolving to the added keyring.
+   */
+  async addNewKeyring(type, opts) {
+    if (type === "QR Hardware Wallet Device" /* qr */) {
+      return this.getOrAddQRKeyring();
+    }
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => __privateMethod(this, _newKeyring, newKeyring_fn).call(this, type, opts));
+  }
+  /**
+   * Method to verify a given password validity. Throws an
+   * error if the password is invalid.
+   *
+   * @param password - Password of the keyring.
+   */
+  async verifyPassword(password) {
+    if (!this.state.vault) {
+      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
+    }
+    await __privateGet(this, _encryptor).decrypt(password, this.state.vault);
+  }
+  /**
+   * Returns the status of the vault.
+   *
+   * @returns Boolean returning true if the vault is unlocked.
+   */
+  isUnlocked() {
+    return this.state.isUnlocked;
+  }
+  /**
+   * Gets the seed phrase of the HD keyring.
+   *
+   * @param password - Password of the keyring.
+   * @returns Promise resolving to the seed phrase.
+   */
+  async exportSeedPhrase(password) {
+    await this.verifyPassword(password);
+    assertHasUint8ArrayMnemonic(__privateGet(this, _keyrings)[0]);
+    return __privateGet(this, _keyrings)[0].mnemonic;
+  }
+  /**
+   * Gets the private key from the keyring controlling an address.
+   *
+   * @param password - Password of the keyring.
+   * @param address - Address to export.
+   * @returns Promise resolving to the private key for an address.
+   */
+  async exportAccount(password, address) {
+    await this.verifyPassword(password);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.exportAccount) {
+      throw new Error("`KeyringController - The keyring for the current address does not support the method exportAccount" /* UnsupportedExportAccount */);
+    }
+    return await keyring.exportAccount(normalize(address));
+  }
+  /**
+   * Returns the public addresses of all accounts from every keyring.
+   *
+   * @returns A promise resolving to an array of addresses.
+   */
+  async getAccounts() {
+    return this.state.keyrings.reduce(
+      (accounts, keyring) => accounts.concat(keyring.accounts),
+      []
+    );
+  }
+  /**
+   * Get encryption public key.
+   *
+   * @param account - An account address.
+   * @param opts - Additional encryption options.
+   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method
+   * @returns Promise resolving to encyption public key of the `account` if one exists.
+   */
+  async getEncryptionPublicKey(account, opts) {
+    const address = ethNormalize(account);
+    const keyring = await this.getKeyringForAccount(
+      account
+    );
+    if (!keyring.getEncryptionPublicKey) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method getEncryptionPublicKey." /* UnsupportedGetEncryptionPublicKey */);
+    }
+    return await keyring.getEncryptionPublicKey(address, opts);
+  }
+  /**
+   * Attempts to decrypt the provided message parameters.
+   *
+   * @param messageParams - The decryption message parameters.
+   * @param messageParams.from - The address of the account you want to use to decrypt the message.
+   * @param messageParams.data - The encrypted data that you want to decrypt.
+   * @returns The raw decryption result.
+   */
+  async decryptMessage(messageParams) {
+    const address = ethNormalize(messageParams.from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.decryptMessage) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method decryptMessage." /* UnsupportedDecryptMessage */);
+    }
+    return keyring.decryptMessage(address, messageParams.data);
+  }
+  /**
+   * Returns the currently initialized keyring that manages
+   * the specified `address` if one exists.
+   *
+   * @deprecated Use of this method is discouraged as actions executed directly on
+   * keyrings are not being reflected in the KeyringController state and not
+   * persisted in the vault. Use `withKeyring` instead.
+   * @param account - An account address.
+   * @returns Promise resolving to keyring of the `account` if one exists.
+   */
+  async getKeyringForAccount(account) {
+    const address = normalize(account);
+    const candidates = await Promise.all(
+      __privateGet(this, _keyrings).map(async (keyring) => {
+        return Promise.all([keyring, keyring.getAccounts()]);
+      })
+    );
+    const winners = candidates.filter((candidate) => {
+      const accounts = candidate[1].map(normalize);
+      return accounts.includes(address);
+    });
+    if (winners.length && winners[0]?.length) {
+      return winners[0][0];
+    }
+    let errorInfo = "";
+    if (!candidates.length) {
+      errorInfo = "There are no keyrings";
+    } else if (!winners.length) {
+      errorInfo = "There are keyrings, but none match the address";
+    }
+    throw new Error(
+      `${"KeyringController - No keyring found" /* NoKeyring */}. Error info: ${errorInfo}`
+    );
+  }
+  /**
+   * Returns all keyrings of the given type.
+   *
+   * @deprecated Use of this method is discouraged as actions executed directly on
+   * keyrings are not being reflected in the KeyringController state and not
+   * persisted in the vault. Use `withKeyring` instead.
+   * @param type - Keyring type name.
+   * @returns An array of keyrings of the given type.
+   */
+  getKeyringsByType(type) {
+    return __privateGet(this, _keyrings).filter((keyring) => keyring.type === type);
+  }
+  /**
+   * Persist all serialized keyrings in the vault.
+   *
+   * @deprecated This method is being phased out in favor of `withKeyring`.
+   * @returns Promise resolving with `true` value when the
+   * operation completes.
+   */
+  async persistAllKeyrings() {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => true);
+  }
+  /**
+   * Imports an account with the specified import strategy.
+   *
+   * @param strategy - Import strategy name.
+   * @param args - Array of arguments to pass to the underlying stategy.
+   * @throws Will throw when passed an unrecognized strategy.
+   * @returns Promise resolving to the imported account address.
+   */
+  async importAccountWithStrategy(strategy, args) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      let privateKey;
+      switch (strategy) {
+        case "privateKey":
+          const [importedKey] = args;
+          if (!importedKey) {
+            throw new Error("Cannot import an empty key.");
+          }
+          const prefixed = add0x(importedKey);
+          let bufferedPrivateKey;
+          try {
+            bufferedPrivateKey = toBuffer(prefixed);
+          } catch {
+            throw new Error("Cannot import invalid private key.");
+          }
+          if (!isValidPrivate(bufferedPrivateKey) || // ensures that the key is 64 bytes long
+          getBinarySize(prefixed) !== 64 + "0x".length) {
+            throw new Error("Cannot import invalid private key.");
+          }
+          privateKey = remove0x(prefixed);
+          break;
+        case "json":
+          let wallet;
+          const [input, password] = args;
+          try {
+            wallet = importers.fromEtherWallet(input, password);
+          } catch (e) {
+            wallet = wallet || await Wallet.fromV3(input, password, true);
+          }
+          privateKey = bytesToHex(wallet.getPrivateKey());
+          break;
+        default:
+          throw new Error(`Unexpected import strategy: '${strategy}'`);
+      }
+      const newKeyring = await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, "Simple Key Pair" /* simple */, [
+        privateKey
+      ]);
+      const accounts = await newKeyring.getAccounts();
+      return accounts[0];
+    });
+  }
+  /**
+   * Removes an account from keyring state.
+   *
+   * @param address - Address of the account to remove.
+   * @fires KeyringController:accountRemoved
+   * @returns Promise resolving when the account is removed.
+   */
+  async removeAccount(address) {
+    await __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = await this.getKeyringForAccount(
+        address
+      );
+      if (!keyring.removeAccount) {
+        throw new Error("`KeyringController - The keyring for the current address does not support the method removeAccount" /* UnsupportedRemoveAccount */);
+      }
+      await keyring.removeAccount(address);
+      const accounts = await keyring.getAccounts();
+      if (accounts.length === 0) {
+        await __privateMethod(this, _removeEmptyKeyrings, removeEmptyKeyrings_fn).call(this);
+      }
+    });
+    this.messagingSystem.publish(`${name}:accountRemoved`, address);
+  }
+  /**
+   * Deallocates all secrets and locks the wallet.
+   *
+   * @returns Promise resolving when the operation completes.
+   */
+  async setLocked() {
+    return __privateMethod(this, _withRollback, withRollback_fn).call(this, async () => {
+      __privateMethod(this, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn).call(this);
+      __privateSet(this, _password, void 0);
+      await __privateMethod(this, _clearKeyrings, clearKeyrings_fn).call(this);
+      this.update((state) => {
+        state.isUnlocked = false;
+        state.keyrings = [];
+        delete state.encryptionKey;
+        delete state.encryptionSalt;
+      });
+      this.messagingSystem.publish(`${name}:lock`);
+    });
+  }
+  /**
+   * Signs message by calling down into a specific keyring.
+   *
+   * @param messageParams - PersonalMessageParams object to sign.
+   * @returns Promise resolving to a signed message string.
+   */
+  async signMessage(messageParams) {
+    if (!messageParams.data) {
+      throw new Error("Can't sign an empty message");
+    }
+    const address = ethNormalize(messageParams.from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signMessage) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signMessage." /* UnsupportedSignMessage */);
+    }
+    return await keyring.signMessage(address, messageParams.data);
+  }
+  /**
+   * Signs personal message by calling down into a specific keyring.
+   *
+   * @param messageParams - PersonalMessageParams object to sign.
+   * @returns Promise resolving to a signed message string.
+   */
+  async signPersonalMessage(messageParams) {
+    const address = ethNormalize(messageParams.from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signPersonalMessage) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signPersonalMessage." /* UnsupportedSignPersonalMessage */);
+    }
+    const normalizedData = normalize(messageParams.data);
+    return await keyring.signPersonalMessage(address, normalizedData);
+  }
+  /**
+   * Signs typed message by calling down into a specific keyring.
+   *
+   * @param messageParams - TypedMessageParams object to sign.
+   * @param version - Compatibility version EIP712.
+   * @throws Will throw when passed an unrecognized version.
+   * @returns Promise resolving to a signed message string or an error if any.
+   */
+  async signTypedMessage(messageParams, version) {
+    try {
+      if (![
+        "V1" /* V1 */,
+        "V3" /* V3 */,
+        "V4" /* V4 */
+      ].includes(version)) {
+        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
+      }
+      const address = ethNormalize(messageParams.from);
+      const keyring = await this.getKeyringForAccount(
+        address
+      );
+      if (!keyring.signTypedData) {
+        throw new Error("KeyringController - The keyring for the current address does not support the method signTypedMessage." /* UnsupportedSignTypedMessage */);
+      }
+      return await keyring.signTypedData(
+        address,
+        version !== "V1" /* V1 */ && typeof messageParams.data === "string" ? JSON.parse(messageParams.data) : messageParams.data,
+        { version }
+      );
+    } catch (error) {
+      throw new Error(`Keyring Controller signTypedMessage: ${error}`);
+    }
+  }
+  /**
+   * Signs a transaction by calling down into a specific keyring.
+   *
+   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
+   * @param from - Address to sign from, should be in keychain.
+   * @param opts - An optional options object.
+   * @returns Promise resolving to a signed transaction string.
+   */
+  async signTransaction(transaction, from, opts) {
+    const address = ethNormalize(from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signTransaction) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signTransaction." /* UnsupportedSignTransaction */);
+    }
+    return await keyring.signTransaction(address, transaction, opts);
+  }
+  /**
+   * Convert a base transaction to a base UserOperation.
+   *
+   * @param from - Address of the sender.
+   * @param transactions - Base transactions to include in the UserOperation.
+   * @param executionContext - The execution context to use for the UserOperation.
+   * @returns A pseudo-UserOperation that can be used to construct a real.
+   */
+  async prepareUserOperation(from, transactions, executionContext) {
+    const address = ethNormalize(from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.prepareUserOperation) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method prepareUserOperation." /* UnsupportedPrepareUserOperation */);
+    }
+    return await keyring.prepareUserOperation(
+      address,
+      transactions,
+      executionContext
+    );
+  }
+  /**
+   * Patches properties of a UserOperation. Currently, only the
+   * `paymasterAndData` can be patched.
+   *
+   * @param from - Address of the sender.
+   * @param userOp - UserOperation to patch.
+   * @param executionContext - The execution context to use for the UserOperation.
+   * @returns A patch to apply to the UserOperation.
+   */
+  async patchUserOperation(from, userOp, executionContext) {
+    const address = ethNormalize(from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.patchUserOperation) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method patchUserOperation." /* UnsupportedPatchUserOperation */);
+    }
+    return await keyring.patchUserOperation(address, userOp, executionContext);
+  }
+  /**
+   * Signs an UserOperation.
+   *
+   * @param from - Address of the sender.
+   * @param userOp - UserOperation to sign.
+   * @param executionContext - The execution context to use for the UserOperation.
+   * @returns The signature of the UserOperation.
+   */
+  async signUserOperation(from, userOp, executionContext) {
+    const address = ethNormalize(from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signUserOperation) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signUserOperation." /* UnsupportedSignUserOperation */);
+    }
+    return await keyring.signUserOperation(address, userOp, executionContext);
+  }
+  /**
+   * Changes the password used to encrypt the vault.
+   *
+   * @param password - The new password.
+   * @returns Promise resolving when the operation completes.
+   */
+  changePassword(password) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      if (!this.state.isUnlocked) {
+        throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
+      }
+      assertIsValidPassword(password);
+      __privateSet(this, _password, password);
+      if (__privateGet(this, _cacheEncryptionKey)) {
+        this.update((state) => {
+          delete state.encryptionKey;
+          delete state.encryptionSalt;
+        });
+      }
+    });
+  }
+  /**
+   * Attempts to decrypt the current vault and load its keyrings,
+   * using the given encryption key and salt.
+   *
+   * @param encryptionKey - Key to unlock the keychain.
+   * @param encryptionSalt - Salt to unlock the keychain.
+   * @returns Promise resolving when the operation completes.
+   */
+  async submitEncryptionKey(encryptionKey, encryptionSalt) {
+    return __privateMethod(this, _withRollback, withRollback_fn).call(this, async () => {
+      __privateSet(this, _keyrings, await __privateMethod(this, _unlockKeyrings, unlockKeyrings_fn).call(this, void 0, encryptionKey, encryptionSalt));
+      __privateMethod(this, _setUnlocked, setUnlocked_fn).call(this);
+    });
+  }
+  /**
+   * Attempts to decrypt the current vault and load its keyrings,
+   * using the given password.
+   *
+   * @param password - Password to unlock the keychain.
+   * @returns Promise resolving when the operation completes.
+   */
+  async submitPassword(password) {
+    return __privateMethod(this, _withRollback, withRollback_fn).call(this, async () => {
+      __privateSet(this, _keyrings, await __privateMethod(this, _unlockKeyrings, unlockKeyrings_fn).call(this, password));
+      __privateMethod(this, _setUnlocked, setUnlocked_fn).call(this);
+    });
+  }
+  /**
+   * Verifies the that the seed phrase restores the current keychain's accounts.
+   *
+   * @returns Promise resolving to the seed phrase as Uint8Array.
+   */
+  async verifySeedPhrase() {
+    const primaryKeyring = this.getKeyringsByType("HD Key Tree" /* hd */)[0];
+    if (!primaryKeyring) {
+      throw new Error("No HD keyring found.");
+    }
+    assertHasUint8ArrayMnemonic(primaryKeyring);
+    const seedWords = primaryKeyring.mnemonic;
+    const accounts = await primaryKeyring.getAccounts();
+    if (accounts.length === 0) {
+      throw new Error("Cannot verify an empty keyring.");
+    }
+    const hdKeyringBuilder = __privateMethod(this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, "HD Key Tree" /* hd */);
+    const hdKeyring = hdKeyringBuilder();
+    await hdKeyring.deserialize({
+      mnemonic: seedWords,
+      numberOfAccounts: accounts.length
+    });
+    const testAccounts = await hdKeyring.getAccounts();
+    if (testAccounts.length !== accounts.length) {
+      throw new Error("Seed phrase imported incorrect number of accounts.");
+    }
+    testAccounts.forEach((account, i) => {
+      if (account.toLowerCase() !== accounts[i].toLowerCase()) {
+        throw new Error("Seed phrase imported different accounts.");
+      }
+    });
+    return seedWords;
+  }
+  async withKeyring(selector, operation, options = {
+    createIfMissing: false
+  }) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      let keyring;
+      if ("address" in selector) {
+        keyring = await this.getKeyringForAccount(selector.address);
+      } else {
+        keyring = this.getKeyringsByType(selector.type)[selector.index || 0];
+        if (!keyring && options.createIfMissing) {
+          keyring = await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, selector.type, options.createWithData);
+        }
+      }
+      if (!keyring) {
+        throw new Error("KeyringController - Keyring not found." /* KeyringNotFound */);
+      }
+      const result = await operation(keyring);
+      if (Object.is(result, keyring)) {
+        throw new Error("KeyringController - Returning keyring instances is unsafe" /* UnsafeDirectKeyringAccess */);
+      }
+      return result;
+    });
+  }
+  // QR Hardware related methods
+  /**
+   * Get QR Hardware keyring.
+   *
+   * @returns The QR Keyring if defined, otherwise undefined
+   */
+  getQRKeyring() {
+    return this.getKeyringsByType("QR Hardware Wallet Device" /* qr */)[0];
+  }
+  /**
+   * Get QR hardware keyring. If it doesn't exist, add it.
+   *
+   * @returns The added keyring
+   */
+  async getOrAddQRKeyring() {
+    return this.getQRKeyring() || await __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this));
+  }
+  // TODO: Replace `any` with type
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  async restoreQRKeyring(serialized) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = this.getQRKeyring() || await __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this);
+      keyring.deserialize(serialized);
+    });
+  }
+  async resetQRKeyringState() {
+    (await this.getOrAddQRKeyring()).resetStore();
+  }
+  async getQRKeyringState() {
+    return (await this.getOrAddQRKeyring()).getMemStore();
+  }
+  async submitQRCryptoHDKey(cryptoHDKey) {
+    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);
+  }
+  async submitQRCryptoAccount(cryptoAccount) {
+    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);
+  }
+  async submitQRSignature(requestId, ethSignature) {
+    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);
+  }
+  async cancelQRSignRequest() {
+    (await this.getOrAddQRKeyring()).cancelSignRequest();
+  }
+  /**
+   * Cancels qr keyring sync.
+   */
+  async cancelQRSynchronization() {
+    (await this.getOrAddQRKeyring()).cancelSync();
+  }
+  async connectQRHardware(page) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      try {
+        const keyring = this.getQRKeyring() || await __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this);
+        let accounts;
+        switch (page) {
+          case -1:
+            accounts = await keyring.getPreviousPage();
+            break;
+          case 1:
+            accounts = await keyring.getNextPage();
+            break;
+          default:
+            accounts = await keyring.getFirstPage();
+        }
+        return accounts.map((account) => {
+          return {
+            ...account,
+            balance: "0x0"
+          };
+        });
+      } catch (e) {
+        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);
+      }
+    });
+  }
+  async unlockQRHardwareWalletAccount(index) {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = this.getQRKeyring() || await __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this);
+      keyring.setAccountToUnlock(index);
+      await keyring.addAccounts(1);
+    });
+  }
+  async getAccountKeyringType(account) {
+    const keyring = await this.getKeyringForAccount(
+      account
+    );
+    return keyring.type;
+  }
+  async forgetQRDevice() {
+    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = this.getQRKeyring();
+      if (!keyring) {
+        return { removedAccounts: [], remainingAccounts: [] };
+      }
+      const allAccounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      keyring.forgetDevice();
+      const remainingAccounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      const removedAccounts = allAccounts.filter(
+        (address) => !remainingAccounts.includes(address)
+      );
+      return { removedAccounts, remainingAccounts };
+    });
+  }
+};
+_controllerOperationMutex = new WeakMap();
+_vaultOperationMutex = new WeakMap();
+_keyringBuilders = new WeakMap();
+_keyrings = new WeakMap();
+_unsupportedKeyrings = new WeakMap();
+_password = new WeakMap();
+_encryptor = new WeakMap();
+_cacheEncryptionKey = new WeakMap();
+_qrKeyringStateListener = new WeakMap();
+_registerMessageHandlers = new WeakSet();
+registerMessageHandlers_fn = function() {
+  this.messagingSystem.registerActionHandler(
+    `${name}:signMessage`,
+    this.signMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:signPersonalMessage`,
+    this.signPersonalMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:signTypedMessage`,
+    this.signTypedMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:decryptMessage`,
+    this.decryptMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getEncryptionPublicKey`,
+    this.getEncryptionPublicKey.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getAccounts`,
+    this.getAccounts.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getKeyringsByType`,
+    this.getKeyringsByType.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getKeyringForAccount`,
+    this.getKeyringForAccount.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:persistAllKeyrings`,
+    this.persistAllKeyrings.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:prepareUserOperation`,
+    this.prepareUserOperation.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:patchUserOperation`,
+    this.patchUserOperation.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:signUserOperation`,
+    this.signUserOperation.bind(this)
+  );
+};
+_getKeyringBuilderForType = new WeakSet();
+getKeyringBuilderForType_fn = function(type) {
+  return __privateGet(this, _keyringBuilders).find(
+    (keyringBuilder) => keyringBuilder.type === type
+  );
+};
+_addQRKeyring = new WeakSet();
+addQRKeyring_fn = async function() {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  return await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, "QR Hardware Wallet Device" /* qr */);
+};
+_subscribeToQRKeyringEvents = new WeakSet();
+subscribeToQRKeyringEvents_fn = function(qrKeyring) {
+  __privateSet(this, _qrKeyringStateListener, (state) => {
+    this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);
+  });
+  qrKeyring.getMemStore().subscribe(__privateGet(this, _qrKeyringStateListener));
+};
+_unsubscribeFromQRKeyringsEvents = new WeakSet();
+unsubscribeFromQRKeyringsEvents_fn = function() {
+  const qrKeyrings = this.getKeyringsByType(
+    "QR Hardware Wallet Device" /* qr */
+  );
+  qrKeyrings.forEach((qrKeyring) => {
+    if (__privateGet(this, _qrKeyringStateListener)) {
+      qrKeyring.getMemStore().unsubscribe(__privateGet(this, _qrKeyringStateListener));
+    }
+  });
+};
+_createNewVaultWithKeyring = new WeakSet();
+createNewVaultWithKeyring_fn = async function(password, keyring) {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  if (typeof password !== "string") {
+    throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
+  }
+  this.update((state) => {
+    delete state.encryptionKey;
+    delete state.encryptionSalt;
+  });
+  __privateSet(this, _password, password);
+  await __privateMethod(this, _clearKeyrings, clearKeyrings_fn).call(this);
+  await __privateMethod(this, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn).call(this, keyring.type, keyring.opts);
+  __privateMethod(this, _setUnlocked, setUnlocked_fn).call(this);
+};
+_getUpdatedKeyrings = new WeakSet();
+getUpdatedKeyrings_fn = async function() {
+  return Promise.all(__privateGet(this, _keyrings).map(displayForKeyring));
+};
+_getSerializedKeyrings = new WeakSet();
+getSerializedKeyrings_fn = async function({ includeUnsupported } = {
+  includeUnsupported: true
+}) {
+  const serializedKeyrings = await Promise.all(
+    __privateGet(this, _keyrings).map(async (keyring) => {
+      const [type, data] = await Promise.all([
+        keyring.type,
+        keyring.serialize()
+      ]);
+      return { type, data };
+    })
+  );
+  if (includeUnsupported) {
+    serializedKeyrings.push(...__privateGet(this, _unsupportedKeyrings));
+  }
+  return serializedKeyrings;
+};
+_restoreSerializedKeyrings = new WeakSet();
+restoreSerializedKeyrings_fn = async function(serializedKeyrings) {
+  await __privateMethod(this, _clearKeyrings, clearKeyrings_fn).call(this);
+  for (const serializedKeyring of serializedKeyrings) {
+    await __privateMethod(this, _restoreKeyring, restoreKeyring_fn).call(this, serializedKeyring);
+  }
+};
+_unlockKeyrings = new WeakSet();
+unlockKeyrings_fn = async function(password, encryptionKey, encryptionSalt) {
+  return __privateMethod(this, _withVaultLock, withVaultLock_fn).call(this, async ({ releaseLock }) => {
+    const encryptedVault = this.state.vault;
+    if (!encryptedVault) {
+      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
+    }
+    let vault;
+    const updatedState = {};
+    if (__privateGet(this, _cacheEncryptionKey)) {
+      assertIsExportableKeyEncryptor(__privateGet(this, _encryptor));
+      if (password) {
+        const result = await __privateGet(this, _encryptor).decryptWithDetail(
+          password,
+          encryptedVault
+        );
+        vault = result.vault;
+        __privateSet(this, _password, password);
+        updatedState.encryptionKey = result.exportedKeyString;
+        updatedState.encryptionSalt = result.salt;
+      } else {
+        const parsedEncryptedVault = JSON.parse(encryptedVault);
+        if (encryptionSalt !== parsedEncryptedVault.salt) {
+          throw new Error("KeyringController - Encryption key and salt provided are expired" /* ExpiredCredentials */);
+        }
+        if (typeof encryptionKey !== "string") {
+          throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
+        }
+        const key = await __privateGet(this, _encryptor).importKey(encryptionKey);
+        vault = await __privateGet(this, _encryptor).decryptWithKey(
+          key,
+          parsedEncryptedVault
+        );
+        updatedState.encryptionKey = encryptionKey;
+        updatedState.encryptionSalt = encryptionSalt;
+      }
+    } else {
+      if (typeof password !== "string") {
+        throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
+      }
+      vault = await __privateGet(this, _encryptor).decrypt(password, encryptedVault);
+      __privateSet(this, _password, password);
+    }
+    if (!isSerializedKeyringsArray(vault)) {
+      throw new Error("KeyringController - The decrypted vault has an unexpected shape." /* VaultDataError */);
+    }
+    await __privateMethod(this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, vault);
+    const updatedKeyrings = await __privateMethod(this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
+    this.update((state) => {
+      state.keyrings = updatedKeyrings;
+      if (updatedState.encryptionKey || updatedState.encryptionSalt) {
+        state.encryptionKey = updatedState.encryptionKey;
+        state.encryptionSalt = updatedState.encryptionSalt;
+      }
+    });
+    if (__privateGet(this, _password) && (!__privateGet(this, _cacheEncryptionKey) || !encryptionKey) && __privateGet(this, _encryptor).isVaultUpdated && !__privateGet(this, _encryptor).isVaultUpdated(encryptedVault)) {
+      releaseLock();
+      await __privateMethod(this, _updateVault, updateVault_fn).call(this);
+    }
+    return __privateGet(this, _keyrings);
+  });
+};
+_updateVault = new WeakSet();
+updateVault_fn = function() {
+  return __privateMethod(this, _withVaultLock, withVaultLock_fn).call(this, async () => {
+    const { encryptionKey, encryptionSalt } = this.state;
+    if (!__privateGet(this, _password) && !encryptionKey) {
+      throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
+    }
+    const serializedKeyrings = await __privateMethod(this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
+    if (!serializedKeyrings.some((keyring) => keyring.type === "HD Key Tree" /* hd */)) {
+      throw new Error("KeyringController - No HD Keyring found" /* NoHdKeyring */);
+    }
+    const updatedState = {};
+    if (__privateGet(this, _cacheEncryptionKey)) {
+      assertIsExportableKeyEncryptor(__privateGet(this, _encryptor));
+      if (encryptionKey) {
+        const key = await __privateGet(this, _encryptor).importKey(encryptionKey);
+        const vaultJSON = await __privateGet(this, _encryptor).encryptWithKey(
+          key,
+          serializedKeyrings
+        );
+        vaultJSON.salt = encryptionSalt;
+        updatedState.vault = JSON.stringify(vaultJSON);
+      } else if (__privateGet(this, _password)) {
+        const { vault: newVault, exportedKeyString } = await __privateGet(this, _encryptor).encryptWithDetail(
+          __privateGet(this, _password),
+          serializedKeyrings
+        );
+        updatedState.vault = newVault;
+        updatedState.encryptionKey = exportedKeyString;
+      }
+    } else {
+      assertIsValidPassword(__privateGet(this, _password));
+      updatedState.vault = await __privateGet(this, _encryptor).encrypt(
+        __privateGet(this, _password),
+        serializedKeyrings
+      );
+    }
+    if (!updatedState.vault) {
+      throw new Error("KeyringController - Cannot persist vault without vault information" /* MissingVaultData */);
+    }
+    const updatedKeyrings = await __privateMethod(this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
+    this.update((state) => {
+      state.vault = updatedState.vault;
+      state.keyrings = updatedKeyrings;
+      if (updatedState.encryptionKey) {
+        state.encryptionKey = updatedState.encryptionKey;
+        state.encryptionSalt = JSON.parse(updatedState.vault).salt;
+      }
+    });
+    return true;
+  });
+};
+_getAccountsFromKeyrings = new WeakSet();
+getAccountsFromKeyrings_fn = async function() {
+  const keyrings = __privateGet(this, _keyrings);
+  const keyringArrays = await Promise.all(
+    keyrings.map(async (keyring) => keyring.getAccounts())
+  );
+  const addresses = keyringArrays.reduce((res, arr) => {
+    return res.concat(arr);
+  }, []);
+  return addresses.map(normalize);
+};
+_createKeyringWithFirstAccount = new WeakSet();
+createKeyringWithFirstAccount_fn = async function(type, opts) {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  const keyring = await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, type, opts);
+  const [firstAccount] = await keyring.getAccounts();
+  if (!firstAccount) {
+    throw new Error("KeyringController - First Account not found." /* NoFirstAccount */);
+  }
+};
+_newKeyring = new WeakSet();
+newKeyring_fn = async function(type, data) {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  const keyringBuilder = __privateMethod(this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, type);
+  if (!keyringBuilder) {
+    throw new Error(
+      `${"KeyringController - No keyringBuilder found for keyring" /* NoKeyringBuilder */}. Keyring type: ${type}`
+    );
+  }
+  const keyring = keyringBuilder();
+  await keyring.deserialize(data);
+  if (keyring.init) {
+    await keyring.init();
+  }
+  if (type === "HD Key Tree" /* hd */ && (!isObject(data) || !data.mnemonic)) {
+    if (!keyring.generateRandomMnemonic) {
+      throw new Error(
+        "KeyringController - The current keyring does not support the method generateRandomMnemonic." /* UnsupportedGenerateRandomMnemonic */
+      );
+    }
+    keyring.generateRandomMnemonic();
+    await keyring.addAccounts(1);
+  }
+  await __privateMethod(this, _checkForDuplicate, checkForDuplicate_fn).call(this, type, await keyring.getAccounts());
+  if (type === "QR Hardware Wallet Device" /* qr */) {
+    __privateMethod(this, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn).call(this, keyring);
+  }
+  __privateGet(this, _keyrings).push(keyring);
+  return keyring;
+};
+_clearKeyrings = new WeakSet();
+clearKeyrings_fn = async function() {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  for (const keyring of __privateGet(this, _keyrings)) {
+    await __privateMethod(this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
+  }
+  __privateSet(this, _keyrings, []);
+};
+_restoreKeyring = new WeakSet();
+restoreKeyring_fn = async function(serialized) {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  try {
+    const { type, data } = serialized;
+    return await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, type, data);
+  } catch (_) {
+    __privateGet(this, _unsupportedKeyrings).push(serialized);
+    return void 0;
+  }
+};
+_destroyKeyring = new WeakSet();
+destroyKeyring_fn = async function(keyring) {
+  await keyring.destroy?.();
+};
+_removeEmptyKeyrings = new WeakSet();
+removeEmptyKeyrings_fn = async function() {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  const validKeyrings = [];
+  await Promise.all(
+    __privateGet(this, _keyrings).map(async (keyring) => {
+      const accounts = await keyring.getAccounts();
+      if (accounts.length > 0) {
+        validKeyrings.push(keyring);
+      } else {
+        await __privateMethod(this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
+      }
+    })
+  );
+  __privateSet(this, _keyrings, validKeyrings);
+};
+_checkForDuplicate = new WeakSet();
+checkForDuplicate_fn = async function(type, newAccountArray) {
+  const accounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+  switch (type) {
+    case "Simple Key Pair" /* simple */: {
+      const isIncluded = Boolean(
+        accounts.find(
+          (key) => newAccountArray[0] && (key === newAccountArray[0] || key === remove0x(newAccountArray[0]))
+        )
+      );
+      if (isIncluded) {
+        throw new Error("KeyringController - The account you are trying to import is a duplicate" /* DuplicatedAccount */);
+      }
+      return newAccountArray;
+    }
+    default: {
+      return newAccountArray;
+    }
+  }
+};
+_setUnlocked = new WeakSet();
+setUnlocked_fn = function() {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  this.update((state) => {
+    state.isUnlocked = true;
+  });
+  this.messagingSystem.publish(`${name}:unlock`);
+};
+_persistOrRollback = new WeakSet();
+persistOrRollback_fn = async function(fn) {
+  return __privateMethod(this, _withRollback, withRollback_fn).call(this, async ({ releaseLock }) => {
+    const callbackResult = await fn({ releaseLock });
+    await __privateMethod(this, _updateVault, updateVault_fn).call(this);
+    return callbackResult;
+  });
+};
+_withRollback = new WeakSet();
+withRollback_fn = async function(fn) {
+  return __privateMethod(this, _withControllerLock, withControllerLock_fn).call(this, async ({ releaseLock }) => {
+    const currentSerializedKeyrings = await __privateMethod(this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
+    const currentPassword = __privateGet(this, _password);
+    try {
+      return await fn({ releaseLock });
+    } catch (e) {
+      await __privateMethod(this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, currentSerializedKeyrings);
+      __privateSet(this, _password, currentPassword);
+      throw e;
+    }
+  });
+};
+_assertControllerMutexIsLocked = new WeakSet();
+assertControllerMutexIsLocked_fn = function() {
+  if (!__privateGet(this, _controllerOperationMutex).isLocked()) {
+    throw new Error("KeyringController - attempt to update vault during a non mutually exclusive operation" /* ControllerLockRequired */);
+  }
+};
+_withControllerLock = new WeakSet();
+withControllerLock_fn = async function(fn) {
+  return withLock(__privateGet(this, _controllerOperationMutex), fn);
+};
+_withVaultLock = new WeakSet();
+withVaultLock_fn = async function(fn) {
+  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  return withLock(__privateGet(this, _vaultOperationMutex), fn);
+};
+async function withLock(mutex, fn) {
+  const releaseLock = await mutex.acquire();
+  try {
+    return await fn({ releaseLock });
+  } finally {
+    releaseLock();
+  }
+}
+var KeyringController_default = KeyringController;
+
+export {
+  KeyringTypes,
+  isCustodyKeyring,
+  AccountImportStrategy,
+  SignTypedDataVersion,
+  keyringBuilderFactory,
+  getDefaultKeyringState,
+  KeyringController,
+  KeyringController_default
+};
+//# sourceMappingURL=chunk-7A7D7THR.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-7A7D7THR.mjs.map b/dist/chunk-7A7D7THR.mjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..1e66368615fd8c5550c36f68586a25339b072f2f
--- /dev/null
+++ b/dist/chunk-7A7D7THR.mjs.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/KeyringController.ts"],"sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport { isValidPrivate, toBuffer, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize as ethNormalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthKeyring,\n  EthUserOperation,\n  EthUserOperationPatch,\n  KeyringExecutionContext,\n} from '@metamask/keyring-api';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type {\n  Eip1024EncryptedData,\n  Hex,\n  Json,\n  KeyringClass,\n} from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  isObject,\n  isStrictHexString,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { MutexInterface } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nimport { KeyringControllerError } from './constants';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  never,\n  never\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (\n    key: unknown,\n    object: Json,\n  ) => Promise<encryptorUtils.EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<encryptorUtils.DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n\nexport type KeyringSelector =\n  | {\n      type: string;\n      index?: number;\n    }\n  | {\n      address: Hex;\n    };\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<T> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<T>;\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring<Json>,\n): asserts keyring is EthKeyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(KeyringControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(KeyringControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: EthKeyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `string[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    accounts: accounts.map(normalize) as string[],\n  };\n}\n\n/**\n * Check if address is an ethereum address\n *\n * @param address - An address.\n * @returns Returns true if the address is an ethereum one, false otherwise.\n */\nfunction isEthAddress(address: string): boolean {\n  // We first check if it's a matching `Hex` string, so that is narrows down\n  // `address` as an `Hex` type, allowing us to use `isValidHexAddress`\n  return (\n    // NOTE: This function only checks for lowercased strings\n    isStrictHexString(address.toLowerCase()) &&\n    // This checks for lowercased addresses and checksum addresses too\n    isValidHexAddress(address as Hex)\n  );\n}\n\n/**\n * Normalize ethereum or non-EVM address.\n *\n * @param address - Ethereum or non-EVM address.\n * @returns The normalized address.\n */\nfunction normalize(address: string): string | undefined {\n  // Since the `KeyringController` is only dealing with address, we have\n  // no other way to get the associated account type with this address. So we\n  // are down to check the actual address format for now\n  // TODO: Find a better way to not have those runtime checks based on the\n  //       address value!\n  return isEthAddress(address) ? ethNormalize(address) : address;\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  readonly #controllerOperationMutex = new Mutex();\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  #keyringBuilders: { (): EthKeyring<Json>; type: string }[];\n\n  #keyrings: EthKeyring<Json>[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  #cacheEncryptionKey: boolean;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? defaultKeyringBuilders.concat(keyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccount(accountCount?: number): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const oldAccounts = await primaryKeyring.getAccounts();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n        // we return the account already existing at index `accountCount`\n        const existingAccount = oldAccounts[accountCount];\n\n        if (!existingAccount) {\n          throw new Error(`Can't find account at index ${accountCount}`);\n        }\n\n        return existingAccount;\n      }\n\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to the added account address\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    // READ THIS CAREFULLY:\n    // We still uses `Hex` here, since we are not using this method when creating\n    // and account using a \"Snap Keyring\". This function assume the `keyring` is\n    // ethereum compatible, but \"Snap Keyring\" might not be.\n    return this.#persistOrRollback(async () => {\n      const oldAccounts = await this.#getAccountsFromKeyrings();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n\n        const existingAccount = oldAccounts[accountCount];\n        assertIsStrictHexString(existingAccount);\n\n        return existingAccount;\n      }\n\n      await keyring.addAccounts(1);\n\n      const addedAccountAddress = (await this.#getAccountsFromKeyrings()).find(\n        (selectedAddress) => !oldAccounts.includes(selectedAddress),\n      );\n      assertIsStrictHexString(addedAccountAddress);\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccountWithoutUpdate(): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n    });\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    return this.#persistOrRollback(async () => {\n      const accounts = await this.#getAccountsFromKeyrings();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n    });\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    return this.#persistOrRollback(async () => this.#newKeyring(type, opts));\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyrings[0]);\n    return this.#keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts from every keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    return this.state.keyrings.reduce<string[]>(\n      (accounts, keyring) => accounts.concat(keyring.accounts),\n      [],\n    );\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    const address = ethNormalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(address, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    const address = normalize(account);\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(address);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyrings.filter((keyring) => keyring.type === type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @deprecated This method is being phased out in favor of `withKeyring`.\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#persistOrRollback(async () => true);\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to the imported account address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      let privateKey;\n      switch (strategy) {\n        case 'privateKey':\n          const [importedKey] = args;\n          if (!importedKey) {\n            throw new Error('Cannot import an empty key.');\n          }\n          const prefixed = add0x(importedKey);\n\n          let bufferedPrivateKey;\n          try {\n            bufferedPrivateKey = toBuffer(prefixed);\n          } catch {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          if (\n            !isValidPrivate(bufferedPrivateKey) ||\n            // ensures that the key is 64 bytes long\n            getBinarySize(prefixed) !== 64 + '0x'.length\n          ) {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          privateKey = remove0x(prefixed);\n          break;\n        case 'json':\n          let wallet;\n          const [input, password] = args;\n          try {\n            wallet = importers.fromEtherWallet(input, password);\n          } catch (e) {\n            wallet = wallet || (await Wallet.fromV3(input, password, true));\n          }\n          privateKey = bytesToHex(wallet.getPrivateKey());\n          break;\n        default:\n          throw new Error(`Unexpected import strategy: '${strategy}'`);\n      }\n      const newKeyring = (await this.#newKeyring(KeyringTypes.simple, [\n        privateKey,\n      ])) as EthKeyring<Json>;\n      const accounts = await newKeyring.getAccounts();\n      return accounts[0];\n    });\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving when the account is removed.\n   */\n  async removeAccount(address: string): Promise<void> {\n    await this.#persistOrRollback(async () => {\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n\n      // Not all the keyrings support this, so we have to check\n      if (!keyring.removeAccount) {\n        throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n      }\n\n      // The `removeAccount` method of snaps keyring is async. We have to update\n      // the interface of the other keyrings to be async as well.\n      // eslint-disable-next-line @typescript-eslint/await-thenable\n      // FIXME: We do cast to `Hex` to makes the type checker happy here, and\n      // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those\n      // type would need to be updated for a full non-EVM support.\n      await keyring.removeAccount(address as Hex);\n\n      const accounts = await keyring.getAccounts();\n      // Check if this was the last/only account\n      if (accounts.length === 0) {\n        await this.#removeEmptyKeyrings();\n      }\n    });\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving when the operation completes.\n   */\n  async setLocked(): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#unsubscribeFromQRKeyringsEvents();\n\n      this.#password = undefined;\n      await this.#clearKeyrings();\n\n      this.update((state) => {\n        state.isUnlocked = false;\n        state.keyrings = [];\n        delete state.encryptionKey;\n        delete state.encryptionSalt;\n      });\n\n      this.messagingSystem.publish(`${name}:lock`);\n    });\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = ethNormalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthBaseUserOperation> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(\n      address,\n      transactions,\n      executionContext,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthUserOperationPatch> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<string> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Changes the password used to encrypt the vault.\n   *\n   * @param password - The new password.\n   * @returns Promise resolving when the operation completes.\n   */\n  changePassword(password: string): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      if (!this.state.isUnlocked) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      assertIsValidPassword(password);\n\n      this.#password = password;\n      // We need to clear encryption key and salt from state\n      // to force the controller to re-encrypt the vault using\n      // the new password.\n      if (this.#cacheEncryptionKey) {\n        this.update((state) => {\n          delete state.encryptionKey;\n          delete state.encryptionSalt;\n        });\n      }\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(\n        undefined,\n        encryptionKey,\n        encryptionSalt,\n      );\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitPassword(password: string): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(password);\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @param options - Additional options.\n   * @param options.createIfMissing - Whether to create a new keyring if the selected one is missing.\n   * @param options.createWithData - Optional data to use when creating a new keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   * @deprecated This method overload is deprecated. Use `withKeyring` without options instead.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown },\n  ): Promise<CallbackResult>;\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n  ): Promise<CallbackResult>;\n\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown } = {\n      createIfMissing: false,\n    },\n  ): Promise<CallbackResult> {\n    return this.#persistOrRollback(async () => {\n      let keyring: SelectedKeyring | undefined;\n\n      if ('address' in selector) {\n        keyring = (await this.getKeyringForAccount(selector.address)) as\n          | SelectedKeyring\n          | undefined;\n      } else {\n        keyring = this.getKeyringsByType(selector.type)[selector.index || 0] as\n          | SelectedKeyring\n          | undefined;\n\n        if (!keyring && options.createIfMissing) {\n          keyring = (await this.#newKeyring(\n            selector.type,\n            options.createWithData,\n          )) as SelectedKeyring;\n        }\n      }\n\n      if (!keyring) {\n        throw new Error(KeyringControllerError.KeyringNotFound);\n      }\n\n      const result = await operation(keyring);\n\n      if (Object.is(result, keyring)) {\n        // Access to a keyring instance outside of controller safeguards\n        // should be discouraged, as it can lead to unexpected behavior.\n        // This error is thrown to prevent consumers using `withKeyring`\n        // as a way to get a reference to a keyring instance.\n        throw new Error(KeyringControllerError.UnsafeDirectKeyringAccess);\n      }\n\n      return result;\n    });\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return (\n      this.getQRKeyring() ||\n      (await this.#persistOrRollback(async () => this.#addQRKeyring()))\n    );\n  }\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n      keyring.deserialize(serialized);\n    });\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    return this.#persistOrRollback(async () => {\n      try {\n        const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n        let accounts;\n        switch (page) {\n          case -1:\n            accounts = await keyring.getPreviousPage();\n            break;\n          case 1:\n            accounts = await keyring.getNextPage();\n            break;\n          default:\n            accounts = await keyring.getFirstPage();\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return accounts.map((account: any) => {\n          return {\n            ...account,\n            balance: '0x0',\n          };\n        });\n      } catch (e) {\n        // TODO: Add test case for when keyring throws\n        /* istanbul ignore next */\n        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n      }\n    });\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n\n      keyring.setAccountToUnlock(index);\n      await keyring.addAccounts(1);\n    });\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    return keyring.type;\n  }\n\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring();\n\n      if (!keyring) {\n        return { removedAccounts: [], remainingAccounts: [] };\n      }\n\n      const allAccounts = (await this.#getAccountsFromKeyrings()) as string[];\n      keyring.forgetDevice();\n      const remainingAccounts =\n        (await this.#getAccountsFromKeyrings()) as string[];\n      const removedAccounts = allAccounts.filter(\n        (address: string) => !remainingAccounts.includes(address),\n      );\n      return { removedAccounts, remainingAccounts };\n    });\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring<Json>; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return (await this.#newKeyring(KeyringTypes.qr)) as unknown as QRKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n\n    this.update((state) => {\n      delete state.encryptionKey;\n      delete state.encryptionSalt;\n    });\n\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n  }\n\n  /**\n   * Get the updated array of each keyring's type and\n   * accounts list.\n   *\n   * @returns A promise resolving to the updated keyrings array.\n   */\n  async #getUpdatedKeyrings(): Promise<KeyringObject[]> {\n    return Promise.all(this.#keyrings.map(displayForKeyring));\n  }\n\n  /**\n   * Serialize the current array of keyring instances,\n   * including unsupported keyrings by default.\n   *\n   * @param options - Method options.\n   * @param options.includeUnsupported - Whether to include unsupported keyrings.\n   * @returns The serialized keyrings.\n   */\n  async #getSerializedKeyrings(\n    { includeUnsupported }: { includeUnsupported: boolean } = {\n      includeUnsupported: true,\n    },\n  ): Promise<SerializedKeyring[]> {\n    const serializedKeyrings = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    if (includeUnsupported) {\n      serializedKeyrings.push(...this.#unsupportedKeyrings);\n    }\n\n    return serializedKeyrings;\n  }\n\n  /**\n   * Restore a serialized keyrings array.\n   *\n   * @param serializedKeyrings - The serialized keyrings array.\n   */\n  async #restoreSerializedKeyrings(\n    serializedKeyrings: SerializedKeyring[],\n  ): Promise<void> {\n    await this.#clearKeyrings();\n\n    for (const serializedKeyring of serializedKeyrings) {\n      await this.#restoreKeyring(serializedKeyring);\n    }\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<EthKeyring<Json>[]> {\n    return this.#withVaultLock(async ({ releaseLock }) => {\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(KeyringControllerError.VaultError);\n      }\n\n      let vault;\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (password) {\n          const result = await this.#encryptor.decryptWithDetail(\n            password,\n            encryptedVault,\n          );\n          vault = result.vault;\n          this.#password = password;\n\n          updatedState.encryptionKey = result.exportedKeyString;\n          updatedState.encryptionSalt = result.salt;\n        } else {\n          const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n          if (encryptionSalt !== parsedEncryptedVault.salt) {\n            throw new Error(KeyringControllerError.ExpiredCredentials);\n          }\n\n          if (typeof encryptionKey !== 'string') {\n            throw new TypeError(KeyringControllerError.WrongPasswordType);\n          }\n\n          const key = await this.#encryptor.importKey(encryptionKey);\n          vault = await this.#encryptor.decryptWithKey(\n            key,\n            parsedEncryptedVault,\n          );\n\n          // This call is required on the first call because encryptionKey\n          // is not yet inside the memStore\n          updatedState.encryptionKey = encryptionKey;\n          // we can safely assume that encryptionSalt is defined here\n          // because we compare it with the salt from the vault\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          updatedState.encryptionSalt = encryptionSalt!;\n        }\n      } else {\n        if (typeof password !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        vault = await this.#encryptor.decrypt(password, encryptedVault);\n        this.#password = password;\n      }\n\n      if (!isSerializedKeyringsArray(vault)) {\n        throw new Error(KeyringControllerError.VaultDataError);\n      }\n\n      await this.#restoreSerializedKeyrings(vault);\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey || updatedState.encryptionSalt) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = updatedState.encryptionSalt;\n        }\n      });\n\n      if (\n        this.#password &&\n        (!this.#cacheEncryptionKey || !encryptionKey) &&\n        this.#encryptor.isVaultUpdated &&\n        !this.#encryptor.isVaultUpdated(encryptedVault)\n      ) {\n        // The lock needs to be released before persisting the keyrings\n        // to avoid deadlock\n        releaseLock();\n        // Re-encrypt the vault with safer method if one is available\n        await this.#updateVault();\n      }\n\n      return this.#keyrings;\n    });\n  }\n\n  /**\n   * Update the vault with the current keyrings.\n   *\n   * @returns A promise resolving to `true` if the operation is successful.\n   */\n  #updateVault(): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      const { encryptionKey, encryptionSalt } = this.state;\n\n      if (!this.#password && !encryptionKey) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      const serializedKeyrings = await this.#getSerializedKeyrings();\n\n      if (\n        !serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)\n      ) {\n        throw new Error(KeyringControllerError.NoHdKeyring);\n      }\n\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (encryptionKey) {\n          const key = await this.#encryptor.importKey(encryptionKey);\n          const vaultJSON = await this.#encryptor.encryptWithKey(\n            key,\n            serializedKeyrings,\n          );\n          vaultJSON.salt = encryptionSalt;\n          updatedState.vault = JSON.stringify(vaultJSON);\n        } else if (this.#password) {\n          const { vault: newVault, exportedKeyString } =\n            await this.#encryptor.encryptWithDetail(\n              this.#password,\n              serializedKeyrings,\n            );\n\n          updatedState.vault = newVault;\n          updatedState.encryptionKey = exportedKeyString;\n        }\n      } else {\n        assertIsValidPassword(this.#password);\n        updatedState.vault = await this.#encryptor.encrypt(\n          this.#password,\n          serializedKeyrings,\n        );\n      }\n\n      if (!updatedState.vault) {\n        throw new Error(KeyringControllerError.MissingVaultData);\n      }\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n      this.update((state) => {\n        state.vault = updatedState.vault;\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = JSON.parse(updatedState.vault as string).salt;\n        }\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Retrieves all the accounts from keyrings instances\n   * that are currently in memory.\n   *\n   * @returns A promise resolving to an array of accounts.\n   */\n  async #getAccountsFromKeyrings(): Promise<string[]> {\n    const keyrings = this.#keyrings;\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `string[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    return addresses.map(normalize) as string[];\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = (await this.#newKeyring(type, opts)) as EthKeyring<Json>;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #newKeyring(type: string, data?: unknown): Promise<EthKeyring<Json>> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    // @ts-expect-error Enforce data type after updating clients\n    await keyring.deserialize(data);\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    if (type === KeyringTypes.hd && (!isObject(data) || !data.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    await this.#checkForDuplicate(type, await keyring.getAccounts());\n\n    if (type === KeyringTypes.qr) {\n      // In case of a QR keyring type, we need to subscribe\n      // to its events after creating it\n      this.#subscribeToQRKeyringEvents(keyring as unknown as QRKeyring);\n    }\n\n    this.#keyrings.push(keyring);\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    this.#assertControllerMutexIsLocked();\n    for (const keyring of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<EthKeyring<Json> | undefined> {\n    this.#assertControllerMutexIsLocked();\n\n    try {\n      const { type, data } = serialized;\n      return await this.#newKeyring(type, data);\n    } catch (_) {\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring<Json>) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n    const validKeyrings: EthKeyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async (keyring: EthKeyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async #checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.#getAccountsFromKeyrings();\n\n    switch (type) {\n      case KeyringTypes.simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.#assertControllerMutexIsLocked();\n\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and save the keyrings to state after it, or rollback to their\n   * previous state in case of error.\n   *\n   * @param fn - The function to execute.\n   * @returns The result of the function.\n   */\n  async #persistOrRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withRollback(async ({ releaseLock }) => {\n      const callbackResult = await fn({ releaseLock });\n      // State is committed only if the operation is successful\n      await this.#updateVault();\n\n      return callbackResult;\n    });\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and rollback keyrings and password states in case of error.\n   *\n   * @param fn - The function to execute atomically.\n   * @returns The result of the function.\n   */\n  async #withRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withControllerLock(async ({ releaseLock }) => {\n      const currentSerializedKeyrings = await this.#getSerializedKeyrings();\n      const currentPassword = this.#password;\n\n      try {\n        return await fn({ releaseLock });\n      } catch (e) {\n        // Keyrings and password are restored to their previous state\n        await this.#restoreSerializedKeyrings(currentSerializedKeyrings);\n        this.#password = currentPassword;\n\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Assert that the controller mutex is locked.\n   *\n   * @throws If the controller mutex is not locked.\n   */\n  #assertControllerMutexIsLocked() {\n    if (!this.#controllerOperationMutex.isLocked()) {\n      throw new Error(KeyringControllerError.ControllerLockRequired);\n    }\n  }\n\n  /**\n   * Lock the controller mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This wrapper ensures that each mutable operation that interacts with the\n   * controller and that changes its state is executed in a mutually exclusive way,\n   * preventing unsafe concurrent access that could lead to unpredictable behavior.\n   *\n   * @param fn - The function to execute while the controller mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withControllerLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return withLock(this.#controllerOperationMutex, fn);\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param fn - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    this.#assertControllerMutexIsLocked();\n\n    return withLock(this.#vaultOperationMutex, fn);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param fn - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<T>(\n  mutex: Mutex,\n  fn: MutuallyExclusiveCallback<T>,\n): Promise<T> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await fn({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n\nexport default KeyringController;\n"],"mappings":"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","names":["KeyringTypes","AccountImportStrategy","SignTypedDataVersion"]}
\ No newline at end of file
diff --git a/dist/chunk-BRS27QHF.js b/dist/chunk-BRS27QHF.js
deleted file mode 100644
index 93bf7c6e9b238aed269aabc193ede499d7efb76a..0000000000000000000000000000000000000000
--- a/dist/chunk-BRS27QHF.js
+++ /dev/null
@@ -1,1500 +0,0 @@
-"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-
-
-
-var _chunkNOCGQCUMjs = require('./chunk-NOCGQCUM.js');
-
-// src/KeyringController.ts
-var _util = require('@ethereumjs/util');
-var _basecontroller = require('@metamask/base-controller');
-var _browserpassworder = require('@metamask/browser-passworder'); var encryptorUtils = _interopRequireWildcard(_browserpassworder);
-var _ethhdkeyring = require('@metamask/eth-hd-keyring'); var _ethhdkeyring2 = _interopRequireDefault(_ethhdkeyring);
-var _ethsigutil = require('@metamask/eth-sig-util');
-var _ethsimplekeyring = require('@metamask/eth-simple-keyring'); var _ethsimplekeyring2 = _interopRequireDefault(_ethsimplekeyring);
-
-
-
-
-
-
-
-
-
-
-var _utils = require('@metamask/utils');
-var _asyncmutex = require('async-mutex');
-var _ethereumjswallet = require('ethereumjs-wallet'); var _ethereumjswallet2 = _interopRequireDefault(_ethereumjswallet);
-var name = "KeyringController";
-var KeyringTypes = /* @__PURE__ */ ((KeyringTypes2) => {
-  KeyringTypes2["simple"] = "Simple Key Pair";
-  KeyringTypes2["hd"] = "HD Key Tree";
-  KeyringTypes2["qr"] = "QR Hardware Wallet Device";
-  KeyringTypes2["trezor"] = "Trezor Hardware";
-  KeyringTypes2["ledger"] = "Ledger Hardware";
-  KeyringTypes2["lattice"] = "Lattice Hardware";
-  KeyringTypes2["snap"] = "Snap Keyring";
-  return KeyringTypes2;
-})(KeyringTypes || {});
-var isCustodyKeyring = (keyringType) => {
-  return keyringType.startsWith("Custody");
-};
-var AccountImportStrategy = /* @__PURE__ */ ((AccountImportStrategy2) => {
-  AccountImportStrategy2["privateKey"] = "privateKey";
-  AccountImportStrategy2["json"] = "json";
-  return AccountImportStrategy2;
-})(AccountImportStrategy || {});
-var SignTypedDataVersion = /* @__PURE__ */ ((SignTypedDataVersion2) => {
-  SignTypedDataVersion2["V1"] = "V1";
-  SignTypedDataVersion2["V3"] = "V3";
-  SignTypedDataVersion2["V4"] = "V4";
-  return SignTypedDataVersion2;
-})(SignTypedDataVersion || {});
-function keyringBuilderFactory(KeyringConstructor) {
-  const builder = () => new KeyringConstructor();
-  builder.type = KeyringConstructor.type;
-  return builder;
-}
-var defaultKeyringBuilders = [
-  keyringBuilderFactory(_ethsimplekeyring2.default),
-  keyringBuilderFactory(_ethhdkeyring2.default)
-];
-var getDefaultKeyringState = () => {
-  return {
-    isUnlocked: false,
-    keyrings: []
-  };
-};
-function assertHasUint8ArrayMnemonic(keyring) {
-  if (!(_utils.hasProperty.call(void 0, keyring, "mnemonic") && keyring.mnemonic instanceof Uint8Array)) {
-    throw new Error("Can't get mnemonic bytes from keyring");
-  }
-}
-function assertIsExportableKeyEncryptor(encryptor) {
-  if (!("importKey" in encryptor && typeof encryptor.importKey === "function" && "decryptWithKey" in encryptor && typeof encryptor.decryptWithKey === "function" && "encryptWithKey" in encryptor && typeof encryptor.encryptWithKey === "function")) {
-    throw new Error("KeyringController - The encryptor does not support encryption key export." /* UnsupportedEncryptionKeyExport */);
-  }
-}
-function assertIsValidPassword(password) {
-  if (typeof password !== "string") {
-    throw new Error("KeyringController - Password must be of type string." /* WrongPasswordType */);
-  }
-  if (!password || !password.length) {
-    throw new Error("KeyringController - Password cannot be empty." /* InvalidEmptyPassword */);
-  }
-}
-function isSerializedKeyringsArray(array) {
-  return typeof array === "object" && Array.isArray(array) && array.every((value) => value.type && _utils.isValidJson.call(void 0, value.data));
-}
-async function displayForKeyring(keyring) {
-  const accounts = await keyring.getAccounts();
-  return {
-    type: keyring.type,
-    // Cast to `string[]` here is safe here because `accounts` has no nullish
-    // values, and `normalize` returns `string` unless given a nullish value
-    accounts: accounts.map(normalize)
-  };
-}
-function isEthAddress(address) {
-  return (
-    // NOTE: This function only checks for lowercased strings
-    _utils.isStrictHexString.call(void 0, address.toLowerCase()) && // This checks for lowercased addresses and checksum addresses too
-    _utils.isValidHexAddress.call(void 0, address)
-  );
-}
-function normalize(address) {
-  return isEthAddress(address) ? _ethsigutil.normalize.call(void 0, address) : address;
-}
-var _controllerOperationMutex, _vaultOperationMutex, _keyringBuilders, _keyrings, _unsupportedKeyrings, _password, _encryptor, _cacheEncryptionKey, _qrKeyringStateListener, _registerMessageHandlers, registerMessageHandlers_fn, _getKeyringBuilderForType, getKeyringBuilderForType_fn, _addQRKeyring, addQRKeyring_fn, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn, _getUpdatedKeyrings, getUpdatedKeyrings_fn, _getSerializedKeyrings, getSerializedKeyrings_fn, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn, _unlockKeyrings, unlockKeyrings_fn, _updateVault, updateVault_fn, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn, _newKeyring, newKeyring_fn, _clearKeyrings, clearKeyrings_fn, _restoreKeyring, restoreKeyring_fn, _destroyKeyring, destroyKeyring_fn, _removeEmptyKeyrings, removeEmptyKeyrings_fn, _checkForDuplicate, checkForDuplicate_fn, _setUnlocked, setUnlocked_fn, _persistOrRollback, persistOrRollback_fn, _withRollback, withRollback_fn, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn, _withControllerLock, withControllerLock_fn, _withVaultLock, withVaultLock_fn;
-var KeyringController = class extends _basecontroller.BaseController {
-  /**
-   * Creates a KeyringController instance.
-   *
-   * @param options - Initial options used to configure this controller
-   * @param options.encryptor - An optional object for defining encryption schemes.
-   * @param options.keyringBuilders - Set a new name for account.
-   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.
-   * @param options.messenger - A restricted controller messenger.
-   * @param options.state - Initial state to set on this controller.
-   */
-  constructor(options) {
-    const {
-      encryptor = encryptorUtils,
-      keyringBuilders,
-      messenger,
-      state
-    } = options;
-    super({
-      name,
-      metadata: {
-        vault: { persist: true, anonymous: false },
-        isUnlocked: { persist: false, anonymous: true },
-        keyrings: { persist: false, anonymous: false },
-        encryptionKey: { persist: false, anonymous: false },
-        encryptionSalt: { persist: false, anonymous: false }
-      },
-      messenger,
-      state: {
-        ...getDefaultKeyringState(),
-        ...state
-      }
-    });
-    /**
-     * Constructor helper for registering this controller's messaging system
-     * actions.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _registerMessageHandlers);
-    /**
-     * Get the keyring builder for the given `type`.
-     *
-     * @param type - The type of keyring to get the builder for.
-     * @returns The keyring builder, or undefined if none exists.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getKeyringBuilderForType);
-    /**
-     * Add qr hardware keyring.
-     *
-     * @returns The added keyring
-     * @throws If a QRKeyring builder is not provided
-     * when initializing the controller
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _addQRKeyring);
-    /**
-     * Subscribe to a QRKeyring state change events and
-     * forward them through the messaging system.
-     *
-     * @param qrKeyring - The QRKeyring instance to subscribe to
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _subscribeToQRKeyringEvents);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _unsubscribeFromQRKeyringsEvents);
-    /**
-     * Create new vault with an initial keyring
-     *
-     * Destroys any old encrypted storage,
-     * creates a new encrypted store with the given password,
-     * creates a new wallet with 1 account.
-     *
-     * @fires KeyringController:unlock
-     * @param password - The password to encrypt the vault with.
-     * @param keyring - A object containing the params to instantiate a new keyring.
-     * @param keyring.type - The keyring type.
-     * @param keyring.opts - Optional parameters required to instantiate the keyring.
-     * @returns A promise that resolves to the state.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _createNewVaultWithKeyring);
-    /**
-     * Get the updated array of each keyring's type and
-     * accounts list.
-     *
-     * @returns A promise resolving to the updated keyrings array.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getUpdatedKeyrings);
-    /**
-     * Serialize the current array of keyring instances,
-     * including unsupported keyrings by default.
-     *
-     * @param options - Method options.
-     * @param options.includeUnsupported - Whether to include unsupported keyrings.
-     * @returns The serialized keyrings.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getSerializedKeyrings);
-    /**
-     * Restore a serialized keyrings array.
-     *
-     * @param serializedKeyrings - The serialized keyrings array.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _restoreSerializedKeyrings);
-    /**
-     * Unlock Keyrings, decrypting the vault and deserializing all
-     * keyrings contained in it, using a password or an encryption key with salt.
-     *
-     * @param password - The keyring controller password.
-     * @param encryptionKey - An exported key string to unlock keyrings with.
-     * @param encryptionSalt - The salt used to encrypt the vault.
-     * @returns A promise resolving to the deserialized keyrings array.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _unlockKeyrings);
-    /**
-     * Update the vault with the current keyrings.
-     *
-     * @returns A promise resolving to `true` if the operation is successful.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _updateVault);
-    /**
-     * Retrieves all the accounts from keyrings instances
-     * that are currently in memory.
-     *
-     * @returns A promise resolving to an array of accounts.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getAccountsFromKeyrings);
-    /**
-     * Create a new keyring, ensuring that the first account is
-     * also created.
-     *
-     * @param type - Keyring type to instantiate.
-     * @param opts - Optional parameters required to instantiate the keyring.
-     * @returns A promise that resolves if the operation is successful.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _createKeyringWithFirstAccount);
-    /**
-     * Instantiate, initialize and return a new keyring of the given `type`,
-     * using the given `opts`. The keyring is built using the keyring builder
-     * registered for the given `type`.
-     *
-     *
-     * @param type - The type of keyring to add.
-     * @param data - The data to restore a previously serialized keyring.
-     * @returns The new keyring.
-     * @throws If the keyring includes duplicated accounts.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _newKeyring);
-    /**
-     * Remove all managed keyrings, destroying all their
-     * instances in memory.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _clearKeyrings);
-    /**
-     * Restore a Keyring from a provided serialized payload.
-     * On success, returns the resulting keyring instance.
-     *
-     * @param serialized - The serialized keyring.
-     * @returns The deserialized keyring or undefined if the keyring type is unsupported.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _restoreKeyring);
-    /**
-     * Destroy Keyring
-     *
-     * Some keyrings support a method called `destroy`, that destroys the
-     * keyring along with removing all its event listeners and, in some cases,
-     * clears the keyring bridge iframe from the DOM.
-     *
-     * @param keyring - The keyring to destroy.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _destroyKeyring);
-    /**
-     * Remove empty keyrings.
-     *
-     * Loops through the keyrings and removes the ones with empty accounts
-     * (usually after removing the last / only account) from a keyring.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _removeEmptyKeyrings);
-    /**
-     * Checks for duplicate keypairs, using the the first account in the given
-     * array. Rejects if a duplicate is found.
-     *
-     * Only supports 'Simple Key Pair'.
-     *
-     * @param type - The key pair type to check for.
-     * @param newAccountArray - Array of new accounts.
-     * @returns The account, if no duplicate is found.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _checkForDuplicate);
-    /**
-     * Set the `isUnlocked` to true and notify listeners
-     * through the messenger.
-     *
-     * @fires KeyringController:unlock
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _setUnlocked);
-    /**
-     * Execute the given function after acquiring the controller lock
-     * and save the keyrings to state after it, or rollback to their
-     * previous state in case of error.
-     *
-     * @param fn - The function to execute.
-     * @returns The result of the function.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _persistOrRollback);
-    /**
-     * Execute the given function after acquiring the controller lock
-     * and rollback keyrings and password states in case of error.
-     *
-     * @param fn - The function to execute atomically.
-     * @returns The result of the function.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _withRollback);
-    /**
-     * Assert that the controller mutex is locked.
-     *
-     * @throws If the controller mutex is not locked.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _assertControllerMutexIsLocked);
-    /**
-     * Lock the controller mutex before executing the given function,
-     * and release it after the function is resolved or after an
-     * error is thrown.
-     *
-     * This wrapper ensures that each mutable operation that interacts with the
-     * controller and that changes its state is executed in a mutually exclusive way,
-     * preventing unsafe concurrent access that could lead to unpredictable behavior.
-     *
-     * @param fn - The function to execute while the controller mutex is locked.
-     * @returns The result of the function.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _withControllerLock);
-    /**
-     * Lock the vault mutex before executing the given function,
-     * and release it after the function is resolved or after an
-     * error is thrown.
-     *
-     * This ensures that each operation that interacts with the vault
-     * is executed in a mutually exclusive way.
-     *
-     * @param fn - The function to execute while the vault mutex is locked.
-     * @returns The result of the function.
-     */
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _withVaultLock);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _controllerOperationMutex, new (0, _asyncmutex.Mutex)());
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _vaultOperationMutex, new (0, _asyncmutex.Mutex)());
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _keyringBuilders, void 0);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _keyrings, void 0);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _unsupportedKeyrings, void 0);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _password, void 0);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _encryptor, void 0);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _cacheEncryptionKey, void 0);
-    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _qrKeyringStateListener, void 0);
-    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyringBuilders, keyringBuilders ? defaultKeyringBuilders.concat(keyringBuilders) : defaultKeyringBuilders);
-    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _encryptor, encryptor);
-    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, []);
-    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _unsupportedKeyrings, []);
-    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _cacheEncryptionKey, Boolean(options.cacheEncryptionKey));
-    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
-      assertIsExportableKeyEncryptor(encryptor);
-    }
-    _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _registerMessageHandlers, registerMessageHandlers_fn).call(this);
-  }
-  /**
-   * Adds a new account to the default (first) HD seed phrase keyring.
-   *
-   * @param accountCount - Number of accounts before adding a new one, used to
-   * make the method idempotent.
-   * @returns Promise resolving to the added account address.
-   */
-  async addNewAccount(accountCount) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
-      if (!primaryKeyring) {
-        throw new Error("No HD keyring found");
-      }
-      const oldAccounts = await primaryKeyring.getAccounts();
-      if (accountCount && oldAccounts.length !== accountCount) {
-        if (accountCount > oldAccounts.length) {
-          throw new Error("Account out of sequence");
-        }
-        const existingAccount = oldAccounts[accountCount];
-        if (!existingAccount) {
-          throw new Error(`Can't find account at index ${accountCount}`);
-        }
-        return existingAccount;
-      }
-      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
-      await this.verifySeedPhrase();
-      return addedAccountAddress;
-    });
-  }
-  /**
-   * Adds a new account to the specified keyring.
-   *
-   * @param keyring - Keyring to add the account to.
-   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.
-   * @returns Promise resolving to the added account address
-   */
-  async addNewAccountForKeyring(keyring, accountCount) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const oldAccounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      if (accountCount && oldAccounts.length !== accountCount) {
-        if (accountCount > oldAccounts.length) {
-          throw new Error("Account out of sequence");
-        }
-        const existingAccount = oldAccounts[accountCount];
-        _utils.assertIsStrictHexString.call(void 0, existingAccount);
-        return existingAccount;
-      }
-      await keyring.addAccounts(1);
-      const addedAccountAddress = (await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this)).find(
-        (selectedAddress) => !oldAccounts.includes(selectedAddress)
-      );
-      _utils.assertIsStrictHexString.call(void 0, addedAccountAddress);
-      return addedAccountAddress;
-    });
-  }
-  /**
-   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.
-   *
-   * @returns Promise resolving to the added account address.
-   */
-  async addNewAccountWithoutUpdate() {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
-      if (!primaryKeyring) {
-        throw new Error("No HD keyring found");
-      }
-      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
-      await this.verifySeedPhrase();
-      return addedAccountAddress;
-    });
-  }
-  /**
-   * Effectively the same as creating a new keychain then populating it
-   * using the given seed phrase.
-   *
-   * @param password - Password to unlock keychain.
-   * @param seed - A BIP39-compliant seed phrase as Uint8Array,
-   * either as a string or an array of UTF-8 bytes that represent the string.
-   * @returns Promise resolving when the operation ends successfully.
-   */
-  async createNewVaultAndRestore(password, seed) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      assertIsValidPassword(password);
-      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
-        type: "HD Key Tree" /* hd */,
-        opts: {
-          mnemonic: seed,
-          numberOfAccounts: 1
-        }
-      });
-    });
-  }
-  /**
-   * Create a new primary keychain and wipe any previous keychains.
-   *
-   * @param password - Password to unlock the new vault.
-   * @returns Promise resolving when the operation ends successfully.
-   */
-  async createNewVaultAndKeychain(password) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const accounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      if (!accounts.length) {
-        await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
-          type: "HD Key Tree" /* hd */
-        });
-      }
-    });
-  }
-  /**
-   * Adds a new keyring of the given `type`.
-   *
-   * @param type - Keyring type name.
-   * @param opts - Keyring options.
-   * @throws If a builder for the given `type` does not exist.
-   * @returns Promise resolving to the added keyring.
-   */
-  async addNewKeyring(type, opts) {
-    if (type === "QR Hardware Wallet Device" /* qr */) {
-      return this.getOrAddQRKeyring();
-    }
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, type, opts));
-  }
-  /**
-   * Method to verify a given password validity. Throws an
-   * error if the password is invalid.
-   *
-   * @param password - Password of the keyring.
-   */
-  async verifyPassword(password) {
-    if (!this.state.vault) {
-      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
-    }
-    await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decrypt(password, this.state.vault);
-  }
-  /**
-   * Returns the status of the vault.
-   *
-   * @returns Boolean returning true if the vault is unlocked.
-   */
-  isUnlocked() {
-    return this.state.isUnlocked;
-  }
-  /**
-   * Gets the seed phrase of the HD keyring.
-   *
-   * @param password - Password of the keyring.
-   * @returns Promise resolving to the seed phrase.
-   */
-  async exportSeedPhrase(password) {
-    await this.verifyPassword(password);
-    assertHasUint8ArrayMnemonic(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings)[0]);
-    return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings)[0].mnemonic;
-  }
-  /**
-   * Gets the private key from the keyring controlling an address.
-   *
-   * @param password - Password of the keyring.
-   * @param address - Address to export.
-   * @returns Promise resolving to the private key for an address.
-   */
-  async exportAccount(password, address) {
-    await this.verifyPassword(password);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.exportAccount) {
-      throw new Error("`KeyringController - The keyring for the current address does not support the method exportAccount" /* UnsupportedExportAccount */);
-    }
-    return await keyring.exportAccount(normalize(address));
-  }
-  /**
-   * Returns the public addresses of all accounts from every keyring.
-   *
-   * @returns A promise resolving to an array of addresses.
-   */
-  async getAccounts() {
-    return this.state.keyrings.reduce(
-      (accounts, keyring) => accounts.concat(keyring.accounts),
-      []
-    );
-  }
-  /**
-   * Get encryption public key.
-   *
-   * @param account - An account address.
-   * @param opts - Additional encryption options.
-   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method
-   * @returns Promise resolving to encyption public key of the `account` if one exists.
-   */
-  async getEncryptionPublicKey(account, opts) {
-    const address = _ethsigutil.normalize.call(void 0, account);
-    const keyring = await this.getKeyringForAccount(
-      account
-    );
-    if (!keyring.getEncryptionPublicKey) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method getEncryptionPublicKey." /* UnsupportedGetEncryptionPublicKey */);
-    }
-    return await keyring.getEncryptionPublicKey(address, opts);
-  }
-  /**
-   * Attempts to decrypt the provided message parameters.
-   *
-   * @param messageParams - The decryption message parameters.
-   * @param messageParams.from - The address of the account you want to use to decrypt the message.
-   * @param messageParams.data - The encrypted data that you want to decrypt.
-   * @returns The raw decryption result.
-   */
-  async decryptMessage(messageParams) {
-    const address = _ethsigutil.normalize.call(void 0, messageParams.from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.decryptMessage) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method decryptMessage." /* UnsupportedDecryptMessage */);
-    }
-    return keyring.decryptMessage(address, messageParams.data);
-  }
-  /**
-   * Returns the currently initialized keyring that manages
-   * the specified `address` if one exists.
-   *
-   * @deprecated Use of this method is discouraged as actions executed directly on
-   * keyrings are not being reflected in the KeyringController state and not
-   * persisted in the vault. Use `withKeyring` instead.
-   * @param account - An account address.
-   * @returns Promise resolving to keyring of the `account` if one exists.
-   */
-  async getKeyringForAccount(account) {
-    const address = normalize(account);
-    const candidates = await Promise.all(
-      _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(async (keyring) => {
-        return Promise.all([keyring, keyring.getAccounts()]);
-      })
-    );
-    const winners = candidates.filter((candidate) => {
-      const accounts = candidate[1].map(normalize);
-      return accounts.includes(address);
-    });
-    if (winners.length && winners[0]?.length) {
-      return winners[0][0];
-    }
-    let errorInfo = "";
-    if (!candidates.length) {
-      errorInfo = "There are no keyrings";
-    } else if (!winners.length) {
-      errorInfo = "There are keyrings, but none match the address";
-    }
-    throw new Error(
-      `${"KeyringController - No keyring found" /* NoKeyring */}. Error info: ${errorInfo}`
-    );
-  }
-  /**
-   * Returns all keyrings of the given type.
-   *
-   * @deprecated Use of this method is discouraged as actions executed directly on
-   * keyrings are not being reflected in the KeyringController state and not
-   * persisted in the vault. Use `withKeyring` instead.
-   * @param type - Keyring type name.
-   * @returns An array of keyrings of the given type.
-   */
-  getKeyringsByType(type) {
-    return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).filter((keyring) => keyring.type === type);
-  }
-  /**
-   * Persist all serialized keyrings in the vault.
-   *
-   * @deprecated This method is being phased out in favor of `withKeyring`.
-   * @returns Promise resolving with `true` value when the
-   * operation completes.
-   */
-  async persistAllKeyrings() {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => true);
-  }
-  /**
-   * Imports an account with the specified import strategy.
-   *
-   * @param strategy - Import strategy name.
-   * @param args - Array of arguments to pass to the underlying stategy.
-   * @throws Will throw when passed an unrecognized strategy.
-   * @returns Promise resolving to the imported account address.
-   */
-  async importAccountWithStrategy(strategy, args) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      let privateKey;
-      switch (strategy) {
-        case "privateKey":
-          const [importedKey] = args;
-          if (!importedKey) {
-            throw new Error("Cannot import an empty key.");
-          }
-          const prefixed = _utils.add0x.call(void 0, importedKey);
-          let bufferedPrivateKey;
-          try {
-            bufferedPrivateKey = _util.toBuffer.call(void 0, prefixed);
-          } catch {
-            throw new Error("Cannot import invalid private key.");
-          }
-          if (!_util.isValidPrivate.call(void 0, bufferedPrivateKey) || // ensures that the key is 64 bytes long
-          _util.getBinarySize.call(void 0, prefixed) !== 64 + "0x".length) {
-            throw new Error("Cannot import invalid private key.");
-          }
-          privateKey = _utils.remove0x.call(void 0, prefixed);
-          break;
-        case "json":
-          let wallet;
-          const [input, password] = args;
-          try {
-            wallet = _ethereumjswallet.thirdparty.fromEtherWallet(input, password);
-          } catch (e) {
-            wallet = wallet || await _ethereumjswallet2.default.fromV3(input, password, true);
-          }
-          privateKey = _utils.bytesToHex.call(void 0, wallet.getPrivateKey());
-          break;
-        default:
-          throw new Error(`Unexpected import strategy: '${strategy}'`);
-      }
-      const newKeyring = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, "Simple Key Pair" /* simple */, [
-        privateKey
-      ]);
-      const accounts = await newKeyring.getAccounts();
-      return accounts[0];
-    });
-  }
-  /**
-   * Removes an account from keyring state.
-   *
-   * @param address - Address of the account to remove.
-   * @fires KeyringController:accountRemoved
-   * @returns Promise resolving when the account is removed.
-   */
-  async removeAccount(address) {
-    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = await this.getKeyringForAccount(
-        address
-      );
-      if (!keyring.removeAccount) {
-        throw new Error("`KeyringController - The keyring for the current address does not support the method removeAccount" /* UnsupportedRemoveAccount */);
-      }
-      await keyring.removeAccount(address);
-      const accounts = await keyring.getAccounts();
-      if (accounts.length === 0) {
-        await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _removeEmptyKeyrings, removeEmptyKeyrings_fn).call(this);
-      }
-    });
-    this.messagingSystem.publish(`${name}:accountRemoved`, address);
-  }
-  /**
-   * Deallocates all secrets and locks the wallet.
-   *
-   * @returns Promise resolving when the operation completes.
-   */
-  async setLocked() {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async () => {
-      _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn).call(this);
-      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, void 0);
-      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _clearKeyrings, clearKeyrings_fn).call(this);
-      this.update((state) => {
-        state.isUnlocked = false;
-        state.keyrings = [];
-      });
-      this.messagingSystem.publish(`${name}:lock`);
-    });
-  }
-  /**
-   * Signs message by calling down into a specific keyring.
-   *
-   * @param messageParams - PersonalMessageParams object to sign.
-   * @returns Promise resolving to a signed message string.
-   */
-  async signMessage(messageParams) {
-    if (!messageParams.data) {
-      throw new Error("Can't sign an empty message");
-    }
-    const address = _ethsigutil.normalize.call(void 0, messageParams.from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signMessage) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signMessage." /* UnsupportedSignMessage */);
-    }
-    return await keyring.signMessage(address, messageParams.data);
-  }
-  /**
-   * Signs personal message by calling down into a specific keyring.
-   *
-   * @param messageParams - PersonalMessageParams object to sign.
-   * @returns Promise resolving to a signed message string.
-   */
-  async signPersonalMessage(messageParams) {
-    const address = _ethsigutil.normalize.call(void 0, messageParams.from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signPersonalMessage) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signPersonalMessage." /* UnsupportedSignPersonalMessage */);
-    }
-    const normalizedData = normalize(messageParams.data);
-    return await keyring.signPersonalMessage(address, normalizedData);
-  }
-  /**
-   * Signs typed message by calling down into a specific keyring.
-   *
-   * @param messageParams - TypedMessageParams object to sign.
-   * @param version - Compatibility version EIP712.
-   * @throws Will throw when passed an unrecognized version.
-   * @returns Promise resolving to a signed message string or an error if any.
-   */
-  async signTypedMessage(messageParams, version) {
-    try {
-      if (![
-        "V1" /* V1 */,
-        "V3" /* V3 */,
-        "V4" /* V4 */
-      ].includes(version)) {
-        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
-      }
-      const address = _ethsigutil.normalize.call(void 0, messageParams.from);
-      const keyring = await this.getKeyringForAccount(
-        address
-      );
-      if (!keyring.signTypedData) {
-        throw new Error("KeyringController - The keyring for the current address does not support the method signTypedMessage." /* UnsupportedSignTypedMessage */);
-      }
-      return await keyring.signTypedData(
-        address,
-        version !== "V1" /* V1 */ && typeof messageParams.data === "string" ? JSON.parse(messageParams.data) : messageParams.data,
-        { version }
-      );
-    } catch (error) {
-      throw new Error(`Keyring Controller signTypedMessage: ${error}`);
-    }
-  }
-  /**
-   * Signs a transaction by calling down into a specific keyring.
-   *
-   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
-   * @param from - Address to sign from, should be in keychain.
-   * @param opts - An optional options object.
-   * @returns Promise resolving to a signed transaction string.
-   */
-  async signTransaction(transaction, from, opts) {
-    const address = _ethsigutil.normalize.call(void 0, from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signTransaction) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signTransaction." /* UnsupportedSignTransaction */);
-    }
-    return await keyring.signTransaction(address, transaction, opts);
-  }
-  /**
-   * Convert a base transaction to a base UserOperation.
-   *
-   * @param from - Address of the sender.
-   * @param transactions - Base transactions to include in the UserOperation.
-   * @param executionContext - The execution context to use for the UserOperation.
-   * @returns A pseudo-UserOperation that can be used to construct a real.
-   */
-  async prepareUserOperation(from, transactions, executionContext) {
-    const address = _ethsigutil.normalize.call(void 0, from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.prepareUserOperation) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method prepareUserOperation." /* UnsupportedPrepareUserOperation */);
-    }
-    return await keyring.prepareUserOperation(
-      address,
-      transactions,
-      executionContext
-    );
-  }
-  /**
-   * Patches properties of a UserOperation. Currently, only the
-   * `paymasterAndData` can be patched.
-   *
-   * @param from - Address of the sender.
-   * @param userOp - UserOperation to patch.
-   * @param executionContext - The execution context to use for the UserOperation.
-   * @returns A patch to apply to the UserOperation.
-   */
-  async patchUserOperation(from, userOp, executionContext) {
-    const address = _ethsigutil.normalize.call(void 0, from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.patchUserOperation) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method patchUserOperation." /* UnsupportedPatchUserOperation */);
-    }
-    return await keyring.patchUserOperation(address, userOp, executionContext);
-  }
-  /**
-   * Signs an UserOperation.
-   *
-   * @param from - Address of the sender.
-   * @param userOp - UserOperation to sign.
-   * @param executionContext - The execution context to use for the UserOperation.
-   * @returns The signature of the UserOperation.
-   */
-  async signUserOperation(from, userOp, executionContext) {
-    const address = _ethsigutil.normalize.call(void 0, from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signUserOperation) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signUserOperation." /* UnsupportedSignUserOperation */);
-    }
-    return await keyring.signUserOperation(address, userOp, executionContext);
-  }
-  /**
-   * Changes the password used to encrypt the vault.
-   *
-   * @param password - The new password.
-   * @returns Promise resolving when the operation completes.
-   */
-  changePassword(password) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      if (!this.state.isUnlocked) {
-        throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
-      }
-      assertIsValidPassword(password);
-      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
-      if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
-        this.update((state) => {
-          delete state.encryptionKey;
-          delete state.encryptionSalt;
-        });
-      }
-    });
-  }
-  /**
-   * Attempts to decrypt the current vault and load its keyrings,
-   * using the given encryption key and salt.
-   *
-   * @param encryptionKey - Key to unlock the keychain.
-   * @param encryptionSalt - Salt to unlock the keychain.
-   * @returns Promise resolving when the operation completes.
-   */
-  async submitEncryptionKey(encryptionKey, encryptionSalt) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async () => {
-      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _unlockKeyrings, unlockKeyrings_fn).call(this, void 0, encryptionKey, encryptionSalt));
-      _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _setUnlocked, setUnlocked_fn).call(this);
-    });
-  }
-  /**
-   * Attempts to decrypt the current vault and load its keyrings,
-   * using the given password.
-   *
-   * @param password - Password to unlock the keychain.
-   * @returns Promise resolving when the operation completes.
-   */
-  async submitPassword(password) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async () => {
-      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _unlockKeyrings, unlockKeyrings_fn).call(this, password));
-      _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _setUnlocked, setUnlocked_fn).call(this);
-    });
-  }
-  /**
-   * Verifies the that the seed phrase restores the current keychain's accounts.
-   *
-   * @returns Promise resolving to the seed phrase as Uint8Array.
-   */
-  async verifySeedPhrase() {
-    const primaryKeyring = this.getKeyringsByType("HD Key Tree" /* hd */)[0];
-    if (!primaryKeyring) {
-      throw new Error("No HD keyring found.");
-    }
-    assertHasUint8ArrayMnemonic(primaryKeyring);
-    const seedWords = primaryKeyring.mnemonic;
-    const accounts = await primaryKeyring.getAccounts();
-    if (accounts.length === 0) {
-      throw new Error("Cannot verify an empty keyring.");
-    }
-    const hdKeyringBuilder = _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, "HD Key Tree" /* hd */);
-    const hdKeyring = hdKeyringBuilder();
-    await hdKeyring.deserialize({
-      mnemonic: seedWords,
-      numberOfAccounts: accounts.length
-    });
-    const testAccounts = await hdKeyring.getAccounts();
-    if (testAccounts.length !== accounts.length) {
-      throw new Error("Seed phrase imported incorrect number of accounts.");
-    }
-    testAccounts.forEach((account, i) => {
-      if (account.toLowerCase() !== accounts[i].toLowerCase()) {
-        throw new Error("Seed phrase imported different accounts.");
-      }
-    });
-    return seedWords;
-  }
-  async withKeyring(selector, operation, options = {
-    createIfMissing: false
-  }) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      let keyring;
-      if ("address" in selector) {
-        keyring = await this.getKeyringForAccount(selector.address);
-      } else {
-        keyring = this.getKeyringsByType(selector.type)[selector.index || 0];
-        if (!keyring && options.createIfMissing) {
-          keyring = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, selector.type, options.createWithData);
-        }
-      }
-      if (!keyring) {
-        throw new Error("KeyringController - Keyring not found." /* KeyringNotFound */);
-      }
-      const result = await operation(keyring);
-      if (Object.is(result, keyring)) {
-        throw new Error("KeyringController - Returning keyring instances is unsafe" /* UnsafeDirectKeyringAccess */);
-      }
-      return result;
-    });
-  }
-  // QR Hardware related methods
-  /**
-   * Get QR Hardware keyring.
-   *
-   * @returns The QR Keyring if defined, otherwise undefined
-   */
-  getQRKeyring() {
-    return this.getKeyringsByType("QR Hardware Wallet Device" /* qr */)[0];
-  }
-  /**
-   * Get QR hardware keyring. If it doesn't exist, add it.
-   *
-   * @returns The added keyring
-   */
-  async getOrAddQRKeyring() {
-    return this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this));
-  }
-  // TODO: Replace `any` with type
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  async restoreQRKeyring(serialized) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this);
-      keyring.deserialize(serialized);
-    });
-  }
-  async resetQRKeyringState() {
-    (await this.getOrAddQRKeyring()).resetStore();
-  }
-  async getQRKeyringState() {
-    return (await this.getOrAddQRKeyring()).getMemStore();
-  }
-  async submitQRCryptoHDKey(cryptoHDKey) {
-    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);
-  }
-  async submitQRCryptoAccount(cryptoAccount) {
-    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);
-  }
-  async submitQRSignature(requestId, ethSignature) {
-    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);
-  }
-  async cancelQRSignRequest() {
-    (await this.getOrAddQRKeyring()).cancelSignRequest();
-  }
-  /**
-   * Cancels qr keyring sync.
-   */
-  async cancelQRSynchronization() {
-    (await this.getOrAddQRKeyring()).cancelSync();
-  }
-  async connectQRHardware(page) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      try {
-        const keyring = this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this);
-        let accounts;
-        switch (page) {
-          case -1:
-            accounts = await keyring.getPreviousPage();
-            break;
-          case 1:
-            accounts = await keyring.getNextPage();
-            break;
-          default:
-            accounts = await keyring.getFirstPage();
-        }
-        return accounts.map((account) => {
-          return {
-            ...account,
-            balance: "0x0"
-          };
-        });
-      } catch (e) {
-        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);
-      }
-    });
-  }
-  async unlockQRHardwareWalletAccount(index) {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this);
-      keyring.setAccountToUnlock(index);
-      await keyring.addAccounts(1);
-    });
-  }
-  async getAccountKeyringType(account) {
-    const keyring = await this.getKeyringForAccount(
-      account
-    );
-    return keyring.type;
-  }
-  async forgetQRDevice() {
-    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = this.getQRKeyring();
-      if (!keyring) {
-        return { removedAccounts: [], remainingAccounts: [] };
-      }
-      const allAccounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      keyring.forgetDevice();
-      const remainingAccounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      const removedAccounts = allAccounts.filter(
-        (address) => !remainingAccounts.includes(address)
-      );
-      return { removedAccounts, remainingAccounts };
-    });
-  }
-};
-_controllerOperationMutex = new WeakMap();
-_vaultOperationMutex = new WeakMap();
-_keyringBuilders = new WeakMap();
-_keyrings = new WeakMap();
-_unsupportedKeyrings = new WeakMap();
-_password = new WeakMap();
-_encryptor = new WeakMap();
-_cacheEncryptionKey = new WeakMap();
-_qrKeyringStateListener = new WeakMap();
-_registerMessageHandlers = new WeakSet();
-registerMessageHandlers_fn = function() {
-  this.messagingSystem.registerActionHandler(
-    `${name}:signMessage`,
-    this.signMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:signPersonalMessage`,
-    this.signPersonalMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:signTypedMessage`,
-    this.signTypedMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:decryptMessage`,
-    this.decryptMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getEncryptionPublicKey`,
-    this.getEncryptionPublicKey.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getAccounts`,
-    this.getAccounts.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getKeyringsByType`,
-    this.getKeyringsByType.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getKeyringForAccount`,
-    this.getKeyringForAccount.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:persistAllKeyrings`,
-    this.persistAllKeyrings.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:prepareUserOperation`,
-    this.prepareUserOperation.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:patchUserOperation`,
-    this.patchUserOperation.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:signUserOperation`,
-    this.signUserOperation.bind(this)
-  );
-};
-_getKeyringBuilderForType = new WeakSet();
-getKeyringBuilderForType_fn = function(type) {
-  return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyringBuilders).find(
-    (keyringBuilder) => keyringBuilder.type === type
-  );
-};
-_addQRKeyring = new WeakSet();
-addQRKeyring_fn = async function() {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  return await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, "QR Hardware Wallet Device" /* qr */);
-};
-_subscribeToQRKeyringEvents = new WeakSet();
-subscribeToQRKeyringEvents_fn = function(qrKeyring) {
-  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _qrKeyringStateListener, (state) => {
-    this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);
-  });
-  qrKeyring.getMemStore().subscribe(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _qrKeyringStateListener));
-};
-_unsubscribeFromQRKeyringsEvents = new WeakSet();
-unsubscribeFromQRKeyringsEvents_fn = function() {
-  const qrKeyrings = this.getKeyringsByType(
-    "QR Hardware Wallet Device" /* qr */
-  );
-  qrKeyrings.forEach((qrKeyring) => {
-    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _qrKeyringStateListener)) {
-      qrKeyring.getMemStore().unsubscribe(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _qrKeyringStateListener));
-    }
-  });
-};
-_createNewVaultWithKeyring = new WeakSet();
-createNewVaultWithKeyring_fn = async function(password, keyring) {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  if (typeof password !== "string") {
-    throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
-  }
-  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
-  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _clearKeyrings, clearKeyrings_fn).call(this);
-  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn).call(this, keyring.type, keyring.opts);
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _setUnlocked, setUnlocked_fn).call(this);
-};
-_getUpdatedKeyrings = new WeakSet();
-getUpdatedKeyrings_fn = async function() {
-  return Promise.all(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(displayForKeyring));
-};
-_getSerializedKeyrings = new WeakSet();
-getSerializedKeyrings_fn = async function({ includeUnsupported } = {
-  includeUnsupported: true
-}) {
-  const serializedKeyrings = await Promise.all(
-    _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(async (keyring) => {
-      const [type, data] = await Promise.all([
-        keyring.type,
-        keyring.serialize()
-      ]);
-      return { type, data };
-    })
-  );
-  if (includeUnsupported) {
-    serializedKeyrings.push(..._chunkNOCGQCUMjs.__privateGet.call(void 0, this, _unsupportedKeyrings));
-  }
-  return serializedKeyrings;
-};
-_restoreSerializedKeyrings = new WeakSet();
-restoreSerializedKeyrings_fn = async function(serializedKeyrings) {
-  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _clearKeyrings, clearKeyrings_fn).call(this);
-  for (const serializedKeyring of serializedKeyrings) {
-    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _restoreKeyring, restoreKeyring_fn).call(this, serializedKeyring);
-  }
-};
-_unlockKeyrings = new WeakSet();
-unlockKeyrings_fn = async function(password, encryptionKey, encryptionSalt) {
-  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withVaultLock, withVaultLock_fn).call(this, async ({ releaseLock }) => {
-    const encryptedVault = this.state.vault;
-    if (!encryptedVault) {
-      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
-    }
-    let vault;
-    const updatedState = {};
-    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
-      assertIsExportableKeyEncryptor(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor));
-      if (password) {
-        const result = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decryptWithDetail(
-          password,
-          encryptedVault
-        );
-        vault = result.vault;
-        _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
-        updatedState.encryptionKey = result.exportedKeyString;
-        updatedState.encryptionSalt = result.salt;
-      } else {
-        const parsedEncryptedVault = JSON.parse(encryptedVault);
-        if (encryptionSalt !== parsedEncryptedVault.salt) {
-          throw new Error("KeyringController - Encryption key and salt provided are expired" /* ExpiredCredentials */);
-        }
-        if (typeof encryptionKey !== "string") {
-          throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
-        }
-        const key = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).importKey(encryptionKey);
-        vault = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decryptWithKey(
-          key,
-          parsedEncryptedVault
-        );
-        updatedState.encryptionKey = encryptionKey;
-        updatedState.encryptionSalt = encryptionSalt;
-      }
-    } else {
-      if (typeof password !== "string") {
-        throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
-      }
-      vault = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decrypt(password, encryptedVault);
-      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
-    }
-    if (!isSerializedKeyringsArray(vault)) {
-      throw new Error("KeyringController - The decrypted vault has an unexpected shape." /* VaultDataError */);
-    }
-    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, vault);
-    const updatedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
-    this.update((state) => {
-      state.keyrings = updatedKeyrings;
-      if (updatedState.encryptionKey || updatedState.encryptionSalt) {
-        state.encryptionKey = updatedState.encryptionKey;
-        state.encryptionSalt = updatedState.encryptionSalt;
-      }
-    });
-    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password) && (!_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey) || !encryptionKey) && _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).isVaultUpdated && !_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).isVaultUpdated(encryptedVault)) {
-      releaseLock();
-      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _updateVault, updateVault_fn).call(this);
-    }
-    return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings);
-  });
-};
-_updateVault = new WeakSet();
-updateVault_fn = function() {
-  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withVaultLock, withVaultLock_fn).call(this, async () => {
-    const { encryptionKey, encryptionSalt } = this.state;
-    if (!_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password) && !encryptionKey) {
-      throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
-    }
-    const serializedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
-    if (!serializedKeyrings.some((keyring) => keyring.type === "HD Key Tree" /* hd */)) {
-      throw new Error("KeyringController - No HD Keyring found" /* NoHdKeyring */);
-    }
-    const updatedState = {};
-    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
-      assertIsExportableKeyEncryptor(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor));
-      if (encryptionKey) {
-        const key = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).importKey(encryptionKey);
-        const vaultJSON = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).encryptWithKey(
-          key,
-          serializedKeyrings
-        );
-        vaultJSON.salt = encryptionSalt;
-        updatedState.vault = JSON.stringify(vaultJSON);
-      } else if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password)) {
-        const { vault: newVault, exportedKeyString } = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).encryptWithDetail(
-          _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password),
-          serializedKeyrings
-        );
-        updatedState.vault = newVault;
-        updatedState.encryptionKey = exportedKeyString;
-      }
-    } else {
-      assertIsValidPassword(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password));
-      updatedState.vault = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).encrypt(
-        _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password),
-        serializedKeyrings
-      );
-    }
-    if (!updatedState.vault) {
-      throw new Error("KeyringController - Cannot persist vault without vault information" /* MissingVaultData */);
-    }
-    const updatedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
-    this.update((state) => {
-      state.vault = updatedState.vault;
-      state.keyrings = updatedKeyrings;
-      if (updatedState.encryptionKey) {
-        state.encryptionKey = updatedState.encryptionKey;
-        state.encryptionSalt = JSON.parse(updatedState.vault).salt;
-      }
-    });
-    return true;
-  });
-};
-_getAccountsFromKeyrings = new WeakSet();
-getAccountsFromKeyrings_fn = async function() {
-  const keyrings = _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings);
-  const keyringArrays = await Promise.all(
-    keyrings.map(async (keyring) => keyring.getAccounts())
-  );
-  const addresses = keyringArrays.reduce((res, arr) => {
-    return res.concat(arr);
-  }, []);
-  return addresses.map(normalize);
-};
-_createKeyringWithFirstAccount = new WeakSet();
-createKeyringWithFirstAccount_fn = async function(type, opts) {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  const keyring = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, type, opts);
-  const [firstAccount] = await keyring.getAccounts();
-  if (!firstAccount) {
-    throw new Error("KeyringController - First Account not found." /* NoFirstAccount */);
-  }
-};
-_newKeyring = new WeakSet();
-newKeyring_fn = async function(type, data) {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  const keyringBuilder = _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, type);
-  if (!keyringBuilder) {
-    throw new Error(
-      `${"KeyringController - No keyringBuilder found for keyring" /* NoKeyringBuilder */}. Keyring type: ${type}`
-    );
-  }
-  const keyring = keyringBuilder();
-  await keyring.deserialize(data);
-  if (keyring.init) {
-    await keyring.init();
-  }
-  if (type === "HD Key Tree" /* hd */ && (!_utils.isObject.call(void 0, data) || !data.mnemonic)) {
-    if (!keyring.generateRandomMnemonic) {
-      throw new Error(
-        "KeyringController - The current keyring does not support the method generateRandomMnemonic." /* UnsupportedGenerateRandomMnemonic */
-      );
-    }
-    keyring.generateRandomMnemonic();
-    await keyring.addAccounts(1);
-  }
-  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _checkForDuplicate, checkForDuplicate_fn).call(this, type, await keyring.getAccounts());
-  if (type === "QR Hardware Wallet Device" /* qr */) {
-    _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn).call(this, keyring);
-  }
-  _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).push(keyring);
-  return keyring;
-};
-_clearKeyrings = new WeakSet();
-clearKeyrings_fn = async function() {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  for (const keyring of _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings)) {
-    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
-  }
-  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, []);
-};
-_restoreKeyring = new WeakSet();
-restoreKeyring_fn = async function(serialized) {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  try {
-    const { type, data } = serialized;
-    return await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, type, data);
-  } catch (_) {
-    _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _unsupportedKeyrings).push(serialized);
-    return void 0;
-  }
-};
-_destroyKeyring = new WeakSet();
-destroyKeyring_fn = async function(keyring) {
-  await keyring.destroy?.();
-};
-_removeEmptyKeyrings = new WeakSet();
-removeEmptyKeyrings_fn = async function() {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  const validKeyrings = [];
-  await Promise.all(
-    _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(async (keyring) => {
-      const accounts = await keyring.getAccounts();
-      if (accounts.length > 0) {
-        validKeyrings.push(keyring);
-      } else {
-        await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
-      }
-    })
-  );
-  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, validKeyrings);
-};
-_checkForDuplicate = new WeakSet();
-checkForDuplicate_fn = async function(type, newAccountArray) {
-  const accounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-  switch (type) {
-    case "Simple Key Pair" /* simple */: {
-      const isIncluded = Boolean(
-        accounts.find(
-          (key) => newAccountArray[0] && (key === newAccountArray[0] || key === _utils.remove0x.call(void 0, newAccountArray[0]))
-        )
-      );
-      if (isIncluded) {
-        throw new Error("KeyringController - The account you are trying to import is a duplicate" /* DuplicatedAccount */);
-      }
-      return newAccountArray;
-    }
-    default: {
-      return newAccountArray;
-    }
-  }
-};
-_setUnlocked = new WeakSet();
-setUnlocked_fn = function() {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  this.update((state) => {
-    state.isUnlocked = true;
-  });
-  this.messagingSystem.publish(`${name}:unlock`);
-};
-_persistOrRollback = new WeakSet();
-persistOrRollback_fn = async function(fn) {
-  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async ({ releaseLock }) => {
-    const callbackResult = await fn({ releaseLock });
-    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _updateVault, updateVault_fn).call(this);
-    return callbackResult;
-  });
-};
-_withRollback = new WeakSet();
-withRollback_fn = async function(fn) {
-  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withControllerLock, withControllerLock_fn).call(this, async ({ releaseLock }) => {
-    const currentSerializedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
-    const currentPassword = _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password);
-    try {
-      return await fn({ releaseLock });
-    } catch (e) {
-      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, currentSerializedKeyrings);
-      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, currentPassword);
-      throw e;
-    }
-  });
-};
-_assertControllerMutexIsLocked = new WeakSet();
-assertControllerMutexIsLocked_fn = function() {
-  if (!_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _controllerOperationMutex).isLocked()) {
-    throw new Error("KeyringController - attempt to update vault during a non mutually exclusive operation" /* ControllerLockRequired */);
-  }
-};
-_withControllerLock = new WeakSet();
-withControllerLock_fn = async function(fn) {
-  return withLock(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _controllerOperationMutex), fn);
-};
-_withVaultLock = new WeakSet();
-withVaultLock_fn = async function(fn) {
-  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  return withLock(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _vaultOperationMutex), fn);
-};
-async function withLock(mutex, fn) {
-  const releaseLock = await mutex.acquire();
-  try {
-    return await fn({ releaseLock });
-  } finally {
-    releaseLock();
-  }
-}
-var KeyringController_default = KeyringController;
-
-
-
-
-
-
-
-
-
-
-exports.KeyringTypes = KeyringTypes; exports.isCustodyKeyring = isCustodyKeyring; exports.AccountImportStrategy = AccountImportStrategy; exports.SignTypedDataVersion = SignTypedDataVersion; exports.keyringBuilderFactory = keyringBuilderFactory; exports.getDefaultKeyringState = getDefaultKeyringState; exports.KeyringController = KeyringController; exports.KeyringController_default = KeyringController_default;
-//# sourceMappingURL=chunk-BRS27QHF.js.map
\ No newline at end of file
diff --git a/dist/chunk-BRS27QHF.js.map b/dist/chunk-BRS27QHF.js.map
deleted file mode 100644
index e425cd5a63571b3647494e83eb458829f9c6c941..0000000000000000000000000000000000000000
--- a/dist/chunk-BRS27QHF.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/KeyringController.ts"],"names":["KeyringTypes","AccountImportStrategy","SignTypedDataVersion"],"mappings":"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","sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport { isValidPrivate, toBuffer, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize as ethNormalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthKeyring,\n  EthUserOperation,\n  EthUserOperationPatch,\n  KeyringExecutionContext,\n} from '@metamask/keyring-api';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type {\n  Eip1024EncryptedData,\n  Hex,\n  Json,\n  KeyringClass,\n} from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  isObject,\n  isStrictHexString,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { MutexInterface } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nimport { KeyringControllerError } from './constants';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  never,\n  never\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (\n    key: unknown,\n    object: Json,\n  ) => Promise<encryptorUtils.EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<encryptorUtils.DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n\nexport type KeyringSelector =\n  | {\n      type: string;\n      index?: number;\n    }\n  | {\n      address: Hex;\n    };\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<T> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<T>;\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring<Json>,\n): asserts keyring is EthKeyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(KeyringControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(KeyringControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: EthKeyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `string[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    accounts: accounts.map(normalize) as string[],\n  };\n}\n\n/**\n * Check if address is an ethereum address\n *\n * @param address - An address.\n * @returns Returns true if the address is an ethereum one, false otherwise.\n */\nfunction isEthAddress(address: string): boolean {\n  // We first check if it's a matching `Hex` string, so that is narrows down\n  // `address` as an `Hex` type, allowing us to use `isValidHexAddress`\n  return (\n    // NOTE: This function only checks for lowercased strings\n    isStrictHexString(address.toLowerCase()) &&\n    // This checks for lowercased addresses and checksum addresses too\n    isValidHexAddress(address as Hex)\n  );\n}\n\n/**\n * Normalize ethereum or non-EVM address.\n *\n * @param address - Ethereum or non-EVM address.\n * @returns The normalized address.\n */\nfunction normalize(address: string): string | undefined {\n  // Since the `KeyringController` is only dealing with address, we have\n  // no other way to get the associated account type with this address. So we\n  // are down to check the actual address format for now\n  // TODO: Find a better way to not have those runtime checks based on the\n  //       address value!\n  return isEthAddress(address) ? ethNormalize(address) : address;\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  readonly #controllerOperationMutex = new Mutex();\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  #keyringBuilders: { (): EthKeyring<Json>; type: string }[];\n\n  #keyrings: EthKeyring<Json>[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  #cacheEncryptionKey: boolean;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? defaultKeyringBuilders.concat(keyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccount(accountCount?: number): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const oldAccounts = await primaryKeyring.getAccounts();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n        // we return the account already existing at index `accountCount`\n        const existingAccount = oldAccounts[accountCount];\n\n        if (!existingAccount) {\n          throw new Error(`Can't find account at index ${accountCount}`);\n        }\n\n        return existingAccount;\n      }\n\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to the added account address\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    // READ THIS CAREFULLY:\n    // We still uses `Hex` here, since we are not using this method when creating\n    // and account using a \"Snap Keyring\". This function assume the `keyring` is\n    // ethereum compatible, but \"Snap Keyring\" might not be.\n    return this.#persistOrRollback(async () => {\n      const oldAccounts = await this.#getAccountsFromKeyrings();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n\n        const existingAccount = oldAccounts[accountCount];\n        assertIsStrictHexString(existingAccount);\n\n        return existingAccount;\n      }\n\n      await keyring.addAccounts(1);\n\n      const addedAccountAddress = (await this.#getAccountsFromKeyrings()).find(\n        (selectedAddress) => !oldAccounts.includes(selectedAddress),\n      );\n      assertIsStrictHexString(addedAccountAddress);\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccountWithoutUpdate(): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n    });\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    return this.#persistOrRollback(async () => {\n      const accounts = await this.#getAccountsFromKeyrings();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n    });\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    return this.#persistOrRollback(async () => this.#newKeyring(type, opts));\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyrings[0]);\n    return this.#keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts from every keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    return this.state.keyrings.reduce<string[]>(\n      (accounts, keyring) => accounts.concat(keyring.accounts),\n      [],\n    );\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    const address = ethNormalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(address, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    const address = normalize(account);\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(address);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyrings.filter((keyring) => keyring.type === type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @deprecated This method is being phased out in favor of `withKeyring`.\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#persistOrRollback(async () => true);\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to the imported account address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      let privateKey;\n      switch (strategy) {\n        case 'privateKey':\n          const [importedKey] = args;\n          if (!importedKey) {\n            throw new Error('Cannot import an empty key.');\n          }\n          const prefixed = add0x(importedKey);\n\n          let bufferedPrivateKey;\n          try {\n            bufferedPrivateKey = toBuffer(prefixed);\n          } catch {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          if (\n            !isValidPrivate(bufferedPrivateKey) ||\n            // ensures that the key is 64 bytes long\n            getBinarySize(prefixed) !== 64 + '0x'.length\n          ) {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          privateKey = remove0x(prefixed);\n          break;\n        case 'json':\n          let wallet;\n          const [input, password] = args;\n          try {\n            wallet = importers.fromEtherWallet(input, password);\n          } catch (e) {\n            wallet = wallet || (await Wallet.fromV3(input, password, true));\n          }\n          privateKey = bytesToHex(wallet.getPrivateKey());\n          break;\n        default:\n          throw new Error(`Unexpected import strategy: '${strategy}'`);\n      }\n      const newKeyring = (await this.#newKeyring(KeyringTypes.simple, [\n        privateKey,\n      ])) as EthKeyring<Json>;\n      const accounts = await newKeyring.getAccounts();\n      return accounts[0];\n    });\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving when the account is removed.\n   */\n  async removeAccount(address: string): Promise<void> {\n    await this.#persistOrRollback(async () => {\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n\n      // Not all the keyrings support this, so we have to check\n      if (!keyring.removeAccount) {\n        throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n      }\n\n      // The `removeAccount` method of snaps keyring is async. We have to update\n      // the interface of the other keyrings to be async as well.\n      // eslint-disable-next-line @typescript-eslint/await-thenable\n      // FIXME: We do cast to `Hex` to makes the type checker happy here, and\n      // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those\n      // type would need to be updated for a full non-EVM support.\n      await keyring.removeAccount(address as Hex);\n\n      const accounts = await keyring.getAccounts();\n      // Check if this was the last/only account\n      if (accounts.length === 0) {\n        await this.#removeEmptyKeyrings();\n      }\n    });\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving when the operation completes.\n   */\n  async setLocked(): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#unsubscribeFromQRKeyringsEvents();\n\n      this.#password = undefined;\n      await this.#clearKeyrings();\n\n      this.update((state) => {\n        state.isUnlocked = false;\n        state.keyrings = [];\n      });\n\n      this.messagingSystem.publish(`${name}:lock`);\n    });\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = ethNormalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthBaseUserOperation> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(\n      address,\n      transactions,\n      executionContext,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthUserOperationPatch> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<string> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Changes the password used to encrypt the vault.\n   *\n   * @param password - The new password.\n   * @returns Promise resolving when the operation completes.\n   */\n  changePassword(password: string): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      if (!this.state.isUnlocked) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      assertIsValidPassword(password);\n\n      this.#password = password;\n      // We need to clear encryption key and salt from state\n      // to force the controller to re-encrypt the vault using\n      // the new password.\n      if (this.#cacheEncryptionKey) {\n        this.update((state) => {\n          delete state.encryptionKey;\n          delete state.encryptionSalt;\n        });\n      }\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(\n        undefined,\n        encryptionKey,\n        encryptionSalt,\n      );\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitPassword(password: string): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(password);\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @param options - Additional options.\n   * @param options.createIfMissing - Whether to create a new keyring if the selected one is missing.\n   * @param options.createWithData - Optional data to use when creating a new keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   * @deprecated This method overload is deprecated. Use `withKeyring` without options instead.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown },\n  ): Promise<CallbackResult>;\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n  ): Promise<CallbackResult>;\n\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown } = {\n      createIfMissing: false,\n    },\n  ): Promise<CallbackResult> {\n    return this.#persistOrRollback(async () => {\n      let keyring: SelectedKeyring | undefined;\n\n      if ('address' in selector) {\n        keyring = (await this.getKeyringForAccount(selector.address)) as\n          | SelectedKeyring\n          | undefined;\n      } else {\n        keyring = this.getKeyringsByType(selector.type)[selector.index || 0] as\n          | SelectedKeyring\n          | undefined;\n\n        if (!keyring && options.createIfMissing) {\n          keyring = (await this.#newKeyring(\n            selector.type,\n            options.createWithData,\n          )) as SelectedKeyring;\n        }\n      }\n\n      if (!keyring) {\n        throw new Error(KeyringControllerError.KeyringNotFound);\n      }\n\n      const result = await operation(keyring);\n\n      if (Object.is(result, keyring)) {\n        // Access to a keyring instance outside of controller safeguards\n        // should be discouraged, as it can lead to unexpected behavior.\n        // This error is thrown to prevent consumers using `withKeyring`\n        // as a way to get a reference to a keyring instance.\n        throw new Error(KeyringControllerError.UnsafeDirectKeyringAccess);\n      }\n\n      return result;\n    });\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return (\n      this.getQRKeyring() ||\n      (await this.#persistOrRollback(async () => this.#addQRKeyring()))\n    );\n  }\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n      keyring.deserialize(serialized);\n    });\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    return this.#persistOrRollback(async () => {\n      try {\n        const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n        let accounts;\n        switch (page) {\n          case -1:\n            accounts = await keyring.getPreviousPage();\n            break;\n          case 1:\n            accounts = await keyring.getNextPage();\n            break;\n          default:\n            accounts = await keyring.getFirstPage();\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return accounts.map((account: any) => {\n          return {\n            ...account,\n            balance: '0x0',\n          };\n        });\n      } catch (e) {\n        // TODO: Add test case for when keyring throws\n        /* istanbul ignore next */\n        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n      }\n    });\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n\n      keyring.setAccountToUnlock(index);\n      await keyring.addAccounts(1);\n    });\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    return keyring.type;\n  }\n\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring();\n\n      if (!keyring) {\n        return { removedAccounts: [], remainingAccounts: [] };\n      }\n\n      const allAccounts = (await this.#getAccountsFromKeyrings()) as string[];\n      keyring.forgetDevice();\n      const remainingAccounts =\n        (await this.#getAccountsFromKeyrings()) as string[];\n      const removedAccounts = allAccounts.filter(\n        (address: string) => !remainingAccounts.includes(address),\n      );\n      return { removedAccounts, remainingAccounts };\n    });\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring<Json>; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return (await this.#newKeyring(KeyringTypes.qr)) as unknown as QRKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n  }\n\n  /**\n   * Get the updated array of each keyring's type and\n   * accounts list.\n   *\n   * @returns A promise resolving to the updated keyrings array.\n   */\n  async #getUpdatedKeyrings(): Promise<KeyringObject[]> {\n    return Promise.all(this.#keyrings.map(displayForKeyring));\n  }\n\n  /**\n   * Serialize the current array of keyring instances,\n   * including unsupported keyrings by default.\n   *\n   * @param options - Method options.\n   * @param options.includeUnsupported - Whether to include unsupported keyrings.\n   * @returns The serialized keyrings.\n   */\n  async #getSerializedKeyrings(\n    { includeUnsupported }: { includeUnsupported: boolean } = {\n      includeUnsupported: true,\n    },\n  ): Promise<SerializedKeyring[]> {\n    const serializedKeyrings = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    if (includeUnsupported) {\n      serializedKeyrings.push(...this.#unsupportedKeyrings);\n    }\n\n    return serializedKeyrings;\n  }\n\n  /**\n   * Restore a serialized keyrings array.\n   *\n   * @param serializedKeyrings - The serialized keyrings array.\n   */\n  async #restoreSerializedKeyrings(\n    serializedKeyrings: SerializedKeyring[],\n  ): Promise<void> {\n    await this.#clearKeyrings();\n\n    for (const serializedKeyring of serializedKeyrings) {\n      await this.#restoreKeyring(serializedKeyring);\n    }\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<EthKeyring<Json>[]> {\n    return this.#withVaultLock(async ({ releaseLock }) => {\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(KeyringControllerError.VaultError);\n      }\n\n      let vault;\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (password) {\n          const result = await this.#encryptor.decryptWithDetail(\n            password,\n            encryptedVault,\n          );\n          vault = result.vault;\n          this.#password = password;\n\n          updatedState.encryptionKey = result.exportedKeyString;\n          updatedState.encryptionSalt = result.salt;\n        } else {\n          const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n          if (encryptionSalt !== parsedEncryptedVault.salt) {\n            throw new Error(KeyringControllerError.ExpiredCredentials);\n          }\n\n          if (typeof encryptionKey !== 'string') {\n            throw new TypeError(KeyringControllerError.WrongPasswordType);\n          }\n\n          const key = await this.#encryptor.importKey(encryptionKey);\n          vault = await this.#encryptor.decryptWithKey(\n            key,\n            parsedEncryptedVault,\n          );\n\n          // This call is required on the first call because encryptionKey\n          // is not yet inside the memStore\n          updatedState.encryptionKey = encryptionKey;\n          // we can safely assume that encryptionSalt is defined here\n          // because we compare it with the salt from the vault\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          updatedState.encryptionSalt = encryptionSalt!;\n        }\n      } else {\n        if (typeof password !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        vault = await this.#encryptor.decrypt(password, encryptedVault);\n        this.#password = password;\n      }\n\n      if (!isSerializedKeyringsArray(vault)) {\n        throw new Error(KeyringControllerError.VaultDataError);\n      }\n\n      await this.#restoreSerializedKeyrings(vault);\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey || updatedState.encryptionSalt) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = updatedState.encryptionSalt;\n        }\n      });\n\n      if (\n        this.#password &&\n        (!this.#cacheEncryptionKey || !encryptionKey) &&\n        this.#encryptor.isVaultUpdated &&\n        !this.#encryptor.isVaultUpdated(encryptedVault)\n      ) {\n        // The lock needs to be released before persisting the keyrings\n        // to avoid deadlock\n        releaseLock();\n        // Re-encrypt the vault with safer method if one is available\n        await this.#updateVault();\n      }\n\n      return this.#keyrings;\n    });\n  }\n\n  /**\n   * Update the vault with the current keyrings.\n   *\n   * @returns A promise resolving to `true` if the operation is successful.\n   */\n  #updateVault(): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      const { encryptionKey, encryptionSalt } = this.state;\n\n      if (!this.#password && !encryptionKey) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      const serializedKeyrings = await this.#getSerializedKeyrings();\n\n      if (\n        !serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)\n      ) {\n        throw new Error(KeyringControllerError.NoHdKeyring);\n      }\n\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (encryptionKey) {\n          const key = await this.#encryptor.importKey(encryptionKey);\n          const vaultJSON = await this.#encryptor.encryptWithKey(\n            key,\n            serializedKeyrings,\n          );\n          vaultJSON.salt = encryptionSalt;\n          updatedState.vault = JSON.stringify(vaultJSON);\n        } else if (this.#password) {\n          const { vault: newVault, exportedKeyString } =\n            await this.#encryptor.encryptWithDetail(\n              this.#password,\n              serializedKeyrings,\n            );\n\n          updatedState.vault = newVault;\n          updatedState.encryptionKey = exportedKeyString;\n        }\n      } else {\n        assertIsValidPassword(this.#password);\n        updatedState.vault = await this.#encryptor.encrypt(\n          this.#password,\n          serializedKeyrings,\n        );\n      }\n\n      if (!updatedState.vault) {\n        throw new Error(KeyringControllerError.MissingVaultData);\n      }\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n      this.update((state) => {\n        state.vault = updatedState.vault;\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = JSON.parse(updatedState.vault as string).salt;\n        }\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Retrieves all the accounts from keyrings instances\n   * that are currently in memory.\n   *\n   * @returns A promise resolving to an array of accounts.\n   */\n  async #getAccountsFromKeyrings(): Promise<string[]> {\n    const keyrings = this.#keyrings;\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `string[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    return addresses.map(normalize) as string[];\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = (await this.#newKeyring(type, opts)) as EthKeyring<Json>;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #newKeyring(type: string, data?: unknown): Promise<EthKeyring<Json>> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    // @ts-expect-error Enforce data type after updating clients\n    await keyring.deserialize(data);\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    if (type === KeyringTypes.hd && (!isObject(data) || !data.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    await this.#checkForDuplicate(type, await keyring.getAccounts());\n\n    if (type === KeyringTypes.qr) {\n      // In case of a QR keyring type, we need to subscribe\n      // to its events after creating it\n      this.#subscribeToQRKeyringEvents(keyring as unknown as QRKeyring);\n    }\n\n    this.#keyrings.push(keyring);\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    this.#assertControllerMutexIsLocked();\n    for (const keyring of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<EthKeyring<Json> | undefined> {\n    this.#assertControllerMutexIsLocked();\n\n    try {\n      const { type, data } = serialized;\n      return await this.#newKeyring(type, data);\n    } catch (_) {\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring<Json>) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n    const validKeyrings: EthKeyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async (keyring: EthKeyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async #checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.#getAccountsFromKeyrings();\n\n    switch (type) {\n      case KeyringTypes.simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.#assertControllerMutexIsLocked();\n\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and save the keyrings to state after it, or rollback to their\n   * previous state in case of error.\n   *\n   * @param fn - The function to execute.\n   * @returns The result of the function.\n   */\n  async #persistOrRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withRollback(async ({ releaseLock }) => {\n      const callbackResult = await fn({ releaseLock });\n      // State is committed only if the operation is successful\n      await this.#updateVault();\n\n      return callbackResult;\n    });\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and rollback keyrings and password states in case of error.\n   *\n   * @param fn - The function to execute atomically.\n   * @returns The result of the function.\n   */\n  async #withRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withControllerLock(async ({ releaseLock }) => {\n      const currentSerializedKeyrings = await this.#getSerializedKeyrings();\n      const currentPassword = this.#password;\n\n      try {\n        return await fn({ releaseLock });\n      } catch (e) {\n        // Keyrings and password are restored to their previous state\n        await this.#restoreSerializedKeyrings(currentSerializedKeyrings);\n        this.#password = currentPassword;\n\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Assert that the controller mutex is locked.\n   *\n   * @throws If the controller mutex is not locked.\n   */\n  #assertControllerMutexIsLocked() {\n    if (!this.#controllerOperationMutex.isLocked()) {\n      throw new Error(KeyringControllerError.ControllerLockRequired);\n    }\n  }\n\n  /**\n   * Lock the controller mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This wrapper ensures that each mutable operation that interacts with the\n   * controller and that changes its state is executed in a mutually exclusive way,\n   * preventing unsafe concurrent access that could lead to unpredictable behavior.\n   *\n   * @param fn - The function to execute while the controller mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withControllerLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return withLock(this.#controllerOperationMutex, fn);\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param fn - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    this.#assertControllerMutexIsLocked();\n\n    return withLock(this.#vaultOperationMutex, fn);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param fn - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<T>(\n  mutex: Mutex,\n  fn: MutuallyExclusiveCallback<T>,\n): Promise<T> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await fn({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n\nexport default KeyringController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-L4UUWIZA.js b/dist/chunk-L4UUWIZA.js
new file mode 100644
index 0000000000000000000000000000000000000000..3e85597548d0825ba3e1e7d938def8c630ba161a
--- /dev/null
+++ b/dist/chunk-L4UUWIZA.js
@@ -0,0 +1,1506 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+
+
+var _chunkNOCGQCUMjs = require('./chunk-NOCGQCUM.js');
+
+// src/KeyringController.ts
+var _util = require('@ethereumjs/util');
+var _basecontroller = require('@metamask/base-controller');
+var _browserpassworder = require('@metamask/browser-passworder'); var encryptorUtils = _interopRequireWildcard(_browserpassworder);
+var _ethhdkeyring = require('@metamask/eth-hd-keyring'); var _ethhdkeyring2 = _interopRequireDefault(_ethhdkeyring);
+var _ethsigutil = require('@metamask/eth-sig-util');
+var _ethsimplekeyring = require('@metamask/eth-simple-keyring'); var _ethsimplekeyring2 = _interopRequireDefault(_ethsimplekeyring);
+
+
+
+
+
+
+
+
+
+
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _ethereumjswallet = require('ethereumjs-wallet'); var _ethereumjswallet2 = _interopRequireDefault(_ethereumjswallet);
+var name = "KeyringController";
+var KeyringTypes = /* @__PURE__ */ ((KeyringTypes2) => {
+  KeyringTypes2["simple"] = "Simple Key Pair";
+  KeyringTypes2["hd"] = "HD Key Tree";
+  KeyringTypes2["qr"] = "QR Hardware Wallet Device";
+  KeyringTypes2["trezor"] = "Trezor Hardware";
+  KeyringTypes2["ledger"] = "Ledger Hardware";
+  KeyringTypes2["lattice"] = "Lattice Hardware";
+  KeyringTypes2["snap"] = "Snap Keyring";
+  return KeyringTypes2;
+})(KeyringTypes || {});
+var isCustodyKeyring = (keyringType) => {
+  return keyringType.startsWith("Custody");
+};
+var AccountImportStrategy = /* @__PURE__ */ ((AccountImportStrategy2) => {
+  AccountImportStrategy2["privateKey"] = "privateKey";
+  AccountImportStrategy2["json"] = "json";
+  return AccountImportStrategy2;
+})(AccountImportStrategy || {});
+var SignTypedDataVersion = /* @__PURE__ */ ((SignTypedDataVersion2) => {
+  SignTypedDataVersion2["V1"] = "V1";
+  SignTypedDataVersion2["V3"] = "V3";
+  SignTypedDataVersion2["V4"] = "V4";
+  return SignTypedDataVersion2;
+})(SignTypedDataVersion || {});
+function keyringBuilderFactory(KeyringConstructor) {
+  const builder = () => new KeyringConstructor();
+  builder.type = KeyringConstructor.type;
+  return builder;
+}
+var defaultKeyringBuilders = [
+  keyringBuilderFactory(_ethsimplekeyring2.default),
+  keyringBuilderFactory(_ethhdkeyring2.default)
+];
+var getDefaultKeyringState = () => {
+  return {
+    isUnlocked: false,
+    keyrings: []
+  };
+};
+function assertHasUint8ArrayMnemonic(keyring) {
+  if (!(_utils.hasProperty.call(void 0, keyring, "mnemonic") && keyring.mnemonic instanceof Uint8Array)) {
+    throw new Error("Can't get mnemonic bytes from keyring");
+  }
+}
+function assertIsExportableKeyEncryptor(encryptor) {
+  if (!("importKey" in encryptor && typeof encryptor.importKey === "function" && "decryptWithKey" in encryptor && typeof encryptor.decryptWithKey === "function" && "encryptWithKey" in encryptor && typeof encryptor.encryptWithKey === "function")) {
+    throw new Error("KeyringController - The encryptor does not support encryption key export." /* UnsupportedEncryptionKeyExport */);
+  }
+}
+function assertIsValidPassword(password) {
+  if (typeof password !== "string") {
+    throw new Error("KeyringController - Password must be of type string." /* WrongPasswordType */);
+  }
+  if (!password || !password.length) {
+    throw new Error("KeyringController - Password cannot be empty." /* InvalidEmptyPassword */);
+  }
+}
+function isSerializedKeyringsArray(array) {
+  return typeof array === "object" && Array.isArray(array) && array.every((value) => value.type && _utils.isValidJson.call(void 0, value.data));
+}
+async function displayForKeyring(keyring) {
+  const accounts = await keyring.getAccounts();
+  return {
+    type: keyring.type,
+    // Cast to `string[]` here is safe here because `accounts` has no nullish
+    // values, and `normalize` returns `string` unless given a nullish value
+    accounts: accounts.map(normalize)
+  };
+}
+function isEthAddress(address) {
+  return (
+    // NOTE: This function only checks for lowercased strings
+    _utils.isStrictHexString.call(void 0, address.toLowerCase()) && // This checks for lowercased addresses and checksum addresses too
+    _utils.isValidHexAddress.call(void 0, address)
+  );
+}
+function normalize(address) {
+  return isEthAddress(address) ? _ethsigutil.normalize.call(void 0, address) : address;
+}
+var _controllerOperationMutex, _vaultOperationMutex, _keyringBuilders, _keyrings, _unsupportedKeyrings, _password, _encryptor, _cacheEncryptionKey, _qrKeyringStateListener, _registerMessageHandlers, registerMessageHandlers_fn, _getKeyringBuilderForType, getKeyringBuilderForType_fn, _addQRKeyring, addQRKeyring_fn, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn, _getUpdatedKeyrings, getUpdatedKeyrings_fn, _getSerializedKeyrings, getSerializedKeyrings_fn, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn, _unlockKeyrings, unlockKeyrings_fn, _updateVault, updateVault_fn, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn, _newKeyring, newKeyring_fn, _clearKeyrings, clearKeyrings_fn, _restoreKeyring, restoreKeyring_fn, _destroyKeyring, destroyKeyring_fn, _removeEmptyKeyrings, removeEmptyKeyrings_fn, _checkForDuplicate, checkForDuplicate_fn, _setUnlocked, setUnlocked_fn, _persistOrRollback, persistOrRollback_fn, _withRollback, withRollback_fn, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn, _withControllerLock, withControllerLock_fn, _withVaultLock, withVaultLock_fn;
+var KeyringController = class extends _basecontroller.BaseController {
+  /**
+   * Creates a KeyringController instance.
+   *
+   * @param options - Initial options used to configure this controller
+   * @param options.encryptor - An optional object for defining encryption schemes.
+   * @param options.keyringBuilders - Set a new name for account.
+   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.
+   * @param options.messenger - A restricted controller messenger.
+   * @param options.state - Initial state to set on this controller.
+   */
+  constructor(options) {
+    const {
+      encryptor = encryptorUtils,
+      keyringBuilders,
+      messenger,
+      state
+    } = options;
+    super({
+      name,
+      metadata: {
+        vault: { persist: true, anonymous: false },
+        isUnlocked: { persist: false, anonymous: true },
+        keyrings: { persist: false, anonymous: false },
+        encryptionKey: { persist: false, anonymous: false },
+        encryptionSalt: { persist: false, anonymous: false }
+      },
+      messenger,
+      state: {
+        ...getDefaultKeyringState(),
+        ...state
+      }
+    });
+    /**
+     * Constructor helper for registering this controller's messaging system
+     * actions.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _registerMessageHandlers);
+    /**
+     * Get the keyring builder for the given `type`.
+     *
+     * @param type - The type of keyring to get the builder for.
+     * @returns The keyring builder, or undefined if none exists.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getKeyringBuilderForType);
+    /**
+     * Add qr hardware keyring.
+     *
+     * @returns The added keyring
+     * @throws If a QRKeyring builder is not provided
+     * when initializing the controller
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _addQRKeyring);
+    /**
+     * Subscribe to a QRKeyring state change events and
+     * forward them through the messaging system.
+     *
+     * @param qrKeyring - The QRKeyring instance to subscribe to
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _subscribeToQRKeyringEvents);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _unsubscribeFromQRKeyringsEvents);
+    /**
+     * Create new vault with an initial keyring
+     *
+     * Destroys any old encrypted storage,
+     * creates a new encrypted store with the given password,
+     * creates a new wallet with 1 account.
+     *
+     * @fires KeyringController:unlock
+     * @param password - The password to encrypt the vault with.
+     * @param keyring - A object containing the params to instantiate a new keyring.
+     * @param keyring.type - The keyring type.
+     * @param keyring.opts - Optional parameters required to instantiate the keyring.
+     * @returns A promise that resolves to the state.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _createNewVaultWithKeyring);
+    /**
+     * Get the updated array of each keyring's type and
+     * accounts list.
+     *
+     * @returns A promise resolving to the updated keyrings array.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getUpdatedKeyrings);
+    /**
+     * Serialize the current array of keyring instances,
+     * including unsupported keyrings by default.
+     *
+     * @param options - Method options.
+     * @param options.includeUnsupported - Whether to include unsupported keyrings.
+     * @returns The serialized keyrings.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getSerializedKeyrings);
+    /**
+     * Restore a serialized keyrings array.
+     *
+     * @param serializedKeyrings - The serialized keyrings array.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _restoreSerializedKeyrings);
+    /**
+     * Unlock Keyrings, decrypting the vault and deserializing all
+     * keyrings contained in it, using a password or an encryption key with salt.
+     *
+     * @param password - The keyring controller password.
+     * @param encryptionKey - An exported key string to unlock keyrings with.
+     * @param encryptionSalt - The salt used to encrypt the vault.
+     * @returns A promise resolving to the deserialized keyrings array.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _unlockKeyrings);
+    /**
+     * Update the vault with the current keyrings.
+     *
+     * @returns A promise resolving to `true` if the operation is successful.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _updateVault);
+    /**
+     * Retrieves all the accounts from keyrings instances
+     * that are currently in memory.
+     *
+     * @returns A promise resolving to an array of accounts.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _getAccountsFromKeyrings);
+    /**
+     * Create a new keyring, ensuring that the first account is
+     * also created.
+     *
+     * @param type - Keyring type to instantiate.
+     * @param opts - Optional parameters required to instantiate the keyring.
+     * @returns A promise that resolves if the operation is successful.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _createKeyringWithFirstAccount);
+    /**
+     * Instantiate, initialize and return a new keyring of the given `type`,
+     * using the given `opts`. The keyring is built using the keyring builder
+     * registered for the given `type`.
+     *
+     *
+     * @param type - The type of keyring to add.
+     * @param data - The data to restore a previously serialized keyring.
+     * @returns The new keyring.
+     * @throws If the keyring includes duplicated accounts.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _newKeyring);
+    /**
+     * Remove all managed keyrings, destroying all their
+     * instances in memory.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _clearKeyrings);
+    /**
+     * Restore a Keyring from a provided serialized payload.
+     * On success, returns the resulting keyring instance.
+     *
+     * @param serialized - The serialized keyring.
+     * @returns The deserialized keyring or undefined if the keyring type is unsupported.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _restoreKeyring);
+    /**
+     * Destroy Keyring
+     *
+     * Some keyrings support a method called `destroy`, that destroys the
+     * keyring along with removing all its event listeners and, in some cases,
+     * clears the keyring bridge iframe from the DOM.
+     *
+     * @param keyring - The keyring to destroy.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _destroyKeyring);
+    /**
+     * Remove empty keyrings.
+     *
+     * Loops through the keyrings and removes the ones with empty accounts
+     * (usually after removing the last / only account) from a keyring.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _removeEmptyKeyrings);
+    /**
+     * Checks for duplicate keypairs, using the the first account in the given
+     * array. Rejects if a duplicate is found.
+     *
+     * Only supports 'Simple Key Pair'.
+     *
+     * @param type - The key pair type to check for.
+     * @param newAccountArray - Array of new accounts.
+     * @returns The account, if no duplicate is found.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _checkForDuplicate);
+    /**
+     * Set the `isUnlocked` to true and notify listeners
+     * through the messenger.
+     *
+     * @fires KeyringController:unlock
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _setUnlocked);
+    /**
+     * Execute the given function after acquiring the controller lock
+     * and save the keyrings to state after it, or rollback to their
+     * previous state in case of error.
+     *
+     * @param fn - The function to execute.
+     * @returns The result of the function.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _persistOrRollback);
+    /**
+     * Execute the given function after acquiring the controller lock
+     * and rollback keyrings and password states in case of error.
+     *
+     * @param fn - The function to execute atomically.
+     * @returns The result of the function.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _withRollback);
+    /**
+     * Assert that the controller mutex is locked.
+     *
+     * @throws If the controller mutex is not locked.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _assertControllerMutexIsLocked);
+    /**
+     * Lock the controller mutex before executing the given function,
+     * and release it after the function is resolved or after an
+     * error is thrown.
+     *
+     * This wrapper ensures that each mutable operation that interacts with the
+     * controller and that changes its state is executed in a mutually exclusive way,
+     * preventing unsafe concurrent access that could lead to unpredictable behavior.
+     *
+     * @param fn - The function to execute while the controller mutex is locked.
+     * @returns The result of the function.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _withControllerLock);
+    /**
+     * Lock the vault mutex before executing the given function,
+     * and release it after the function is resolved or after an
+     * error is thrown.
+     *
+     * This ensures that each operation that interacts with the vault
+     * is executed in a mutually exclusive way.
+     *
+     * @param fn - The function to execute while the vault mutex is locked.
+     * @returns The result of the function.
+     */
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _withVaultLock);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _controllerOperationMutex, new (0, _asyncmutex.Mutex)());
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _vaultOperationMutex, new (0, _asyncmutex.Mutex)());
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _keyringBuilders, void 0);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _keyrings, void 0);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _unsupportedKeyrings, void 0);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _password, void 0);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _encryptor, void 0);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _cacheEncryptionKey, void 0);
+    _chunkNOCGQCUMjs.__privateAdd.call(void 0, this, _qrKeyringStateListener, void 0);
+    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyringBuilders, keyringBuilders ? defaultKeyringBuilders.concat(keyringBuilders) : defaultKeyringBuilders);
+    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _encryptor, encryptor);
+    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, []);
+    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _unsupportedKeyrings, []);
+    _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _cacheEncryptionKey, Boolean(options.cacheEncryptionKey));
+    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
+      assertIsExportableKeyEncryptor(encryptor);
+    }
+    _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _registerMessageHandlers, registerMessageHandlers_fn).call(this);
+  }
+  /**
+   * Adds a new account to the default (first) HD seed phrase keyring.
+   *
+   * @param accountCount - Number of accounts before adding a new one, used to
+   * make the method idempotent.
+   * @returns Promise resolving to the added account address.
+   */
+  async addNewAccount(accountCount) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
+      if (!primaryKeyring) {
+        throw new Error("No HD keyring found");
+      }
+      const oldAccounts = await primaryKeyring.getAccounts();
+      if (accountCount && oldAccounts.length !== accountCount) {
+        if (accountCount > oldAccounts.length) {
+          throw new Error("Account out of sequence");
+        }
+        const existingAccount = oldAccounts[accountCount];
+        if (!existingAccount) {
+          throw new Error(`Can't find account at index ${accountCount}`);
+        }
+        return existingAccount;
+      }
+      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
+      await this.verifySeedPhrase();
+      return addedAccountAddress;
+    });
+  }
+  /**
+   * Adds a new account to the specified keyring.
+   *
+   * @param keyring - Keyring to add the account to.
+   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.
+   * @returns Promise resolving to the added account address
+   */
+  async addNewAccountForKeyring(keyring, accountCount) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const oldAccounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      if (accountCount && oldAccounts.length !== accountCount) {
+        if (accountCount > oldAccounts.length) {
+          throw new Error("Account out of sequence");
+        }
+        const existingAccount = oldAccounts[accountCount];
+        _utils.assertIsStrictHexString.call(void 0, existingAccount);
+        return existingAccount;
+      }
+      await keyring.addAccounts(1);
+      const addedAccountAddress = (await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this)).find(
+        (selectedAddress) => !oldAccounts.includes(selectedAddress)
+      );
+      _utils.assertIsStrictHexString.call(void 0, addedAccountAddress);
+      return addedAccountAddress;
+    });
+  }
+  /**
+   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.
+   *
+   * @returns Promise resolving to the added account address.
+   */
+  async addNewAccountWithoutUpdate() {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
+      if (!primaryKeyring) {
+        throw new Error("No HD keyring found");
+      }
+      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
+      await this.verifySeedPhrase();
+      return addedAccountAddress;
+    });
+  }
+  /**
+   * Effectively the same as creating a new keychain then populating it
+   * using the given seed phrase.
+   *
+   * @param password - Password to unlock keychain.
+   * @param seed - A BIP39-compliant seed phrase as Uint8Array,
+   * either as a string or an array of UTF-8 bytes that represent the string.
+   * @returns Promise resolving when the operation ends successfully.
+   */
+  async createNewVaultAndRestore(password, seed) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      assertIsValidPassword(password);
+      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
+        type: "HD Key Tree" /* hd */,
+        opts: {
+          mnemonic: seed,
+          numberOfAccounts: 1
+        }
+      });
+    });
+  }
+  /**
+   * Create a new primary keychain and wipe any previous keychains.
+   *
+   * @param password - Password to unlock the new vault.
+   * @returns Promise resolving when the operation ends successfully.
+   */
+  async createNewVaultAndKeychain(password) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const accounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      if (!accounts.length) {
+        await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
+          type: "HD Key Tree" /* hd */
+        });
+      }
+    });
+  }
+  /**
+   * Adds a new keyring of the given `type`.
+   *
+   * @param type - Keyring type name.
+   * @param opts - Keyring options.
+   * @throws If a builder for the given `type` does not exist.
+   * @returns Promise resolving to the added keyring.
+   */
+  async addNewKeyring(type, opts) {
+    if (type === "QR Hardware Wallet Device" /* qr */) {
+      return this.getOrAddQRKeyring();
+    }
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, type, opts));
+  }
+  /**
+   * Method to verify a given password validity. Throws an
+   * error if the password is invalid.
+   *
+   * @param password - Password of the keyring.
+   */
+  async verifyPassword(password) {
+    if (!this.state.vault) {
+      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
+    }
+    await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decrypt(password, this.state.vault);
+  }
+  /**
+   * Returns the status of the vault.
+   *
+   * @returns Boolean returning true if the vault is unlocked.
+   */
+  isUnlocked() {
+    return this.state.isUnlocked;
+  }
+  /**
+   * Gets the seed phrase of the HD keyring.
+   *
+   * @param password - Password of the keyring.
+   * @returns Promise resolving to the seed phrase.
+   */
+  async exportSeedPhrase(password) {
+    await this.verifyPassword(password);
+    assertHasUint8ArrayMnemonic(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings)[0]);
+    return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings)[0].mnemonic;
+  }
+  /**
+   * Gets the private key from the keyring controlling an address.
+   *
+   * @param password - Password of the keyring.
+   * @param address - Address to export.
+   * @returns Promise resolving to the private key for an address.
+   */
+  async exportAccount(password, address) {
+    await this.verifyPassword(password);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.exportAccount) {
+      throw new Error("`KeyringController - The keyring for the current address does not support the method exportAccount" /* UnsupportedExportAccount */);
+    }
+    return await keyring.exportAccount(normalize(address));
+  }
+  /**
+   * Returns the public addresses of all accounts from every keyring.
+   *
+   * @returns A promise resolving to an array of addresses.
+   */
+  async getAccounts() {
+    return this.state.keyrings.reduce(
+      (accounts, keyring) => accounts.concat(keyring.accounts),
+      []
+    );
+  }
+  /**
+   * Get encryption public key.
+   *
+   * @param account - An account address.
+   * @param opts - Additional encryption options.
+   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method
+   * @returns Promise resolving to encyption public key of the `account` if one exists.
+   */
+  async getEncryptionPublicKey(account, opts) {
+    const address = _ethsigutil.normalize.call(void 0, account);
+    const keyring = await this.getKeyringForAccount(
+      account
+    );
+    if (!keyring.getEncryptionPublicKey) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method getEncryptionPublicKey." /* UnsupportedGetEncryptionPublicKey */);
+    }
+    return await keyring.getEncryptionPublicKey(address, opts);
+  }
+  /**
+   * Attempts to decrypt the provided message parameters.
+   *
+   * @param messageParams - The decryption message parameters.
+   * @param messageParams.from - The address of the account you want to use to decrypt the message.
+   * @param messageParams.data - The encrypted data that you want to decrypt.
+   * @returns The raw decryption result.
+   */
+  async decryptMessage(messageParams) {
+    const address = _ethsigutil.normalize.call(void 0, messageParams.from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.decryptMessage) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method decryptMessage." /* UnsupportedDecryptMessage */);
+    }
+    return keyring.decryptMessage(address, messageParams.data);
+  }
+  /**
+   * Returns the currently initialized keyring that manages
+   * the specified `address` if one exists.
+   *
+   * @deprecated Use of this method is discouraged as actions executed directly on
+   * keyrings are not being reflected in the KeyringController state and not
+   * persisted in the vault. Use `withKeyring` instead.
+   * @param account - An account address.
+   * @returns Promise resolving to keyring of the `account` if one exists.
+   */
+  async getKeyringForAccount(account) {
+    const address = normalize(account);
+    const candidates = await Promise.all(
+      _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(async (keyring) => {
+        return Promise.all([keyring, keyring.getAccounts()]);
+      })
+    );
+    const winners = candidates.filter((candidate) => {
+      const accounts = candidate[1].map(normalize);
+      return accounts.includes(address);
+    });
+    if (winners.length && winners[0]?.length) {
+      return winners[0][0];
+    }
+    let errorInfo = "";
+    if (!candidates.length) {
+      errorInfo = "There are no keyrings";
+    } else if (!winners.length) {
+      errorInfo = "There are keyrings, but none match the address";
+    }
+    throw new Error(
+      `${"KeyringController - No keyring found" /* NoKeyring */}. Error info: ${errorInfo}`
+    );
+  }
+  /**
+   * Returns all keyrings of the given type.
+   *
+   * @deprecated Use of this method is discouraged as actions executed directly on
+   * keyrings are not being reflected in the KeyringController state and not
+   * persisted in the vault. Use `withKeyring` instead.
+   * @param type - Keyring type name.
+   * @returns An array of keyrings of the given type.
+   */
+  getKeyringsByType(type) {
+    return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).filter((keyring) => keyring.type === type);
+  }
+  /**
+   * Persist all serialized keyrings in the vault.
+   *
+   * @deprecated This method is being phased out in favor of `withKeyring`.
+   * @returns Promise resolving with `true` value when the
+   * operation completes.
+   */
+  async persistAllKeyrings() {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => true);
+  }
+  /**
+   * Imports an account with the specified import strategy.
+   *
+   * @param strategy - Import strategy name.
+   * @param args - Array of arguments to pass to the underlying stategy.
+   * @throws Will throw when passed an unrecognized strategy.
+   * @returns Promise resolving to the imported account address.
+   */
+  async importAccountWithStrategy(strategy, args) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      let privateKey;
+      switch (strategy) {
+        case "privateKey":
+          const [importedKey] = args;
+          if (!importedKey) {
+            throw new Error("Cannot import an empty key.");
+          }
+          const prefixed = _utils.add0x.call(void 0, importedKey);
+          let bufferedPrivateKey;
+          try {
+            bufferedPrivateKey = _util.toBuffer.call(void 0, prefixed);
+          } catch {
+            throw new Error("Cannot import invalid private key.");
+          }
+          if (!_util.isValidPrivate.call(void 0, bufferedPrivateKey) || // ensures that the key is 64 bytes long
+          _util.getBinarySize.call(void 0, prefixed) !== 64 + "0x".length) {
+            throw new Error("Cannot import invalid private key.");
+          }
+          privateKey = _utils.remove0x.call(void 0, prefixed);
+          break;
+        case "json":
+          let wallet;
+          const [input, password] = args;
+          try {
+            wallet = _ethereumjswallet.thirdparty.fromEtherWallet(input, password);
+          } catch (e) {
+            wallet = wallet || await _ethereumjswallet2.default.fromV3(input, password, true);
+          }
+          privateKey = _utils.bytesToHex.call(void 0, wallet.getPrivateKey());
+          break;
+        default:
+          throw new Error(`Unexpected import strategy: '${strategy}'`);
+      }
+      const newKeyring = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, "Simple Key Pair" /* simple */, [
+        privateKey
+      ]);
+      const accounts = await newKeyring.getAccounts();
+      return accounts[0];
+    });
+  }
+  /**
+   * Removes an account from keyring state.
+   *
+   * @param address - Address of the account to remove.
+   * @fires KeyringController:accountRemoved
+   * @returns Promise resolving when the account is removed.
+   */
+  async removeAccount(address) {
+    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = await this.getKeyringForAccount(
+        address
+      );
+      if (!keyring.removeAccount) {
+        throw new Error("`KeyringController - The keyring for the current address does not support the method removeAccount" /* UnsupportedRemoveAccount */);
+      }
+      await keyring.removeAccount(address);
+      const accounts = await keyring.getAccounts();
+      if (accounts.length === 0) {
+        await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _removeEmptyKeyrings, removeEmptyKeyrings_fn).call(this);
+      }
+    });
+    this.messagingSystem.publish(`${name}:accountRemoved`, address);
+  }
+  /**
+   * Deallocates all secrets and locks the wallet.
+   *
+   * @returns Promise resolving when the operation completes.
+   */
+  async setLocked() {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async () => {
+      _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn).call(this);
+      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, void 0);
+      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _clearKeyrings, clearKeyrings_fn).call(this);
+      this.update((state) => {
+        state.isUnlocked = false;
+        state.keyrings = [];
+        delete state.encryptionKey;
+        delete state.encryptionSalt;
+      });
+      this.messagingSystem.publish(`${name}:lock`);
+    });
+  }
+  /**
+   * Signs message by calling down into a specific keyring.
+   *
+   * @param messageParams - PersonalMessageParams object to sign.
+   * @returns Promise resolving to a signed message string.
+   */
+  async signMessage(messageParams) {
+    if (!messageParams.data) {
+      throw new Error("Can't sign an empty message");
+    }
+    const address = _ethsigutil.normalize.call(void 0, messageParams.from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signMessage) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signMessage." /* UnsupportedSignMessage */);
+    }
+    return await keyring.signMessage(address, messageParams.data);
+  }
+  /**
+   * Signs personal message by calling down into a specific keyring.
+   *
+   * @param messageParams - PersonalMessageParams object to sign.
+   * @returns Promise resolving to a signed message string.
+   */
+  async signPersonalMessage(messageParams) {
+    const address = _ethsigutil.normalize.call(void 0, messageParams.from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signPersonalMessage) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signPersonalMessage." /* UnsupportedSignPersonalMessage */);
+    }
+    const normalizedData = normalize(messageParams.data);
+    return await keyring.signPersonalMessage(address, normalizedData);
+  }
+  /**
+   * Signs typed message by calling down into a specific keyring.
+   *
+   * @param messageParams - TypedMessageParams object to sign.
+   * @param version - Compatibility version EIP712.
+   * @throws Will throw when passed an unrecognized version.
+   * @returns Promise resolving to a signed message string or an error if any.
+   */
+  async signTypedMessage(messageParams, version) {
+    try {
+      if (![
+        "V1" /* V1 */,
+        "V3" /* V3 */,
+        "V4" /* V4 */
+      ].includes(version)) {
+        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
+      }
+      const address = _ethsigutil.normalize.call(void 0, messageParams.from);
+      const keyring = await this.getKeyringForAccount(
+        address
+      );
+      if (!keyring.signTypedData) {
+        throw new Error("KeyringController - The keyring for the current address does not support the method signTypedMessage." /* UnsupportedSignTypedMessage */);
+      }
+      return await keyring.signTypedData(
+        address,
+        version !== "V1" /* V1 */ && typeof messageParams.data === "string" ? JSON.parse(messageParams.data) : messageParams.data,
+        { version }
+      );
+    } catch (error) {
+      throw new Error(`Keyring Controller signTypedMessage: ${error}`);
+    }
+  }
+  /**
+   * Signs a transaction by calling down into a specific keyring.
+   *
+   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
+   * @param from - Address to sign from, should be in keychain.
+   * @param opts - An optional options object.
+   * @returns Promise resolving to a signed transaction string.
+   */
+  async signTransaction(transaction, from, opts) {
+    const address = _ethsigutil.normalize.call(void 0, from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signTransaction) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signTransaction." /* UnsupportedSignTransaction */);
+    }
+    return await keyring.signTransaction(address, transaction, opts);
+  }
+  /**
+   * Convert a base transaction to a base UserOperation.
+   *
+   * @param from - Address of the sender.
+   * @param transactions - Base transactions to include in the UserOperation.
+   * @param executionContext - The execution context to use for the UserOperation.
+   * @returns A pseudo-UserOperation that can be used to construct a real.
+   */
+  async prepareUserOperation(from, transactions, executionContext) {
+    const address = _ethsigutil.normalize.call(void 0, from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.prepareUserOperation) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method prepareUserOperation." /* UnsupportedPrepareUserOperation */);
+    }
+    return await keyring.prepareUserOperation(
+      address,
+      transactions,
+      executionContext
+    );
+  }
+  /**
+   * Patches properties of a UserOperation. Currently, only the
+   * `paymasterAndData` can be patched.
+   *
+   * @param from - Address of the sender.
+   * @param userOp - UserOperation to patch.
+   * @param executionContext - The execution context to use for the UserOperation.
+   * @returns A patch to apply to the UserOperation.
+   */
+  async patchUserOperation(from, userOp, executionContext) {
+    const address = _ethsigutil.normalize.call(void 0, from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.patchUserOperation) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method patchUserOperation." /* UnsupportedPatchUserOperation */);
+    }
+    return await keyring.patchUserOperation(address, userOp, executionContext);
+  }
+  /**
+   * Signs an UserOperation.
+   *
+   * @param from - Address of the sender.
+   * @param userOp - UserOperation to sign.
+   * @param executionContext - The execution context to use for the UserOperation.
+   * @returns The signature of the UserOperation.
+   */
+  async signUserOperation(from, userOp, executionContext) {
+    const address = _ethsigutil.normalize.call(void 0, from);
+    const keyring = await this.getKeyringForAccount(
+      address
+    );
+    if (!keyring.signUserOperation) {
+      throw new Error("KeyringController - The keyring for the current address does not support the method signUserOperation." /* UnsupportedSignUserOperation */);
+    }
+    return await keyring.signUserOperation(address, userOp, executionContext);
+  }
+  /**
+   * Changes the password used to encrypt the vault.
+   *
+   * @param password - The new password.
+   * @returns Promise resolving when the operation completes.
+   */
+  changePassword(password) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      if (!this.state.isUnlocked) {
+        throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
+      }
+      assertIsValidPassword(password);
+      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
+      if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
+        this.update((state) => {
+          delete state.encryptionKey;
+          delete state.encryptionSalt;
+        });
+      }
+    });
+  }
+  /**
+   * Attempts to decrypt the current vault and load its keyrings,
+   * using the given encryption key and salt.
+   *
+   * @param encryptionKey - Key to unlock the keychain.
+   * @param encryptionSalt - Salt to unlock the keychain.
+   * @returns Promise resolving when the operation completes.
+   */
+  async submitEncryptionKey(encryptionKey, encryptionSalt) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async () => {
+      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _unlockKeyrings, unlockKeyrings_fn).call(this, void 0, encryptionKey, encryptionSalt));
+      _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _setUnlocked, setUnlocked_fn).call(this);
+    });
+  }
+  /**
+   * Attempts to decrypt the current vault and load its keyrings,
+   * using the given password.
+   *
+   * @param password - Password to unlock the keychain.
+   * @returns Promise resolving when the operation completes.
+   */
+  async submitPassword(password) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async () => {
+      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _unlockKeyrings, unlockKeyrings_fn).call(this, password));
+      _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _setUnlocked, setUnlocked_fn).call(this);
+    });
+  }
+  /**
+   * Verifies the that the seed phrase restores the current keychain's accounts.
+   *
+   * @returns Promise resolving to the seed phrase as Uint8Array.
+   */
+  async verifySeedPhrase() {
+    const primaryKeyring = this.getKeyringsByType("HD Key Tree" /* hd */)[0];
+    if (!primaryKeyring) {
+      throw new Error("No HD keyring found.");
+    }
+    assertHasUint8ArrayMnemonic(primaryKeyring);
+    const seedWords = primaryKeyring.mnemonic;
+    const accounts = await primaryKeyring.getAccounts();
+    if (accounts.length === 0) {
+      throw new Error("Cannot verify an empty keyring.");
+    }
+    const hdKeyringBuilder = _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, "HD Key Tree" /* hd */);
+    const hdKeyring = hdKeyringBuilder();
+    await hdKeyring.deserialize({
+      mnemonic: seedWords,
+      numberOfAccounts: accounts.length
+    });
+    const testAccounts = await hdKeyring.getAccounts();
+    if (testAccounts.length !== accounts.length) {
+      throw new Error("Seed phrase imported incorrect number of accounts.");
+    }
+    testAccounts.forEach((account, i) => {
+      if (account.toLowerCase() !== accounts[i].toLowerCase()) {
+        throw new Error("Seed phrase imported different accounts.");
+      }
+    });
+    return seedWords;
+  }
+  async withKeyring(selector, operation, options = {
+    createIfMissing: false
+  }) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      let keyring;
+      if ("address" in selector) {
+        keyring = await this.getKeyringForAccount(selector.address);
+      } else {
+        keyring = this.getKeyringsByType(selector.type)[selector.index || 0];
+        if (!keyring && options.createIfMissing) {
+          keyring = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, selector.type, options.createWithData);
+        }
+      }
+      if (!keyring) {
+        throw new Error("KeyringController - Keyring not found." /* KeyringNotFound */);
+      }
+      const result = await operation(keyring);
+      if (Object.is(result, keyring)) {
+        throw new Error("KeyringController - Returning keyring instances is unsafe" /* UnsafeDirectKeyringAccess */);
+      }
+      return result;
+    });
+  }
+  // QR Hardware related methods
+  /**
+   * Get QR Hardware keyring.
+   *
+   * @returns The QR Keyring if defined, otherwise undefined
+   */
+  getQRKeyring() {
+    return this.getKeyringsByType("QR Hardware Wallet Device" /* qr */)[0];
+  }
+  /**
+   * Get QR hardware keyring. If it doesn't exist, add it.
+   *
+   * @returns The added keyring
+   */
+  async getOrAddQRKeyring() {
+    return this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this));
+  }
+  // TODO: Replace `any` with type
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  async restoreQRKeyring(serialized) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this);
+      keyring.deserialize(serialized);
+    });
+  }
+  async resetQRKeyringState() {
+    (await this.getOrAddQRKeyring()).resetStore();
+  }
+  async getQRKeyringState() {
+    return (await this.getOrAddQRKeyring()).getMemStore();
+  }
+  async submitQRCryptoHDKey(cryptoHDKey) {
+    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);
+  }
+  async submitQRCryptoAccount(cryptoAccount) {
+    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);
+  }
+  async submitQRSignature(requestId, ethSignature) {
+    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);
+  }
+  async cancelQRSignRequest() {
+    (await this.getOrAddQRKeyring()).cancelSignRequest();
+  }
+  /**
+   * Cancels qr keyring sync.
+   */
+  async cancelQRSynchronization() {
+    (await this.getOrAddQRKeyring()).cancelSync();
+  }
+  async connectQRHardware(page) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      try {
+        const keyring = this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this);
+        let accounts;
+        switch (page) {
+          case -1:
+            accounts = await keyring.getPreviousPage();
+            break;
+          case 1:
+            accounts = await keyring.getNextPage();
+            break;
+          default:
+            accounts = await keyring.getFirstPage();
+        }
+        return accounts.map((account) => {
+          return {
+            ...account,
+            balance: "0x0"
+          };
+        });
+      } catch (e) {
+        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);
+      }
+    });
+  }
+  async unlockQRHardwareWalletAccount(index) {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = this.getQRKeyring() || await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _addQRKeyring, addQRKeyring_fn).call(this);
+      keyring.setAccountToUnlock(index);
+      await keyring.addAccounts(1);
+    });
+  }
+  async getAccountKeyringType(account) {
+    const keyring = await this.getKeyringForAccount(
+      account
+    );
+    return keyring.type;
+  }
+  async forgetQRDevice() {
+    return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
+      const keyring = this.getQRKeyring();
+      if (!keyring) {
+        return { removedAccounts: [], remainingAccounts: [] };
+      }
+      const allAccounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      keyring.forgetDevice();
+      const remainingAccounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+      const removedAccounts = allAccounts.filter(
+        (address) => !remainingAccounts.includes(address)
+      );
+      return { removedAccounts, remainingAccounts };
+    });
+  }
+};
+_controllerOperationMutex = new WeakMap();
+_vaultOperationMutex = new WeakMap();
+_keyringBuilders = new WeakMap();
+_keyrings = new WeakMap();
+_unsupportedKeyrings = new WeakMap();
+_password = new WeakMap();
+_encryptor = new WeakMap();
+_cacheEncryptionKey = new WeakMap();
+_qrKeyringStateListener = new WeakMap();
+_registerMessageHandlers = new WeakSet();
+registerMessageHandlers_fn = function() {
+  this.messagingSystem.registerActionHandler(
+    `${name}:signMessage`,
+    this.signMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:signPersonalMessage`,
+    this.signPersonalMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:signTypedMessage`,
+    this.signTypedMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:decryptMessage`,
+    this.decryptMessage.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getEncryptionPublicKey`,
+    this.getEncryptionPublicKey.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getAccounts`,
+    this.getAccounts.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getKeyringsByType`,
+    this.getKeyringsByType.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:getKeyringForAccount`,
+    this.getKeyringForAccount.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:persistAllKeyrings`,
+    this.persistAllKeyrings.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:prepareUserOperation`,
+    this.prepareUserOperation.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:patchUserOperation`,
+    this.patchUserOperation.bind(this)
+  );
+  this.messagingSystem.registerActionHandler(
+    `${name}:signUserOperation`,
+    this.signUserOperation.bind(this)
+  );
+};
+_getKeyringBuilderForType = new WeakSet();
+getKeyringBuilderForType_fn = function(type) {
+  return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyringBuilders).find(
+    (keyringBuilder) => keyringBuilder.type === type
+  );
+};
+_addQRKeyring = new WeakSet();
+addQRKeyring_fn = async function() {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  return await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, "QR Hardware Wallet Device" /* qr */);
+};
+_subscribeToQRKeyringEvents = new WeakSet();
+subscribeToQRKeyringEvents_fn = function(qrKeyring) {
+  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _qrKeyringStateListener, (state) => {
+    this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);
+  });
+  qrKeyring.getMemStore().subscribe(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _qrKeyringStateListener));
+};
+_unsubscribeFromQRKeyringsEvents = new WeakSet();
+unsubscribeFromQRKeyringsEvents_fn = function() {
+  const qrKeyrings = this.getKeyringsByType(
+    "QR Hardware Wallet Device" /* qr */
+  );
+  qrKeyrings.forEach((qrKeyring) => {
+    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _qrKeyringStateListener)) {
+      qrKeyring.getMemStore().unsubscribe(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _qrKeyringStateListener));
+    }
+  });
+};
+_createNewVaultWithKeyring = new WeakSet();
+createNewVaultWithKeyring_fn = async function(password, keyring) {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  if (typeof password !== "string") {
+    throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
+  }
+  this.update((state) => {
+    delete state.encryptionKey;
+    delete state.encryptionSalt;
+  });
+  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
+  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _clearKeyrings, clearKeyrings_fn).call(this);
+  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn).call(this, keyring.type, keyring.opts);
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _setUnlocked, setUnlocked_fn).call(this);
+};
+_getUpdatedKeyrings = new WeakSet();
+getUpdatedKeyrings_fn = async function() {
+  return Promise.all(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(displayForKeyring));
+};
+_getSerializedKeyrings = new WeakSet();
+getSerializedKeyrings_fn = async function({ includeUnsupported } = {
+  includeUnsupported: true
+}) {
+  const serializedKeyrings = await Promise.all(
+    _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(async (keyring) => {
+      const [type, data] = await Promise.all([
+        keyring.type,
+        keyring.serialize()
+      ]);
+      return { type, data };
+    })
+  );
+  if (includeUnsupported) {
+    serializedKeyrings.push(..._chunkNOCGQCUMjs.__privateGet.call(void 0, this, _unsupportedKeyrings));
+  }
+  return serializedKeyrings;
+};
+_restoreSerializedKeyrings = new WeakSet();
+restoreSerializedKeyrings_fn = async function(serializedKeyrings) {
+  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _clearKeyrings, clearKeyrings_fn).call(this);
+  for (const serializedKeyring of serializedKeyrings) {
+    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _restoreKeyring, restoreKeyring_fn).call(this, serializedKeyring);
+  }
+};
+_unlockKeyrings = new WeakSet();
+unlockKeyrings_fn = async function(password, encryptionKey, encryptionSalt) {
+  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withVaultLock, withVaultLock_fn).call(this, async ({ releaseLock }) => {
+    const encryptedVault = this.state.vault;
+    if (!encryptedVault) {
+      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
+    }
+    let vault;
+    const updatedState = {};
+    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
+      assertIsExportableKeyEncryptor(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor));
+      if (password) {
+        const result = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decryptWithDetail(
+          password,
+          encryptedVault
+        );
+        vault = result.vault;
+        _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
+        updatedState.encryptionKey = result.exportedKeyString;
+        updatedState.encryptionSalt = result.salt;
+      } else {
+        const parsedEncryptedVault = JSON.parse(encryptedVault);
+        if (encryptionSalt !== parsedEncryptedVault.salt) {
+          throw new Error("KeyringController - Encryption key and salt provided are expired" /* ExpiredCredentials */);
+        }
+        if (typeof encryptionKey !== "string") {
+          throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
+        }
+        const key = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).importKey(encryptionKey);
+        vault = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decryptWithKey(
+          key,
+          parsedEncryptedVault
+        );
+        updatedState.encryptionKey = encryptionKey;
+        updatedState.encryptionSalt = encryptionSalt;
+      }
+    } else {
+      if (typeof password !== "string") {
+        throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
+      }
+      vault = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).decrypt(password, encryptedVault);
+      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, password);
+    }
+    if (!isSerializedKeyringsArray(vault)) {
+      throw new Error("KeyringController - The decrypted vault has an unexpected shape." /* VaultDataError */);
+    }
+    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, vault);
+    const updatedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
+    this.update((state) => {
+      state.keyrings = updatedKeyrings;
+      if (updatedState.encryptionKey || updatedState.encryptionSalt) {
+        state.encryptionKey = updatedState.encryptionKey;
+        state.encryptionSalt = updatedState.encryptionSalt;
+      }
+    });
+    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password) && (!_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey) || !encryptionKey) && _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).isVaultUpdated && !_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).isVaultUpdated(encryptedVault)) {
+      releaseLock();
+      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _updateVault, updateVault_fn).call(this);
+    }
+    return _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings);
+  });
+};
+_updateVault = new WeakSet();
+updateVault_fn = function() {
+  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withVaultLock, withVaultLock_fn).call(this, async () => {
+    const { encryptionKey, encryptionSalt } = this.state;
+    if (!_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password) && !encryptionKey) {
+      throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
+    }
+    const serializedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
+    if (!serializedKeyrings.some((keyring) => keyring.type === "HD Key Tree" /* hd */)) {
+      throw new Error("KeyringController - No HD Keyring found" /* NoHdKeyring */);
+    }
+    const updatedState = {};
+    if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _cacheEncryptionKey)) {
+      assertIsExportableKeyEncryptor(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor));
+      if (encryptionKey) {
+        const key = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).importKey(encryptionKey);
+        const vaultJSON = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).encryptWithKey(
+          key,
+          serializedKeyrings
+        );
+        vaultJSON.salt = encryptionSalt;
+        updatedState.vault = JSON.stringify(vaultJSON);
+      } else if (_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password)) {
+        const { vault: newVault, exportedKeyString } = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).encryptWithDetail(
+          _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password),
+          serializedKeyrings
+        );
+        updatedState.vault = newVault;
+        updatedState.encryptionKey = exportedKeyString;
+      }
+    } else {
+      assertIsValidPassword(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password));
+      updatedState.vault = await _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _encryptor).encrypt(
+        _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password),
+        serializedKeyrings
+      );
+    }
+    if (!updatedState.vault) {
+      throw new Error("KeyringController - Cannot persist vault without vault information" /* MissingVaultData */);
+    }
+    const updatedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
+    this.update((state) => {
+      state.vault = updatedState.vault;
+      state.keyrings = updatedKeyrings;
+      if (updatedState.encryptionKey) {
+        state.encryptionKey = updatedState.encryptionKey;
+        state.encryptionSalt = JSON.parse(updatedState.vault).salt;
+      }
+    });
+    return true;
+  });
+};
+_getAccountsFromKeyrings = new WeakSet();
+getAccountsFromKeyrings_fn = async function() {
+  const keyrings = _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings);
+  const keyringArrays = await Promise.all(
+    keyrings.map(async (keyring) => keyring.getAccounts())
+  );
+  const addresses = keyringArrays.reduce((res, arr) => {
+    return res.concat(arr);
+  }, []);
+  return addresses.map(normalize);
+};
+_createKeyringWithFirstAccount = new WeakSet();
+createKeyringWithFirstAccount_fn = async function(type, opts) {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  const keyring = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, type, opts);
+  const [firstAccount] = await keyring.getAccounts();
+  if (!firstAccount) {
+    throw new Error("KeyringController - First Account not found." /* NoFirstAccount */);
+  }
+};
+_newKeyring = new WeakSet();
+newKeyring_fn = async function(type, data) {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  const keyringBuilder = _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, type);
+  if (!keyringBuilder) {
+    throw new Error(
+      `${"KeyringController - No keyringBuilder found for keyring" /* NoKeyringBuilder */}. Keyring type: ${type}`
+    );
+  }
+  const keyring = keyringBuilder();
+  await keyring.deserialize(data);
+  if (keyring.init) {
+    await keyring.init();
+  }
+  if (type === "HD Key Tree" /* hd */ && (!_utils.isObject.call(void 0, data) || !data.mnemonic)) {
+    if (!keyring.generateRandomMnemonic) {
+      throw new Error(
+        "KeyringController - The current keyring does not support the method generateRandomMnemonic." /* UnsupportedGenerateRandomMnemonic */
+      );
+    }
+    keyring.generateRandomMnemonic();
+    await keyring.addAccounts(1);
+  }
+  await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _checkForDuplicate, checkForDuplicate_fn).call(this, type, await keyring.getAccounts());
+  if (type === "QR Hardware Wallet Device" /* qr */) {
+    _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn).call(this, keyring);
+  }
+  _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).push(keyring);
+  return keyring;
+};
+_clearKeyrings = new WeakSet();
+clearKeyrings_fn = async function() {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  for (const keyring of _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings)) {
+    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
+  }
+  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, []);
+};
+_restoreKeyring = new WeakSet();
+restoreKeyring_fn = async function(serialized) {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  try {
+    const { type, data } = serialized;
+    return await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _newKeyring, newKeyring_fn).call(this, type, data);
+  } catch (_) {
+    _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _unsupportedKeyrings).push(serialized);
+    return void 0;
+  }
+};
+_destroyKeyring = new WeakSet();
+destroyKeyring_fn = async function(keyring) {
+  await keyring.destroy?.();
+};
+_removeEmptyKeyrings = new WeakSet();
+removeEmptyKeyrings_fn = async function() {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  const validKeyrings = [];
+  await Promise.all(
+    _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _keyrings).map(async (keyring) => {
+      const accounts = await keyring.getAccounts();
+      if (accounts.length > 0) {
+        validKeyrings.push(keyring);
+      } else {
+        await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
+      }
+    })
+  );
+  _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _keyrings, validKeyrings);
+};
+_checkForDuplicate = new WeakSet();
+checkForDuplicate_fn = async function(type, newAccountArray) {
+  const accounts = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
+  switch (type) {
+    case "Simple Key Pair" /* simple */: {
+      const isIncluded = Boolean(
+        accounts.find(
+          (key) => newAccountArray[0] && (key === newAccountArray[0] || key === _utils.remove0x.call(void 0, newAccountArray[0]))
+        )
+      );
+      if (isIncluded) {
+        throw new Error("KeyringController - The account you are trying to import is a duplicate" /* DuplicatedAccount */);
+      }
+      return newAccountArray;
+    }
+    default: {
+      return newAccountArray;
+    }
+  }
+};
+_setUnlocked = new WeakSet();
+setUnlocked_fn = function() {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  this.update((state) => {
+    state.isUnlocked = true;
+  });
+  this.messagingSystem.publish(`${name}:unlock`);
+};
+_persistOrRollback = new WeakSet();
+persistOrRollback_fn = async function(fn) {
+  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withRollback, withRollback_fn).call(this, async ({ releaseLock }) => {
+    const callbackResult = await fn({ releaseLock });
+    await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _updateVault, updateVault_fn).call(this);
+    return callbackResult;
+  });
+};
+_withRollback = new WeakSet();
+withRollback_fn = async function(fn) {
+  return _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _withControllerLock, withControllerLock_fn).call(this, async ({ releaseLock }) => {
+    const currentSerializedKeyrings = await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
+    const currentPassword = _chunkNOCGQCUMjs.__privateGet.call(void 0, this, _password);
+    try {
+      return await fn({ releaseLock });
+    } catch (e) {
+      await _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, currentSerializedKeyrings);
+      _chunkNOCGQCUMjs.__privateSet.call(void 0, this, _password, currentPassword);
+      throw e;
+    }
+  });
+};
+_assertControllerMutexIsLocked = new WeakSet();
+assertControllerMutexIsLocked_fn = function() {
+  if (!_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _controllerOperationMutex).isLocked()) {
+    throw new Error("KeyringController - attempt to update vault during a non mutually exclusive operation" /* ControllerLockRequired */);
+  }
+};
+_withControllerLock = new WeakSet();
+withControllerLock_fn = async function(fn) {
+  return withLock(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _controllerOperationMutex), fn);
+};
+_withVaultLock = new WeakSet();
+withVaultLock_fn = async function(fn) {
+  _chunkNOCGQCUMjs.__privateMethod.call(void 0, this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
+  return withLock(_chunkNOCGQCUMjs.__privateGet.call(void 0, this, _vaultOperationMutex), fn);
+};
+async function withLock(mutex, fn) {
+  const releaseLock = await mutex.acquire();
+  try {
+    return await fn({ releaseLock });
+  } finally {
+    releaseLock();
+  }
+}
+var KeyringController_default = KeyringController;
+
+
+
+
+
+
+
+
+
+
+exports.KeyringTypes = KeyringTypes; exports.isCustodyKeyring = isCustodyKeyring; exports.AccountImportStrategy = AccountImportStrategy; exports.SignTypedDataVersion = SignTypedDataVersion; exports.keyringBuilderFactory = keyringBuilderFactory; exports.getDefaultKeyringState = getDefaultKeyringState; exports.KeyringController = KeyringController; exports.KeyringController_default = KeyringController_default;
+//# sourceMappingURL=chunk-L4UUWIZA.js.map
\ No newline at end of file
diff --git a/dist/chunk-L4UUWIZA.js.map b/dist/chunk-L4UUWIZA.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..6eb539d49ddeacd961a2282b062088d22ab81bf1
--- /dev/null
+++ b/dist/chunk-L4UUWIZA.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["../src/KeyringController.ts"],"names":["KeyringTypes","AccountImportStrategy","SignTypedDataVersion"],"mappings":";;;;;;;;AACA,SAAS,gBAAgB,UAAU,qBAAqB;AAMxD,SAAS,sBAAsB;AAC/B,YAAY,oBAAoB;AAChC,OAAO,eAAe;AACtB,SAAS,aAAa,oBAAoB;AAC1C,OAAO,mBAAmB;AAmB1B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,aAAa;AAEtB,OAAO,UAAU,cAAc,iBAAiB;AAKhD,IAAM,OAAO;AAKN,IAAK,eAAL,kBAAKA,kBAAL;AACL,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,QAAK;AACL,EAAAA,cAAA,QAAK;AACL,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,YAAS;AACT,EAAAA,cAAA,aAAU;AACV,EAAAA,cAAA,UAAO;AAPG,SAAAA;AAAA,GAAA;AAgBL,IAAM,mBAAmB,CAAC,gBAAiC;AAChE,SAAO,YAAY,WAAW,SAAS;AACzC;AAgLO,IAAK,wBAAL,kBAAKC,2BAAL;AACL,EAAAA,uBAAA,gBAAa;AACb,EAAAA,uBAAA,UAAO;AAFG,SAAAA;AAAA,GAAA;AAUL,IAAK,uBAAL,kBAAKC,0BAAL;AACL,EAAAA,sBAAA,QAAK;AACL,EAAAA,sBAAA,QAAK;AACL,EAAAA,sBAAA,QAAK;AAHK,SAAAA;AAAA,GAAA;AA2IL,SAAS,sBAAsB,oBAAwC;AAC5E,QAAM,UAAU,MAAM,IAAI,mBAAmB;AAE7C,UAAQ,OAAO,mBAAmB;AAElC,SAAO;AACT;AAEA,IAAM,yBAAyB;AAAA,EAC7B,sBAAsB,aAAa;AAAA,EACnC,sBAAsB,SAAS;AACjC;AAEO,IAAM,yBAAyB,MAA8B;AAClE,SAAO;AAAA,IACL,YAAY;AAAA,IACZ,UAAU,CAAC;AAAA,EACb;AACF;AASA,SAAS,4BACP,SACgE;AAChE,MACE,EACE,YAAY,SAAS,UAAU,KAAK,QAAQ,oBAAoB,aAElE;AACA,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AACF;AASA,SAAS,+BACP,WAC6C;AAC7C,MACE,EACE,eAAe,aACf,OAAO,UAAU,cAAc,cAC/B,oBAAoB,aACpB,OAAO,UAAU,mBAAmB,cACpC,oBAAoB,aACpB,OAAO,UAAU,mBAAmB,aAEtC;AACA,UAAM,IAAI,sHAA2D;AAAA,EACvE;AACF;AAQA,SAAS,sBAAsB,UAA+C;AAC5E,MAAI,OAAO,aAAa,UAAU;AAChC,UAAM,IAAI,oFAA8C;AAAA,EAC1D;AAEA,MAAI,CAAC,YAAY,CAAC,SAAS,QAAQ;AACjC,UAAM,IAAI,gFAAiD;AAAA,EAC7D;AACF;AAQA,SAAS,0BACP,OAC8B;AAC9B,SACE,OAAO,UAAU,YACjB,MAAM,QAAQ,KAAK,KACnB,MAAM,MAAM,CAAC,UAAU,MAAM,QAAQ,YAAY,MAAM,IAAI,CAAC;AAEhE;AAUA,eAAe,kBACb,SAC+C;AAC/C,QAAM,WAAW,MAAM,QAAQ,YAAY;AAE3C,SAAO;AAAA,IACL,MAAM,QAAQ;AAAA;AAAA;AAAA,IAGd,UAAU,SAAS,IAAI,SAAS;AAAA,EAClC;AACF;AAQA,SAAS,aAAa,SAA0B;AAG9C;AAAA;AAAA,IAEE,kBAAkB,QAAQ,YAAY,CAAC;AAAA,IAEvC,kBAAkB,OAAc;AAAA;AAEpC;AAQA,SAAS,UAAU,SAAqC;AAMtD,SAAO,aAAa,OAAO,IAAI,aAAa,OAAO,IAAI;AACzD;AA9hBA;AAyiBO,IAAM,oBAAN,cAAgC,eAIrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BA,YAAY,SAAmC;AAC7C,UAAM;AAAA,MACJ,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAEJ,UAAM;AAAA,MACJ;AAAA,MACA,UAAU;AAAA,QACR,OAAO,EAAE,SAAS,MAAM,WAAW,MAAM;AAAA,QACzC,YAAY,EAAE,SAAS,OAAO,WAAW,KAAK;AAAA,QAC9C,UAAU,EAAE,SAAS,OAAO,WAAW,MAAM;AAAA,QAC7C,eAAe,EAAE,SAAS,OAAO,WAAW,MAAM;AAAA,QAClD,gBAAgB,EAAE,SAAS,OAAO,WAAW,MAAM;AAAA,MACrD;AAAA,MACA;AAAA,MACA,OAAO;AAAA,QACL,GAAG,uBAAuB;AAAA,QAC1B,GAAG;AAAA,MACL;AAAA,IACF,CAAC;AAmgCH;AAAA;AAAA;AAAA;AAAA;AAoEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAaN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AA+BN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAYN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AA2BN;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAmBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAkGN;AAAA;AAAA;AAAA;AAAA;AAAA;AAuEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAuBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAsBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAgDN;AAAA;AAAA;AAAA;AAAA,uBAAM;AAeN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAuBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAUN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AA+BN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAmCN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAiBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAsBN;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAeN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAM;AAnuDN,uBAAS,2BAA4B,IAAI,MAAM;AAE/C,uBAAS,sBAAuB,IAAI,MAAM;AAE1C;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAsCE,uBAAK,kBAAmB,kBACpB,uBAAuB,OAAO,eAAe,IAC7C;AAEJ,uBAAK,YAAa;AAClB,uBAAK,WAAY,CAAC;AAClB,uBAAK,sBAAuB,CAAC;AAI7B,uBAAK,qBAAsB,QAAQ,QAAQ,kBAAkB;AAC7D,QAAI,mBAAK,sBAAqB;AAC5B,qCAA+B,SAAS;AAAA,IAC1C;AAEA,0BAAK,sDAAL;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,cAAc,cAAwC;AAC1D,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,iBAAiB,KAAK,kBAAkB,aAAa,EAAE,CAAC;AAG9D,UAAI,CAAC,gBAAgB;AACnB,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AACA,YAAM,cAAc,MAAM,eAAe,YAAY;AAErD,UAAI,gBAAgB,YAAY,WAAW,cAAc;AACvD,YAAI,eAAe,YAAY,QAAQ;AACrC,gBAAM,IAAI,MAAM,yBAAyB;AAAA,QAC3C;AAEA,cAAM,kBAAkB,YAAY,YAAY;AAEhD,YAAI,CAAC,iBAAiB;AACpB,gBAAM,IAAI,MAAM,+BAA+B,YAAY,EAAE;AAAA,QAC/D;AAEA,eAAO;AAAA,MACT;AAEA,YAAM,CAAC,mBAAmB,IAAI,MAAM,eAAe,YAAY,CAAC;AAChE,YAAM,KAAK,iBAAiB;AAE5B,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,wBACJ,SACA,cACc;AAKd,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,cAAc,MAAM,sBAAK,sDAAL;AAE1B,UAAI,gBAAgB,YAAY,WAAW,cAAc;AACvD,YAAI,eAAe,YAAY,QAAQ;AACrC,gBAAM,IAAI,MAAM,yBAAyB;AAAA,QAC3C;AAEA,cAAM,kBAAkB,YAAY,YAAY;AAChD,gCAAwB,eAAe;AAEvC,eAAO;AAAA,MACT;AAEA,YAAM,QAAQ,YAAY,CAAC;AAE3B,YAAM,uBAAuB,MAAM,sBAAK,sDAAL,YAAiC;AAAA,QAClE,CAAC,oBAAoB,CAAC,YAAY,SAAS,eAAe;AAAA,MAC5D;AACA,8BAAwB,mBAAmB;AAE3C,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,6BAA8C;AAClD,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,iBAAiB,KAAK,kBAAkB,aAAa,EAAE,CAAC;AAG9D,UAAI,CAAC,gBAAgB;AACnB,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AACA,YAAM,CAAC,mBAAmB,IAAI,MAAM,eAAe,YAAY,CAAC;AAChE,YAAM,KAAK,iBAAiB;AAC5B,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,yBACJ,UACA,MACe;AACf,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,4BAAsB,QAAQ;AAE9B,YAAM,sBAAK,0DAAL,WAAgC,UAAU;AAAA,QAC9C,MAAM;AAAA,QACN,MAAM;AAAA,UACJ,UAAU;AAAA,UACV,kBAAkB;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,0BAA0B,UAAkB;AAChD,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,WAAW,MAAM,sBAAK,sDAAL;AACvB,UAAI,CAAC,SAAS,QAAQ;AACpB,cAAM,sBAAK,0DAAL,WAAgC,UAAU;AAAA,UAC9C,MAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,cACJ,MACA,MACkB;AAClB,QAAI,SAAS,sCAAiB;AAC5B,aAAO,KAAK,kBAAkB;AAAA,IAChC;AAEA,WAAO,sBAAK,0CAAL,WAAwB,YAAY,sBAAK,4BAAL,WAAiB,MAAM;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,eAAe,UAAkB;AACrC,QAAI,CAAC,KAAK,MAAM,OAAO;AACrB,YAAM,IAAI,oFAAuC;AAAA,IACnD;AACA,UAAM,mBAAK,YAAW,QAAQ,UAAU,KAAK,MAAM,KAAK;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAsB;AACpB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,iBAAiB,UAAuC;AAC5D,UAAM,KAAK,eAAe,QAAQ;AAClC,gCAA4B,mBAAK,WAAU,CAAC,CAAC;AAC7C,WAAO,mBAAK,WAAU,CAAC,EAAE;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,cAAc,UAAkB,SAAkC;AACtE,UAAM,KAAK,eAAe,QAAQ;AAElC,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ,eAAe;AAC1B,YAAM,IAAI,yIAAqD;AAAA,IACjE;AAEA,WAAO,MAAM,QAAQ,cAAc,UAAU,OAAO,CAAQ;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,cAAiC;AACrC,WAAO,KAAK,MAAM,SAAS;AAAA,MACzB,CAAC,UAAU,YAAY,SAAS,OAAO,QAAQ,QAAQ;AAAA,MACvD,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,uBACJ,SACA,MACiB;AACjB,UAAM,UAAU,aAAa,OAAO;AACpC,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ,wBAAwB;AACnC,YAAM,IAAI,2JAA8D;AAAA,IAC1E;AAEA,WAAO,MAAM,QAAQ,uBAAuB,SAAS,IAAI;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,eAAe,eAGD;AAClB,UAAM,UAAU,aAAa,cAAc,IAAI;AAC/C,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ,gBAAgB;AAC3B,YAAM,IAAI,2IAAsD;AAAA,IAClE;AAEA,WAAO,QAAQ,eAAe,SAAS,cAAc,IAAI;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,qBAAqB,SAAmC;AAC5D,UAAM,UAAU,UAAU,OAAO;AAEjC,UAAM,aAAa,MAAM,QAAQ;AAAA,MAC/B,mBAAK,WAAU,IAAI,OAAO,YAAY;AACpC,eAAO,QAAQ,IAAI,CAAC,SAAS,QAAQ,YAAY,CAAC,CAAC;AAAA,MACrD,CAAC;AAAA,IACH;AAEA,UAAM,UAAU,WAAW,OAAO,CAAC,cAAc;AAC/C,YAAM,WAAW,UAAU,CAAC,EAAE,IAAI,SAAS;AAC3C,aAAO,SAAS,SAAS,OAAO;AAAA,IAClC,CAAC;AAED,QAAI,QAAQ,UAAU,QAAQ,CAAC,GAAG,QAAQ;AACxC,aAAO,QAAQ,CAAC,EAAE,CAAC;AAAA,IACrB;AAGA,QAAI,YAAY;AAChB,QAAI,CAAC,WAAW,QAAQ;AACtB,kBAAY;AAAA,IACd,WAAW,CAAC,QAAQ,QAAQ;AAC1B,kBAAY;AAAA,IACd;AACA,UAAM,IAAI;AAAA,MACR,yDAAmC,iBAAiB,SAAS;AAAA,IAC/D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,kBAAkB,MAAwC;AACxD,WAAO,mBAAK,WAAU,OAAO,CAAC,YAAY,QAAQ,SAAS,IAAI;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,qBAAuC;AAC3C,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,0BACJ,UAGA,MACiB;AACjB,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,UAAI;AACJ,cAAQ,UAAU;AAAA,QAChB,KAAK;AACH,gBAAM,CAAC,WAAW,IAAI;AACtB,cAAI,CAAC,aAAa;AAChB,kBAAM,IAAI,MAAM,6BAA6B;AAAA,UAC/C;AACA,gBAAM,WAAW,MAAM,WAAW;AAElC,cAAI;AACJ,cAAI;AACF,iCAAqB,SAAS,QAAQ;AAAA,UACxC,QAAQ;AACN,kBAAM,IAAI,MAAM,oCAAoC;AAAA,UACtD;AAEA,cACE,CAAC,eAAe,kBAAkB;AAAA,UAElC,cAAc,QAAQ,MAAM,KAAK,KAAK,QACtC;AACA,kBAAM,IAAI,MAAM,oCAAoC;AAAA,UACtD;AAEA,uBAAa,SAAS,QAAQ;AAC9B;AAAA,QACF,KAAK;AACH,cAAI;AACJ,gBAAM,CAAC,OAAO,QAAQ,IAAI;AAC1B,cAAI;AACF,qBAAS,UAAU,gBAAgB,OAAO,QAAQ;AAAA,UACpD,SAAS,GAAG;AACV,qBAAS,UAAW,MAAM,OAAO,OAAO,OAAO,UAAU,IAAI;AAAA,UAC/D;AACA,uBAAa,WAAW,OAAO,cAAc,CAAC;AAC9C;AAAA,QACF;AACE,gBAAM,IAAI,MAAM,gCAAgC,QAAQ,GAAG;AAAA,MAC/D;AACA,YAAM,aAAc,MAAM,sBAAK,4BAAL,WAAiB,gCAAqB;AAAA,QAC9D;AAAA,MACF;AACA,YAAM,WAAW,MAAM,WAAW,YAAY;AAC9C,aAAO,SAAS,CAAC;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,cAAc,SAAgC;AAClD,UAAM,sBAAK,0CAAL,WAAwB,YAAY;AACxC,YAAM,UAAW,MAAM,KAAK;AAAA,QAC1B;AAAA,MACF;AAGA,UAAI,CAAC,QAAQ,eAAe;AAC1B,cAAM,IAAI,yIAAqD;AAAA,MACjE;AAQA,YAAM,QAAQ,cAAc,OAAc;AAE1C,YAAM,WAAW,MAAM,QAAQ,YAAY;AAE3C,UAAI,SAAS,WAAW,GAAG;AACzB,cAAM,sBAAK,8CAAL;AAAA,MACR;AAAA,IACF;AAEA,SAAK,gBAAgB,QAAQ,GAAG,IAAI,mBAAmB,OAAO;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,YAA2B;AAC/B,WAAO,sBAAK,gCAAL,WAAmB,YAAY;AACpC,4BAAK,sEAAL;AAEA,yBAAK,WAAY;AACjB,YAAM,sBAAK,kCAAL;AAEN,WAAK,OAAO,CAAC,UAAU;AACrB,cAAM,aAAa;AACnB,cAAM,WAAW,CAAC;AAClB,eAAO,MAAM;AACb,eAAO,MAAM;AAAA,MACf,CAAC;AAED,WAAK,gBAAgB,QAAQ,GAAG,IAAI,OAAO;AAAA,IAC7C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,YAAY,eAAuD;AACvE,QAAI,CAAC,cAAc,MAAM;AACvB,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAEA,UAAM,UAAU,aAAa,cAAc,IAAI;AAC/C,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ,aAAa;AACxB,YAAM,IAAI,qIAAmD;AAAA,IAC/D;AAEA,WAAO,MAAM,QAAQ,YAAY,SAAS,cAAc,IAAI;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,oBAAoB,eAAsC;AAC9D,UAAM,UAAU,aAAa,cAAc,IAAI;AAC/C,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ,qBAAqB;AAChC,YAAM,IAAI,qJAA2D;AAAA,IACvE;AAEA,UAAM,iBAAiB,UAAU,cAAc,IAAI;AAEnD,WAAO,MAAM,QAAQ,oBAAoB,SAAS,cAAc;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,iBACJ,eACA,SACiB;AACjB,QAAI;AACF,UACE,CAAC;AAAA,QACC;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAE,SAAS,OAAO,GAClB;AACA,cAAM,IAAI,MAAM,yCAAyC,OAAO,GAAG;AAAA,MACrE;AAIA,YAAM,UAAU,aAAa,cAAc,IAAI;AAC/C,YAAM,UAAW,MAAM,KAAK;AAAA,QAC1B;AAAA,MACF;AACA,UAAI,CAAC,QAAQ,eAAe;AAC1B,cAAM,IAAI,+IAAwD;AAAA,MACpE;AAEA,aAAO,MAAM,QAAQ;AAAA,QACnB;AAAA,QACA,YAAY,iBACV,OAAO,cAAc,SAAS,WAC5B,KAAK,MAAM,cAAc,IAAI,IAC7B,cAAc;AAAA,QAClB,EAAE,QAAQ;AAAA,MACZ;AAAA,IACF,SAAS,OAAO;AACd,YAAM,IAAI,MAAM,wCAAwC,KAAK,EAAE;AAAA,IACjE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,gBACJ,aACA,MACA,MACiB;AACjB,UAAM,UAAU,aAAa,IAAI;AACjC,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,QAAI,CAAC,QAAQ,iBAAiB;AAC5B,YAAM,IAAI,6IAAuD;AAAA,IACnE;AAEA,WAAO,MAAM,QAAQ,gBAAgB,SAAS,aAAa,IAAI;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,qBACJ,MACA,cACA,kBAC+B;AAC/B,UAAM,UAAU,aAAa,IAAI;AACjC,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AAEA,QAAI,CAAC,QAAQ,sBAAsB;AACjC,YAAM,IAAI,uJAA4D;AAAA,IACxE;AAEA,WAAO,MAAM,QAAQ;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,mBACJ,MACA,QACA,kBACgC;AAChC,UAAM,UAAU,aAAa,IAAI;AACjC,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AAEA,QAAI,CAAC,QAAQ,oBAAoB;AAC/B,YAAM,IAAI,mJAA0D;AAAA,IACtE;AAEA,WAAO,MAAM,QAAQ,mBAAmB,SAAS,QAAQ,gBAAgB;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,kBACJ,MACA,QACA,kBACiB;AACjB,UAAM,UAAU,aAAa,IAAI;AACjC,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AAEA,QAAI,CAAC,QAAQ,mBAAmB;AAC9B,YAAM,IAAI,iJAAyD;AAAA,IACrE;AAEA,WAAO,MAAM,QAAQ,kBAAkB,SAAS,QAAQ,gBAAgB;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAe,UAAiC;AAC9C,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,UAAI,CAAC,KAAK,MAAM,YAAY;AAC1B,cAAM,IAAI,6GAA+C;AAAA,MAC3D;AAEA,4BAAsB,QAAQ;AAE9B,yBAAK,WAAY;AAIjB,UAAI,mBAAK,sBAAqB;AAC5B,aAAK,OAAO,CAAC,UAAU;AACrB,iBAAO,MAAM;AACb,iBAAO,MAAM;AAAA,QACf,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,oBACJ,eACA,gBACe;AACf,WAAO,sBAAK,gCAAL,WAAmB,YAAY;AACpC,yBAAK,WAAY,MAAM,sBAAK,oCAAL,WACrB,QACA,eACA;AAEF,4BAAK,8BAAL;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,eAAe,UAAiC;AACpD,WAAO,sBAAK,gCAAL,WAAmB,YAAY;AACpC,yBAAK,WAAY,MAAM,sBAAK,oCAAL,WAAqB;AAC5C,4BAAK,8BAAL;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,mBAAwC;AAC5C,UAAM,iBAAiB,KAAK,kBAAkB,sBAAe,EAAE,CAAC;AAGhE,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AAEA,gCAA4B,cAAc;AAE1C,UAAM,YAAY,eAAe;AACjC,UAAM,WAAW,MAAM,eAAe,YAAY;AAElD,QAAI,SAAS,WAAW,GAAG;AACzB,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AAIA,UAAM,mBAAmB,sBAAK,wDAAL,WAA+B;AAExD,UAAM,YAAY,iBAAiB;AAGnC,UAAM,UAAU,YAAY;AAAA,MAC1B,UAAU;AAAA,MACV,kBAAkB,SAAS;AAAA,IAC7B,CAAC;AACD,UAAM,eAAe,MAAM,UAAU,YAAY;AAEjD,QAAI,aAAa,WAAW,SAAS,QAAQ;AAC3C,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAEA,iBAAa,QAAQ,CAAC,SAAiB,MAAc;AAEnD,UAAI,QAAQ,YAAY,MAAM,SAAS,CAAC,EAAE,YAAY,GAAG;AACvD,cAAM,IAAI,MAAM,0CAA0C;AAAA,MAC5D;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AAAA,EAwDA,MAAM,YAIJ,UACA,WACA,UAE0D;AAAA,IACxD,iBAAiB;AAAA,EACnB,GACyB;AACzB,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,UAAI;AAEJ,UAAI,aAAa,UAAU;AACzB,kBAAW,MAAM,KAAK,qBAAqB,SAAS,OAAO;AAAA,MAG7D,OAAO;AACL,kBAAU,KAAK,kBAAkB,SAAS,IAAI,EAAE,SAAS,SAAS,CAAC;AAInE,YAAI,CAAC,WAAW,QAAQ,iBAAiB;AACvC,oBAAW,MAAM,sBAAK,4BAAL,WACf,SAAS,MACT,QAAQ;AAAA,QAEZ;AAAA,MACF;AAEA,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,oEAA4C;AAAA,MACxD;AAEA,YAAM,SAAS,MAAM,UAAU,OAAO;AAEtC,UAAI,OAAO,GAAG,QAAQ,OAAO,GAAG;AAK9B,cAAM,IAAI,iGAAsD;AAAA,MAClE;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAsC;AAEpC,WAAO,KAAK,kBAAkB,oCAAe,EAAE,CAAC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,oBAAwC;AAC5C,WACE,KAAK,aAAa,KACjB,MAAM,sBAAK,0CAAL,WAAwB,YAAY,sBAAK,gCAAL;AAAA,EAE/C;AAAA;AAAA;AAAA,EAIA,MAAM,iBAAiB,YAAgC;AACrD,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,UAAU,KAAK,aAAa,KAAM,MAAM,sBAAK,gCAAL;AAC9C,cAAQ,YAAY,UAAU;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,MAAM,sBAAqC;AACzC,KAAC,MAAM,KAAK,kBAAkB,GAAG,WAAW;AAAA,EAC9C;AAAA,EAEA,MAAM,oBAA8C;AAClD,YAAQ,MAAM,KAAK,kBAAkB,GAAG,YAAY;AAAA,EACtD;AAAA,EAEA,MAAM,oBAAoB,aAAoC;AAC5D,KAAC,MAAM,KAAK,kBAAkB,GAAG,kBAAkB,WAAW;AAAA,EAChE;AAAA,EAEA,MAAM,sBAAsB,eAAsC;AAChE,KAAC,MAAM,KAAK,kBAAkB,GAAG,oBAAoB,aAAa;AAAA,EACpE;AAAA,EAEA,MAAM,kBACJ,WACA,cACe;AACf,KAAC,MAAM,KAAK,kBAAkB,GAAG,gBAAgB,WAAW,YAAY;AAAA,EAC1E;AAAA,EAEA,MAAM,sBAAqC;AACzC,KAAC,MAAM,KAAK,kBAAkB,GAAG,kBAAkB;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,0BAAyC;AAE7C,KAAC,MAAM,KAAK,kBAAkB,GAAG,WAAW;AAAA,EAC9C;AAAA,EAEA,MAAM,kBACJ,MACgE;AAChE,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,UAAI;AACF,cAAM,UAAU,KAAK,aAAa,KAAM,MAAM,sBAAK,gCAAL;AAC9C,YAAI;AACJ,gBAAQ,MAAM;AAAA,UACZ,KAAK;AACH,uBAAW,MAAM,QAAQ,gBAAgB;AACzC;AAAA,UACF,KAAK;AACH,uBAAW,MAAM,QAAQ,YAAY;AACrC;AAAA,UACF;AACE,uBAAW,MAAM,QAAQ,aAAa;AAAA,QAC1C;AAGA,eAAO,SAAS,IAAI,CAAC,YAAiB;AACpC,iBAAO;AAAA,YACL,GAAG;AAAA,YACH,SAAS;AAAA,UACX;AAAA,QACF,CAAC;AAAA,MACH,SAAS,GAAG;AAGV,cAAM,IAAI,MAAM,+CAA+C,CAAC,EAAE;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,8BAA8B,OAA8B;AAChE,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,UAAU,KAAK,aAAa,KAAM,MAAM,sBAAK,gCAAL;AAE9C,cAAQ,mBAAmB,KAAK;AAChC,YAAM,QAAQ,YAAY,CAAC;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,MAAM,sBAAsB,SAAkC;AAC5D,UAAM,UAAW,MAAM,KAAK;AAAA,MAC1B;AAAA,IACF;AACA,WAAO,QAAQ;AAAA,EACjB;AAAA,EAEA,MAAM,iBAGH;AACD,WAAO,sBAAK,0CAAL,WAAwB,YAAY;AACzC,YAAM,UAAU,KAAK,aAAa;AAElC,UAAI,CAAC,SAAS;AACZ,eAAO,EAAE,iBAAiB,CAAC,GAAG,mBAAmB,CAAC,EAAE;AAAA,MACtD;AAEA,YAAM,cAAe,MAAM,sBAAK,sDAAL;AAC3B,cAAQ,aAAa;AACrB,YAAM,oBACH,MAAM,sBAAK,sDAAL;AACT,YAAM,kBAAkB,YAAY;AAAA,QAClC,CAAC,YAAoB,CAAC,kBAAkB,SAAS,OAAO;AAAA,MAC1D;AACA,aAAO,EAAE,iBAAiB,kBAAkB;AAAA,IAC9C;AAAA,EACF;AAurBF;AAxuDW;AAEA;AAET;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAuiCA;AAAA,6BAAwB,WAAG;AACzB,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,YAAY,KAAK,IAAI;AAAA,EAC5B;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,oBAAoB,KAAK,IAAI;AAAA,EACpC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,iBAAiB,KAAK,IAAI;AAAA,EACjC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,eAAe,KAAK,IAAI;AAAA,EAC/B;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,uBAAuB,KAAK,IAAI;AAAA,EACvC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,YAAY,KAAK,IAAI;AAAA,EAC5B;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,kBAAkB,KAAK,IAAI;AAAA,EAClC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,qBAAqB,KAAK,IAAI;AAAA,EACrC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,mBAAmB,KAAK,IAAI;AAAA,EACnC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,qBAAqB,KAAK,IAAI;AAAA,EACrC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,mBAAmB,KAAK,IAAI;AAAA,EACnC;AAEA,OAAK,gBAAgB;AAAA,IACnB,GAAG,IAAI;AAAA,IACP,KAAK,kBAAkB,KAAK,IAAI;AAAA,EAClC;AACF;AAQA;AAAA,8BAAyB,SACvB,MACoD;AACpD,SAAO,mBAAK,kBAAiB;AAAA,IAC3B,CAAC,mBAAmB,eAAe,SAAS;AAAA,EAC9C;AACF;AASM;AAAA,kBAAa,iBAAuB;AACxC,wBAAK,kEAAL;AAGA,SAAQ,MAAM,sBAAK,4BAAL,WAAiB;AACjC;AAQA;AAAA,gCAA2B,SAAC,WAAsB;AAChD,qBAAK,yBAA0B,CAAC,UAAU;AACxC,SAAK,gBAAgB,QAAQ,GAAG,IAAI,yBAAyB,KAAK;AAAA,EACpE;AAEA,YAAU,YAAY,EAAE,UAAU,mBAAK,wBAAuB;AAChE;AAEA;AAAA,qCAAgC,WAAG;AACjC,QAAM,aAAa,KAAK;AAAA,IACtB;AAAA,EACF;AAEA,aAAW,QAAQ,CAAC,cAAc;AAChC,QAAI,mBAAK,0BAAyB;AAChC,gBAAU,YAAY,EAAE,YAAY,mBAAK,wBAAuB;AAAA,IAClE;AAAA,EACF,CAAC;AACH;AAgBM;AAAA,+BAA0B,eAC9B,UACA,SAIe;AACf,wBAAK,kEAAL;AAEA,MAAI,OAAO,aAAa,UAAU;AAChC,UAAM,IAAI,wFAAkD;AAAA,EAC9D;AAEA,OAAK,OAAO,CAAC,UAAU;AACrB,WAAO,MAAM;AACb,WAAO,MAAM;AAAA,EACf,CAAC;AAED,qBAAK,WAAY;AAEjB,QAAM,sBAAK,kCAAL;AACN,QAAM,sBAAK,kEAAL,WAAoC,QAAQ,MAAM,QAAQ;AAChE,wBAAK,8BAAL;AACF;AAQM;AAAA,wBAAmB,iBAA6B;AACpD,SAAO,QAAQ,IAAI,mBAAK,WAAU,IAAI,iBAAiB,CAAC;AAC1D;AAUM;AAAA,2BAAsB,eAC1B,EAAE,mBAAmB,IAAqC;AAAA,EACxD,oBAAoB;AACtB,GAC8B;AAC9B,QAAM,qBAAqB,MAAM,QAAQ;AAAA,IACvC,mBAAK,WAAU,IAAI,OAAO,YAAY;AACpC,YAAM,CAAC,MAAM,IAAI,IAAI,MAAM,QAAQ,IAAI;AAAA,QACrC,QAAQ;AAAA,QACR,QAAQ,UAAU;AAAA,MACpB,CAAC;AACD,aAAO,EAAE,MAAM,KAAK;AAAA,IACtB,CAAC;AAAA,EACH;AAEA,MAAI,oBAAoB;AACtB,uBAAmB,KAAK,GAAG,mBAAK,qBAAoB;AAAA,EACtD;AAEA,SAAO;AACT;AAOM;AAAA,+BAA0B,eAC9B,oBACe;AACf,QAAM,sBAAK,kCAAL;AAEN,aAAW,qBAAqB,oBAAoB;AAClD,UAAM,sBAAK,oCAAL,WAAqB;AAAA,EAC7B;AACF;AAWM;AAAA,oBAAe,eACnB,UACA,eACA,gBAC6B;AAC7B,SAAO,sBAAK,kCAAL,WAAoB,OAAO,EAAE,YAAY,MAAM;AACpD,UAAM,iBAAiB,KAAK,MAAM;AAClC,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI,oFAAuC;AAAA,IACnD;AAEA,QAAI;AACJ,UAAM,eAAgD,CAAC;AAEvD,QAAI,mBAAK,sBAAqB;AAC5B,qCAA+B,mBAAK,WAAU;AAE9C,UAAI,UAAU;AACZ,cAAM,SAAS,MAAM,mBAAK,YAAW;AAAA,UACnC;AAAA,UACA;AAAA,QACF;AACA,gBAAQ,OAAO;AACf,2BAAK,WAAY;AAEjB,qBAAa,gBAAgB,OAAO;AACpC,qBAAa,iBAAiB,OAAO;AAAA,MACvC,OAAO;AACL,cAAM,uBAAuB,KAAK,MAAM,cAAc;AAEtD,YAAI,mBAAmB,qBAAqB,MAAM;AAChD,gBAAM,IAAI,iGAA+C;AAAA,QAC3D;AAEA,YAAI,OAAO,kBAAkB,UAAU;AACrC,gBAAM,IAAI,wFAAkD;AAAA,QAC9D;AAEA,cAAM,MAAM,MAAM,mBAAK,YAAW,UAAU,aAAa;AACzD,gBAAQ,MAAM,mBAAK,YAAW;AAAA,UAC5B;AAAA,UACA;AAAA,QACF;AAIA,qBAAa,gBAAgB;AAI7B,qBAAa,iBAAiB;AAAA,MAChC;AAAA,IACF,OAAO;AACL,UAAI,OAAO,aAAa,UAAU;AAChC,cAAM,IAAI,wFAAkD;AAAA,MAC9D;AAEA,cAAQ,MAAM,mBAAK,YAAW,QAAQ,UAAU,cAAc;AAC9D,yBAAK,WAAY;AAAA,IACnB;AAEA,QAAI,CAAC,0BAA0B,KAAK,GAAG;AACrC,YAAM,IAAI,6FAA2C;AAAA,IACvD;AAEA,UAAM,sBAAK,0DAAL,WAAgC;AACtC,UAAM,kBAAkB,MAAM,sBAAK,4CAAL;AAE9B,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,WAAW;AACjB,UAAI,aAAa,iBAAiB,aAAa,gBAAgB;AAC7D,cAAM,gBAAgB,aAAa;AACnC,cAAM,iBAAiB,aAAa;AAAA,MACtC;AAAA,IACF,CAAC;AAED,QACE,mBAAK,eACJ,CAAC,mBAAK,wBAAuB,CAAC,kBAC/B,mBAAK,YAAW,kBAChB,CAAC,mBAAK,YAAW,eAAe,cAAc,GAC9C;AAGA,kBAAY;AAEZ,YAAM,sBAAK,8BAAL;AAAA,IACR;AAEA,WAAO,mBAAK;AAAA,EACd;AACF;AAOA;AAAA,iBAAY,WAAqB;AAC/B,SAAO,sBAAK,kCAAL,WAAoB,YAAY;AACrC,UAAM,EAAE,eAAe,eAAe,IAAI,KAAK;AAE/C,QAAI,CAAC,mBAAK,cAAa,CAAC,eAAe;AACrC,YAAM,IAAI,6GAA+C;AAAA,IAC3D;AAEA,UAAM,qBAAqB,MAAM,sBAAK,kDAAL;AAEjC,QACE,CAAC,mBAAmB,KAAK,CAAC,YAAY,QAAQ,SAAS,sBAAe,GACtE;AACA,YAAM,IAAI,iEAAwC;AAAA,IACpD;AAEA,UAAM,eAAgD,CAAC;AAEvD,QAAI,mBAAK,sBAAqB;AAC5B,qCAA+B,mBAAK,WAAU;AAE9C,UAAI,eAAe;AACjB,cAAM,MAAM,MAAM,mBAAK,YAAW,UAAU,aAAa;AACzD,cAAM,YAAY,MAAM,mBAAK,YAAW;AAAA,UACtC;AAAA,UACA;AAAA,QACF;AACA,kBAAU,OAAO;AACjB,qBAAa,QAAQ,KAAK,UAAU,SAAS;AAAA,MAC/C,WAAW,mBAAK,YAAW;AACzB,cAAM,EAAE,OAAO,UAAU,kBAAkB,IACzC,MAAM,mBAAK,YAAW;AAAA,UACpB,mBAAK;AAAA,UACL;AAAA,QACF;AAEF,qBAAa,QAAQ;AACrB,qBAAa,gBAAgB;AAAA,MAC/B;AAAA,IACF,OAAO;AACL,4BAAsB,mBAAK,UAAS;AACpC,mBAAa,QAAQ,MAAM,mBAAK,YAAW;AAAA,QACzC,mBAAK;AAAA,QACL;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,aAAa,OAAO;AACvB,YAAM,IAAI,iGAA6C;AAAA,IACzD;AAEA,UAAM,kBAAkB,MAAM,sBAAK,4CAAL;AAC9B,SAAK,OAAO,CAAC,UAAU;AACrB,YAAM,QAAQ,aAAa;AAC3B,YAAM,WAAW;AACjB,UAAI,aAAa,eAAe;AAC9B,cAAM,gBAAgB,aAAa;AACnC,cAAM,iBAAiB,KAAK,MAAM,aAAa,KAAe,EAAE;AAAA,MAClE;AAAA,IACF,CAAC;AAED,WAAO;AAAA,EACT;AACF;AAQM;AAAA,6BAAwB,iBAAsB;AAClD,QAAM,WAAW,mBAAK;AAEtB,QAAM,gBAAgB,MAAM,QAAQ;AAAA,IAClC,SAAS,IAAI,OAAO,YAAY,QAAQ,YAAY,CAAC;AAAA,EACvD;AACA,QAAM,YAAY,cAAc,OAAO,CAAC,KAAK,QAAQ;AACnD,WAAO,IAAI,OAAO,GAAG;AAAA,EACvB,GAAG,CAAC,CAAC;AAIL,SAAO,UAAU,IAAI,SAAS;AAChC;AAUM;AAAA,mCAA8B,eAAC,MAAc,MAAgB;AACjE,wBAAK,kEAAL;AAEA,QAAM,UAAW,MAAM,sBAAK,4BAAL,WAAiB,MAAM;AAE9C,QAAM,CAAC,YAAY,IAAI,MAAM,QAAQ,YAAY;AACjD,MAAI,CAAC,cAAc;AACjB,UAAM,IAAI,yEAA2C;AAAA,EACvD;AACF;AAaM;AAAA,gBAAW,eAAC,MAAc,MAA2C;AACzE,wBAAK,kEAAL;AAEA,QAAM,iBAAiB,sBAAK,wDAAL,WAA+B;AAEtD,MAAI,CAAC,gBAAgB;AACnB,UAAM,IAAI;AAAA,MACR,mFAA0C,mBAAmB,IAAI;AAAA,IACnE;AAAA,EACF;AAEA,QAAM,UAAU,eAAe;AAG/B,QAAM,QAAQ,YAAY,IAAI;AAE9B,MAAI,QAAQ,MAAM;AAChB,UAAM,QAAQ,KAAK;AAAA,EACrB;AAEA,MAAI,SAAS,2BAAoB,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,WAAW;AACnE,QAAI,CAAC,QAAQ,wBAAwB;AACnC,YAAM,IAAI;AAAA;AAAA,MAEV;AAAA,IACF;AAEA,YAAQ,uBAAuB;AAC/B,UAAM,QAAQ,YAAY,CAAC;AAAA,EAC7B;AAEA,QAAM,sBAAK,0CAAL,WAAwB,MAAM,MAAM,QAAQ,YAAY;AAE9D,MAAI,SAAS,sCAAiB;AAG5B,0BAAK,4DAAL,WAAiC;AAAA,EACnC;AAEA,qBAAK,WAAU,KAAK,OAAO;AAE3B,SAAO;AACT;AAMM;AAAA,mBAAc,iBAAG;AACrB,wBAAK,kEAAL;AACA,aAAW,WAAW,mBAAK,YAAW;AACpC,UAAM,sBAAK,oCAAL,WAAqB;AAAA,EAC7B;AACA,qBAAK,WAAY,CAAC;AACpB;AASM;AAAA,oBAAe,eACnB,YACuC;AACvC,wBAAK,kEAAL;AAEA,MAAI;AACF,UAAM,EAAE,MAAM,KAAK,IAAI;AACvB,WAAO,MAAM,sBAAK,4BAAL,WAAiB,MAAM;AAAA,EACtC,SAAS,GAAG;AACV,uBAAK,sBAAqB,KAAK,UAAU;AACzC,WAAO;AAAA,EACT;AACF;AAWM;AAAA,oBAAe,eAAC,SAA2B;AAC/C,QAAM,QAAQ,UAAU;AAC1B;AAQM;AAAA,yBAAoB,iBAAkB;AAC1C,wBAAK,kEAAL;AACA,QAAM,gBAAoC,CAAC;AAM3C,QAAM,QAAQ;AAAA,IACZ,mBAAK,WAAU,IAAI,OAAO,YAA8B;AACtD,YAAM,WAAW,MAAM,QAAQ,YAAY;AAC3C,UAAI,SAAS,SAAS,GAAG;AACvB,sBAAc,KAAK,OAAO;AAAA,MAC5B,OAAO;AACL,cAAM,sBAAK,oCAAL,WAAqB;AAAA,MAC7B;AAAA,IACF,CAAC;AAAA,EACH;AACA,qBAAK,WAAY;AACnB;AAYM;AAAA,uBAAkB,eACtB,MACA,iBACmB;AACnB,QAAM,WAAW,MAAM,sBAAK,sDAAL;AAEvB,UAAQ,MAAM;AAAA,IACZ,KAAK,gCAAqB;AACxB,YAAM,aAAa;AAAA,QACjB,SAAS;AAAA,UACP,CAAC,QACC,gBAAgB,CAAC,MAChB,QAAQ,gBAAgB,CAAC,KACxB,QAAQ,SAAS,gBAAgB,CAAC,CAAC;AAAA,QACzC;AAAA,MACF;AAEA,UAAI,YAAY;AACd,cAAM,IAAI,uGAA8C;AAAA,MAC1D;AACA,aAAO;AAAA,IACT;AAAA,IAEA,SAAS;AACP,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAQA;AAAA,iBAAY,WAAS;AACnB,wBAAK,kEAAL;AAEA,OAAK,OAAO,CAAC,UAAU;AACrB,UAAM,aAAa;AAAA,EACrB,CAAC;AACD,OAAK,gBAAgB,QAAQ,GAAG,IAAI,SAAS;AAC/C;AAUM;AAAA,uBAAqB,eAAC,IAA8C;AACxE,SAAO,sBAAK,gCAAL,WAAmB,OAAO,EAAE,YAAY,MAAM;AACnD,UAAM,iBAAiB,MAAM,GAAG,EAAE,YAAY,CAAC;AAE/C,UAAM,sBAAK,8BAAL;AAEN,WAAO;AAAA,EACT;AACF;AASM;AAAA,kBAAgB,eAAC,IAA8C;AACnE,SAAO,sBAAK,4CAAL,WAAyB,OAAO,EAAE,YAAY,MAAM;AACzD,UAAM,4BAA4B,MAAM,sBAAK,kDAAL;AACxC,UAAM,kBAAkB,mBAAK;AAE7B,QAAI;AACF,aAAO,MAAM,GAAG,EAAE,YAAY,CAAC;AAAA,IACjC,SAAS,GAAG;AAEV,YAAM,sBAAK,0DAAL,WAAgC;AACtC,yBAAK,WAAY;AAEjB,YAAM;AAAA,IACR;AAAA,EACF;AACF;AAOA;AAAA,mCAA8B,WAAG;AAC/B,MAAI,CAAC,mBAAK,2BAA0B,SAAS,GAAG;AAC9C,UAAM,IAAI,0HAAmD;AAAA,EAC/D;AACF;AAcM;AAAA,wBAAsB,eAAC,IAA8C;AACzE,SAAO,SAAS,mBAAK,4BAA2B,EAAE;AACpD;AAaM;AAAA,mBAAiB,eAAC,IAA8C;AACpE,wBAAK,kEAAL;AAEA,SAAO,SAAS,mBAAK,uBAAsB,EAAE;AAC/C;AAYF,eAAe,SACb,OACA,IACY;AACZ,QAAM,cAAc,MAAM,MAAM,QAAQ;AAExC,MAAI;AACF,WAAO,MAAM,GAAG,EAAE,YAAY,CAAC;AAAA,EACjC,UAAE;AACA,gBAAY;AAAA,EACd;AACF;AAEA,IAAO,4BAAQ","sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport { isValidPrivate, toBuffer, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize as ethNormalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthKeyring,\n  EthUserOperation,\n  EthUserOperationPatch,\n  KeyringExecutionContext,\n} from '@metamask/keyring-api';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type {\n  Eip1024EncryptedData,\n  Hex,\n  Json,\n  KeyringClass,\n} from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  isObject,\n  isStrictHexString,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { MutexInterface } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nimport { KeyringControllerError } from './constants';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  never,\n  never\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (\n    key: unknown,\n    object: Json,\n  ) => Promise<encryptorUtils.EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<encryptorUtils.DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n\nexport type KeyringSelector =\n  | {\n      type: string;\n      index?: number;\n    }\n  | {\n      address: Hex;\n    };\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<T> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<T>;\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring<Json>,\n): asserts keyring is EthKeyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(KeyringControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(KeyringControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: EthKeyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `string[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    accounts: accounts.map(normalize) as string[],\n  };\n}\n\n/**\n * Check if address is an ethereum address\n *\n * @param address - An address.\n * @returns Returns true if the address is an ethereum one, false otherwise.\n */\nfunction isEthAddress(address: string): boolean {\n  // We first check if it's a matching `Hex` string, so that is narrows down\n  // `address` as an `Hex` type, allowing us to use `isValidHexAddress`\n  return (\n    // NOTE: This function only checks for lowercased strings\n    isStrictHexString(address.toLowerCase()) &&\n    // This checks for lowercased addresses and checksum addresses too\n    isValidHexAddress(address as Hex)\n  );\n}\n\n/**\n * Normalize ethereum or non-EVM address.\n *\n * @param address - Ethereum or non-EVM address.\n * @returns The normalized address.\n */\nfunction normalize(address: string): string | undefined {\n  // Since the `KeyringController` is only dealing with address, we have\n  // no other way to get the associated account type with this address. So we\n  // are down to check the actual address format for now\n  // TODO: Find a better way to not have those runtime checks based on the\n  //       address value!\n  return isEthAddress(address) ? ethNormalize(address) : address;\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  readonly #controllerOperationMutex = new Mutex();\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  #keyringBuilders: { (): EthKeyring<Json>; type: string }[];\n\n  #keyrings: EthKeyring<Json>[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  #cacheEncryptionKey: boolean;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? defaultKeyringBuilders.concat(keyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccount(accountCount?: number): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const oldAccounts = await primaryKeyring.getAccounts();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n        // we return the account already existing at index `accountCount`\n        const existingAccount = oldAccounts[accountCount];\n\n        if (!existingAccount) {\n          throw new Error(`Can't find account at index ${accountCount}`);\n        }\n\n        return existingAccount;\n      }\n\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to the added account address\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    // READ THIS CAREFULLY:\n    // We still uses `Hex` here, since we are not using this method when creating\n    // and account using a \"Snap Keyring\". This function assume the `keyring` is\n    // ethereum compatible, but \"Snap Keyring\" might not be.\n    return this.#persistOrRollback(async () => {\n      const oldAccounts = await this.#getAccountsFromKeyrings();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n\n        const existingAccount = oldAccounts[accountCount];\n        assertIsStrictHexString(existingAccount);\n\n        return existingAccount;\n      }\n\n      await keyring.addAccounts(1);\n\n      const addedAccountAddress = (await this.#getAccountsFromKeyrings()).find(\n        (selectedAddress) => !oldAccounts.includes(selectedAddress),\n      );\n      assertIsStrictHexString(addedAccountAddress);\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccountWithoutUpdate(): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n    });\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    return this.#persistOrRollback(async () => {\n      const accounts = await this.#getAccountsFromKeyrings();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n    });\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    return this.#persistOrRollback(async () => this.#newKeyring(type, opts));\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyrings[0]);\n    return this.#keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts from every keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    return this.state.keyrings.reduce<string[]>(\n      (accounts, keyring) => accounts.concat(keyring.accounts),\n      [],\n    );\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    const address = ethNormalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(address, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    const address = normalize(account);\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(address);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyrings.filter((keyring) => keyring.type === type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @deprecated This method is being phased out in favor of `withKeyring`.\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#persistOrRollback(async () => true);\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to the imported account address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      let privateKey;\n      switch (strategy) {\n        case 'privateKey':\n          const [importedKey] = args;\n          if (!importedKey) {\n            throw new Error('Cannot import an empty key.');\n          }\n          const prefixed = add0x(importedKey);\n\n          let bufferedPrivateKey;\n          try {\n            bufferedPrivateKey = toBuffer(prefixed);\n          } catch {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          if (\n            !isValidPrivate(bufferedPrivateKey) ||\n            // ensures that the key is 64 bytes long\n            getBinarySize(prefixed) !== 64 + '0x'.length\n          ) {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          privateKey = remove0x(prefixed);\n          break;\n        case 'json':\n          let wallet;\n          const [input, password] = args;\n          try {\n            wallet = importers.fromEtherWallet(input, password);\n          } catch (e) {\n            wallet = wallet || (await Wallet.fromV3(input, password, true));\n          }\n          privateKey = bytesToHex(wallet.getPrivateKey());\n          break;\n        default:\n          throw new Error(`Unexpected import strategy: '${strategy}'`);\n      }\n      const newKeyring = (await this.#newKeyring(KeyringTypes.simple, [\n        privateKey,\n      ])) as EthKeyring<Json>;\n      const accounts = await newKeyring.getAccounts();\n      return accounts[0];\n    });\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving when the account is removed.\n   */\n  async removeAccount(address: string): Promise<void> {\n    await this.#persistOrRollback(async () => {\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n\n      // Not all the keyrings support this, so we have to check\n      if (!keyring.removeAccount) {\n        throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n      }\n\n      // The `removeAccount` method of snaps keyring is async. We have to update\n      // the interface of the other keyrings to be async as well.\n      // eslint-disable-next-line @typescript-eslint/await-thenable\n      // FIXME: We do cast to `Hex` to makes the type checker happy here, and\n      // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those\n      // type would need to be updated for a full non-EVM support.\n      await keyring.removeAccount(address as Hex);\n\n      const accounts = await keyring.getAccounts();\n      // Check if this was the last/only account\n      if (accounts.length === 0) {\n        await this.#removeEmptyKeyrings();\n      }\n    });\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving when the operation completes.\n   */\n  async setLocked(): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#unsubscribeFromQRKeyringsEvents();\n\n      this.#password = undefined;\n      await this.#clearKeyrings();\n\n      this.update((state) => {\n        state.isUnlocked = false;\n        state.keyrings = [];\n        delete state.encryptionKey;\n        delete state.encryptionSalt;\n      });\n\n      this.messagingSystem.publish(`${name}:lock`);\n    });\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = ethNormalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthBaseUserOperation> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(\n      address,\n      transactions,\n      executionContext,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthUserOperationPatch> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<string> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Changes the password used to encrypt the vault.\n   *\n   * @param password - The new password.\n   * @returns Promise resolving when the operation completes.\n   */\n  changePassword(password: string): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      if (!this.state.isUnlocked) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      assertIsValidPassword(password);\n\n      this.#password = password;\n      // We need to clear encryption key and salt from state\n      // to force the controller to re-encrypt the vault using\n      // the new password.\n      if (this.#cacheEncryptionKey) {\n        this.update((state) => {\n          delete state.encryptionKey;\n          delete state.encryptionSalt;\n        });\n      }\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(\n        undefined,\n        encryptionKey,\n        encryptionSalt,\n      );\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitPassword(password: string): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(password);\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @param options - Additional options.\n   * @param options.createIfMissing - Whether to create a new keyring if the selected one is missing.\n   * @param options.createWithData - Optional data to use when creating a new keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   * @deprecated This method overload is deprecated. Use `withKeyring` without options instead.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown },\n  ): Promise<CallbackResult>;\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n  ): Promise<CallbackResult>;\n\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown } = {\n      createIfMissing: false,\n    },\n  ): Promise<CallbackResult> {\n    return this.#persistOrRollback(async () => {\n      let keyring: SelectedKeyring | undefined;\n\n      if ('address' in selector) {\n        keyring = (await this.getKeyringForAccount(selector.address)) as\n          | SelectedKeyring\n          | undefined;\n      } else {\n        keyring = this.getKeyringsByType(selector.type)[selector.index || 0] as\n          | SelectedKeyring\n          | undefined;\n\n        if (!keyring && options.createIfMissing) {\n          keyring = (await this.#newKeyring(\n            selector.type,\n            options.createWithData,\n          )) as SelectedKeyring;\n        }\n      }\n\n      if (!keyring) {\n        throw new Error(KeyringControllerError.KeyringNotFound);\n      }\n\n      const result = await operation(keyring);\n\n      if (Object.is(result, keyring)) {\n        // Access to a keyring instance outside of controller safeguards\n        // should be discouraged, as it can lead to unexpected behavior.\n        // This error is thrown to prevent consumers using `withKeyring`\n        // as a way to get a reference to a keyring instance.\n        throw new Error(KeyringControllerError.UnsafeDirectKeyringAccess);\n      }\n\n      return result;\n    });\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return (\n      this.getQRKeyring() ||\n      (await this.#persistOrRollback(async () => this.#addQRKeyring()))\n    );\n  }\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n      keyring.deserialize(serialized);\n    });\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    return this.#persistOrRollback(async () => {\n      try {\n        const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n        let accounts;\n        switch (page) {\n          case -1:\n            accounts = await keyring.getPreviousPage();\n            break;\n          case 1:\n            accounts = await keyring.getNextPage();\n            break;\n          default:\n            accounts = await keyring.getFirstPage();\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return accounts.map((account: any) => {\n          return {\n            ...account,\n            balance: '0x0',\n          };\n        });\n      } catch (e) {\n        // TODO: Add test case for when keyring throws\n        /* istanbul ignore next */\n        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n      }\n    });\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n\n      keyring.setAccountToUnlock(index);\n      await keyring.addAccounts(1);\n    });\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    return keyring.type;\n  }\n\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring();\n\n      if (!keyring) {\n        return { removedAccounts: [], remainingAccounts: [] };\n      }\n\n      const allAccounts = (await this.#getAccountsFromKeyrings()) as string[];\n      keyring.forgetDevice();\n      const remainingAccounts =\n        (await this.#getAccountsFromKeyrings()) as string[];\n      const removedAccounts = allAccounts.filter(\n        (address: string) => !remainingAccounts.includes(address),\n      );\n      return { removedAccounts, remainingAccounts };\n    });\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring<Json>; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return (await this.#newKeyring(KeyringTypes.qr)) as unknown as QRKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n\n    this.update((state) => {\n      delete state.encryptionKey;\n      delete state.encryptionSalt;\n    });\n\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n  }\n\n  /**\n   * Get the updated array of each keyring's type and\n   * accounts list.\n   *\n   * @returns A promise resolving to the updated keyrings array.\n   */\n  async #getUpdatedKeyrings(): Promise<KeyringObject[]> {\n    return Promise.all(this.#keyrings.map(displayForKeyring));\n  }\n\n  /**\n   * Serialize the current array of keyring instances,\n   * including unsupported keyrings by default.\n   *\n   * @param options - Method options.\n   * @param options.includeUnsupported - Whether to include unsupported keyrings.\n   * @returns The serialized keyrings.\n   */\n  async #getSerializedKeyrings(\n    { includeUnsupported }: { includeUnsupported: boolean } = {\n      includeUnsupported: true,\n    },\n  ): Promise<SerializedKeyring[]> {\n    const serializedKeyrings = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    if (includeUnsupported) {\n      serializedKeyrings.push(...this.#unsupportedKeyrings);\n    }\n\n    return serializedKeyrings;\n  }\n\n  /**\n   * Restore a serialized keyrings array.\n   *\n   * @param serializedKeyrings - The serialized keyrings array.\n   */\n  async #restoreSerializedKeyrings(\n    serializedKeyrings: SerializedKeyring[],\n  ): Promise<void> {\n    await this.#clearKeyrings();\n\n    for (const serializedKeyring of serializedKeyrings) {\n      await this.#restoreKeyring(serializedKeyring);\n    }\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<EthKeyring<Json>[]> {\n    return this.#withVaultLock(async ({ releaseLock }) => {\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(KeyringControllerError.VaultError);\n      }\n\n      let vault;\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (password) {\n          const result = await this.#encryptor.decryptWithDetail(\n            password,\n            encryptedVault,\n          );\n          vault = result.vault;\n          this.#password = password;\n\n          updatedState.encryptionKey = result.exportedKeyString;\n          updatedState.encryptionSalt = result.salt;\n        } else {\n          const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n          if (encryptionSalt !== parsedEncryptedVault.salt) {\n            throw new Error(KeyringControllerError.ExpiredCredentials);\n          }\n\n          if (typeof encryptionKey !== 'string') {\n            throw new TypeError(KeyringControllerError.WrongPasswordType);\n          }\n\n          const key = await this.#encryptor.importKey(encryptionKey);\n          vault = await this.#encryptor.decryptWithKey(\n            key,\n            parsedEncryptedVault,\n          );\n\n          // This call is required on the first call because encryptionKey\n          // is not yet inside the memStore\n          updatedState.encryptionKey = encryptionKey;\n          // we can safely assume that encryptionSalt is defined here\n          // because we compare it with the salt from the vault\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          updatedState.encryptionSalt = encryptionSalt!;\n        }\n      } else {\n        if (typeof password !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        vault = await this.#encryptor.decrypt(password, encryptedVault);\n        this.#password = password;\n      }\n\n      if (!isSerializedKeyringsArray(vault)) {\n        throw new Error(KeyringControllerError.VaultDataError);\n      }\n\n      await this.#restoreSerializedKeyrings(vault);\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey || updatedState.encryptionSalt) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = updatedState.encryptionSalt;\n        }\n      });\n\n      if (\n        this.#password &&\n        (!this.#cacheEncryptionKey || !encryptionKey) &&\n        this.#encryptor.isVaultUpdated &&\n        !this.#encryptor.isVaultUpdated(encryptedVault)\n      ) {\n        // The lock needs to be released before persisting the keyrings\n        // to avoid deadlock\n        releaseLock();\n        // Re-encrypt the vault with safer method if one is available\n        await this.#updateVault();\n      }\n\n      return this.#keyrings;\n    });\n  }\n\n  /**\n   * Update the vault with the current keyrings.\n   *\n   * @returns A promise resolving to `true` if the operation is successful.\n   */\n  #updateVault(): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      const { encryptionKey, encryptionSalt } = this.state;\n\n      if (!this.#password && !encryptionKey) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      const serializedKeyrings = await this.#getSerializedKeyrings();\n\n      if (\n        !serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)\n      ) {\n        throw new Error(KeyringControllerError.NoHdKeyring);\n      }\n\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (encryptionKey) {\n          const key = await this.#encryptor.importKey(encryptionKey);\n          const vaultJSON = await this.#encryptor.encryptWithKey(\n            key,\n            serializedKeyrings,\n          );\n          vaultJSON.salt = encryptionSalt;\n          updatedState.vault = JSON.stringify(vaultJSON);\n        } else if (this.#password) {\n          const { vault: newVault, exportedKeyString } =\n            await this.#encryptor.encryptWithDetail(\n              this.#password,\n              serializedKeyrings,\n            );\n\n          updatedState.vault = newVault;\n          updatedState.encryptionKey = exportedKeyString;\n        }\n      } else {\n        assertIsValidPassword(this.#password);\n        updatedState.vault = await this.#encryptor.encrypt(\n          this.#password,\n          serializedKeyrings,\n        );\n      }\n\n      if (!updatedState.vault) {\n        throw new Error(KeyringControllerError.MissingVaultData);\n      }\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n      this.update((state) => {\n        state.vault = updatedState.vault;\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = JSON.parse(updatedState.vault as string).salt;\n        }\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Retrieves all the accounts from keyrings instances\n   * that are currently in memory.\n   *\n   * @returns A promise resolving to an array of accounts.\n   */\n  async #getAccountsFromKeyrings(): Promise<string[]> {\n    const keyrings = this.#keyrings;\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `string[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    return addresses.map(normalize) as string[];\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = (await this.#newKeyring(type, opts)) as EthKeyring<Json>;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #newKeyring(type: string, data?: unknown): Promise<EthKeyring<Json>> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    // @ts-expect-error Enforce data type after updating clients\n    await keyring.deserialize(data);\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    if (type === KeyringTypes.hd && (!isObject(data) || !data.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    await this.#checkForDuplicate(type, await keyring.getAccounts());\n\n    if (type === KeyringTypes.qr) {\n      // In case of a QR keyring type, we need to subscribe\n      // to its events after creating it\n      this.#subscribeToQRKeyringEvents(keyring as unknown as QRKeyring);\n    }\n\n    this.#keyrings.push(keyring);\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    this.#assertControllerMutexIsLocked();\n    for (const keyring of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<EthKeyring<Json> | undefined> {\n    this.#assertControllerMutexIsLocked();\n\n    try {\n      const { type, data } = serialized;\n      return await this.#newKeyring(type, data);\n    } catch (_) {\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring<Json>) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n    const validKeyrings: EthKeyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async (keyring: EthKeyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async #checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.#getAccountsFromKeyrings();\n\n    switch (type) {\n      case KeyringTypes.simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.#assertControllerMutexIsLocked();\n\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and save the keyrings to state after it, or rollback to their\n   * previous state in case of error.\n   *\n   * @param fn - The function to execute.\n   * @returns The result of the function.\n   */\n  async #persistOrRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withRollback(async ({ releaseLock }) => {\n      const callbackResult = await fn({ releaseLock });\n      // State is committed only if the operation is successful\n      await this.#updateVault();\n\n      return callbackResult;\n    });\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and rollback keyrings and password states in case of error.\n   *\n   * @param fn - The function to execute atomically.\n   * @returns The result of the function.\n   */\n  async #withRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withControllerLock(async ({ releaseLock }) => {\n      const currentSerializedKeyrings = await this.#getSerializedKeyrings();\n      const currentPassword = this.#password;\n\n      try {\n        return await fn({ releaseLock });\n      } catch (e) {\n        // Keyrings and password are restored to their previous state\n        await this.#restoreSerializedKeyrings(currentSerializedKeyrings);\n        this.#password = currentPassword;\n\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Assert that the controller mutex is locked.\n   *\n   * @throws If the controller mutex is not locked.\n   */\n  #assertControllerMutexIsLocked() {\n    if (!this.#controllerOperationMutex.isLocked()) {\n      throw new Error(KeyringControllerError.ControllerLockRequired);\n    }\n  }\n\n  /**\n   * Lock the controller mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This wrapper ensures that each mutable operation that interacts with the\n   * controller and that changes its state is executed in a mutually exclusive way,\n   * preventing unsafe concurrent access that could lead to unpredictable behavior.\n   *\n   * @param fn - The function to execute while the controller mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withControllerLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return withLock(this.#controllerOperationMutex, fn);\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param fn - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    this.#assertControllerMutexIsLocked();\n\n    return withLock(this.#vaultOperationMutex, fn);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param fn - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<T>(\n  mutex: Mutex,\n  fn: MutuallyExclusiveCallback<T>,\n): Promise<T> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await fn({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n\nexport default KeyringController;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-STFS4REY.mjs b/dist/chunk-STFS4REY.mjs
deleted file mode 100644
index 58e38b7016380f616d2bed694a35a81f639d304b..0000000000000000000000000000000000000000
--- a/dist/chunk-STFS4REY.mjs
+++ /dev/null
@@ -1,1500 +0,0 @@
-import {
-  __privateAdd,
-  __privateGet,
-  __privateMethod,
-  __privateSet
-} from "./chunk-F64I344Z.mjs";
-
-// src/KeyringController.ts
-import { isValidPrivate, toBuffer, getBinarySize } from "@ethereumjs/util";
-import { BaseController } from "@metamask/base-controller";
-import * as encryptorUtils from "@metamask/browser-passworder";
-import HDKeyring from "@metamask/eth-hd-keyring";
-import { normalize as ethNormalize } from "@metamask/eth-sig-util";
-import SimpleKeyring from "@metamask/eth-simple-keyring";
-import {
-  add0x,
-  assertIsStrictHexString,
-  bytesToHex,
-  hasProperty,
-  isObject,
-  isStrictHexString,
-  isValidHexAddress,
-  isValidJson,
-  remove0x
-} from "@metamask/utils";
-import { Mutex } from "async-mutex";
-import Wallet, { thirdparty as importers } from "ethereumjs-wallet";
-var name = "KeyringController";
-var KeyringTypes = /* @__PURE__ */ ((KeyringTypes2) => {
-  KeyringTypes2["simple"] = "Simple Key Pair";
-  KeyringTypes2["hd"] = "HD Key Tree";
-  KeyringTypes2["qr"] = "QR Hardware Wallet Device";
-  KeyringTypes2["trezor"] = "Trezor Hardware";
-  KeyringTypes2["ledger"] = "Ledger Hardware";
-  KeyringTypes2["lattice"] = "Lattice Hardware";
-  KeyringTypes2["snap"] = "Snap Keyring";
-  return KeyringTypes2;
-})(KeyringTypes || {});
-var isCustodyKeyring = (keyringType) => {
-  return keyringType.startsWith("Custody");
-};
-var AccountImportStrategy = /* @__PURE__ */ ((AccountImportStrategy2) => {
-  AccountImportStrategy2["privateKey"] = "privateKey";
-  AccountImportStrategy2["json"] = "json";
-  return AccountImportStrategy2;
-})(AccountImportStrategy || {});
-var SignTypedDataVersion = /* @__PURE__ */ ((SignTypedDataVersion2) => {
-  SignTypedDataVersion2["V1"] = "V1";
-  SignTypedDataVersion2["V3"] = "V3";
-  SignTypedDataVersion2["V4"] = "V4";
-  return SignTypedDataVersion2;
-})(SignTypedDataVersion || {});
-function keyringBuilderFactory(KeyringConstructor) {
-  const builder = () => new KeyringConstructor();
-  builder.type = KeyringConstructor.type;
-  return builder;
-}
-var defaultKeyringBuilders = [
-  keyringBuilderFactory(SimpleKeyring),
-  keyringBuilderFactory(HDKeyring)
-];
-var getDefaultKeyringState = () => {
-  return {
-    isUnlocked: false,
-    keyrings: []
-  };
-};
-function assertHasUint8ArrayMnemonic(keyring) {
-  if (!(hasProperty(keyring, "mnemonic") && keyring.mnemonic instanceof Uint8Array)) {
-    throw new Error("Can't get mnemonic bytes from keyring");
-  }
-}
-function assertIsExportableKeyEncryptor(encryptor) {
-  if (!("importKey" in encryptor && typeof encryptor.importKey === "function" && "decryptWithKey" in encryptor && typeof encryptor.decryptWithKey === "function" && "encryptWithKey" in encryptor && typeof encryptor.encryptWithKey === "function")) {
-    throw new Error("KeyringController - The encryptor does not support encryption key export." /* UnsupportedEncryptionKeyExport */);
-  }
-}
-function assertIsValidPassword(password) {
-  if (typeof password !== "string") {
-    throw new Error("KeyringController - Password must be of type string." /* WrongPasswordType */);
-  }
-  if (!password || !password.length) {
-    throw new Error("KeyringController - Password cannot be empty." /* InvalidEmptyPassword */);
-  }
-}
-function isSerializedKeyringsArray(array) {
-  return typeof array === "object" && Array.isArray(array) && array.every((value) => value.type && isValidJson(value.data));
-}
-async function displayForKeyring(keyring) {
-  const accounts = await keyring.getAccounts();
-  return {
-    type: keyring.type,
-    // Cast to `string[]` here is safe here because `accounts` has no nullish
-    // values, and `normalize` returns `string` unless given a nullish value
-    accounts: accounts.map(normalize)
-  };
-}
-function isEthAddress(address) {
-  return (
-    // NOTE: This function only checks for lowercased strings
-    isStrictHexString(address.toLowerCase()) && // This checks for lowercased addresses and checksum addresses too
-    isValidHexAddress(address)
-  );
-}
-function normalize(address) {
-  return isEthAddress(address) ? ethNormalize(address) : address;
-}
-var _controllerOperationMutex, _vaultOperationMutex, _keyringBuilders, _keyrings, _unsupportedKeyrings, _password, _encryptor, _cacheEncryptionKey, _qrKeyringStateListener, _registerMessageHandlers, registerMessageHandlers_fn, _getKeyringBuilderForType, getKeyringBuilderForType_fn, _addQRKeyring, addQRKeyring_fn, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn, _getUpdatedKeyrings, getUpdatedKeyrings_fn, _getSerializedKeyrings, getSerializedKeyrings_fn, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn, _unlockKeyrings, unlockKeyrings_fn, _updateVault, updateVault_fn, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn, _newKeyring, newKeyring_fn, _clearKeyrings, clearKeyrings_fn, _restoreKeyring, restoreKeyring_fn, _destroyKeyring, destroyKeyring_fn, _removeEmptyKeyrings, removeEmptyKeyrings_fn, _checkForDuplicate, checkForDuplicate_fn, _setUnlocked, setUnlocked_fn, _persistOrRollback, persistOrRollback_fn, _withRollback, withRollback_fn, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn, _withControllerLock, withControllerLock_fn, _withVaultLock, withVaultLock_fn;
-var KeyringController = class extends BaseController {
-  /**
-   * Creates a KeyringController instance.
-   *
-   * @param options - Initial options used to configure this controller
-   * @param options.encryptor - An optional object for defining encryption schemes.
-   * @param options.keyringBuilders - Set a new name for account.
-   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.
-   * @param options.messenger - A restricted controller messenger.
-   * @param options.state - Initial state to set on this controller.
-   */
-  constructor(options) {
-    const {
-      encryptor = encryptorUtils,
-      keyringBuilders,
-      messenger,
-      state
-    } = options;
-    super({
-      name,
-      metadata: {
-        vault: { persist: true, anonymous: false },
-        isUnlocked: { persist: false, anonymous: true },
-        keyrings: { persist: false, anonymous: false },
-        encryptionKey: { persist: false, anonymous: false },
-        encryptionSalt: { persist: false, anonymous: false }
-      },
-      messenger,
-      state: {
-        ...getDefaultKeyringState(),
-        ...state
-      }
-    });
-    /**
-     * Constructor helper for registering this controller's messaging system
-     * actions.
-     */
-    __privateAdd(this, _registerMessageHandlers);
-    /**
-     * Get the keyring builder for the given `type`.
-     *
-     * @param type - The type of keyring to get the builder for.
-     * @returns The keyring builder, or undefined if none exists.
-     */
-    __privateAdd(this, _getKeyringBuilderForType);
-    /**
-     * Add qr hardware keyring.
-     *
-     * @returns The added keyring
-     * @throws If a QRKeyring builder is not provided
-     * when initializing the controller
-     */
-    __privateAdd(this, _addQRKeyring);
-    /**
-     * Subscribe to a QRKeyring state change events and
-     * forward them through the messaging system.
-     *
-     * @param qrKeyring - The QRKeyring instance to subscribe to
-     */
-    __privateAdd(this, _subscribeToQRKeyringEvents);
-    __privateAdd(this, _unsubscribeFromQRKeyringsEvents);
-    /**
-     * Create new vault with an initial keyring
-     *
-     * Destroys any old encrypted storage,
-     * creates a new encrypted store with the given password,
-     * creates a new wallet with 1 account.
-     *
-     * @fires KeyringController:unlock
-     * @param password - The password to encrypt the vault with.
-     * @param keyring - A object containing the params to instantiate a new keyring.
-     * @param keyring.type - The keyring type.
-     * @param keyring.opts - Optional parameters required to instantiate the keyring.
-     * @returns A promise that resolves to the state.
-     */
-    __privateAdd(this, _createNewVaultWithKeyring);
-    /**
-     * Get the updated array of each keyring's type and
-     * accounts list.
-     *
-     * @returns A promise resolving to the updated keyrings array.
-     */
-    __privateAdd(this, _getUpdatedKeyrings);
-    /**
-     * Serialize the current array of keyring instances,
-     * including unsupported keyrings by default.
-     *
-     * @param options - Method options.
-     * @param options.includeUnsupported - Whether to include unsupported keyrings.
-     * @returns The serialized keyrings.
-     */
-    __privateAdd(this, _getSerializedKeyrings);
-    /**
-     * Restore a serialized keyrings array.
-     *
-     * @param serializedKeyrings - The serialized keyrings array.
-     */
-    __privateAdd(this, _restoreSerializedKeyrings);
-    /**
-     * Unlock Keyrings, decrypting the vault and deserializing all
-     * keyrings contained in it, using a password or an encryption key with salt.
-     *
-     * @param password - The keyring controller password.
-     * @param encryptionKey - An exported key string to unlock keyrings with.
-     * @param encryptionSalt - The salt used to encrypt the vault.
-     * @returns A promise resolving to the deserialized keyrings array.
-     */
-    __privateAdd(this, _unlockKeyrings);
-    /**
-     * Update the vault with the current keyrings.
-     *
-     * @returns A promise resolving to `true` if the operation is successful.
-     */
-    __privateAdd(this, _updateVault);
-    /**
-     * Retrieves all the accounts from keyrings instances
-     * that are currently in memory.
-     *
-     * @returns A promise resolving to an array of accounts.
-     */
-    __privateAdd(this, _getAccountsFromKeyrings);
-    /**
-     * Create a new keyring, ensuring that the first account is
-     * also created.
-     *
-     * @param type - Keyring type to instantiate.
-     * @param opts - Optional parameters required to instantiate the keyring.
-     * @returns A promise that resolves if the operation is successful.
-     */
-    __privateAdd(this, _createKeyringWithFirstAccount);
-    /**
-     * Instantiate, initialize and return a new keyring of the given `type`,
-     * using the given `opts`. The keyring is built using the keyring builder
-     * registered for the given `type`.
-     *
-     *
-     * @param type - The type of keyring to add.
-     * @param data - The data to restore a previously serialized keyring.
-     * @returns The new keyring.
-     * @throws If the keyring includes duplicated accounts.
-     */
-    __privateAdd(this, _newKeyring);
-    /**
-     * Remove all managed keyrings, destroying all their
-     * instances in memory.
-     */
-    __privateAdd(this, _clearKeyrings);
-    /**
-     * Restore a Keyring from a provided serialized payload.
-     * On success, returns the resulting keyring instance.
-     *
-     * @param serialized - The serialized keyring.
-     * @returns The deserialized keyring or undefined if the keyring type is unsupported.
-     */
-    __privateAdd(this, _restoreKeyring);
-    /**
-     * Destroy Keyring
-     *
-     * Some keyrings support a method called `destroy`, that destroys the
-     * keyring along with removing all its event listeners and, in some cases,
-     * clears the keyring bridge iframe from the DOM.
-     *
-     * @param keyring - The keyring to destroy.
-     */
-    __privateAdd(this, _destroyKeyring);
-    /**
-     * Remove empty keyrings.
-     *
-     * Loops through the keyrings and removes the ones with empty accounts
-     * (usually after removing the last / only account) from a keyring.
-     */
-    __privateAdd(this, _removeEmptyKeyrings);
-    /**
-     * Checks for duplicate keypairs, using the the first account in the given
-     * array. Rejects if a duplicate is found.
-     *
-     * Only supports 'Simple Key Pair'.
-     *
-     * @param type - The key pair type to check for.
-     * @param newAccountArray - Array of new accounts.
-     * @returns The account, if no duplicate is found.
-     */
-    __privateAdd(this, _checkForDuplicate);
-    /**
-     * Set the `isUnlocked` to true and notify listeners
-     * through the messenger.
-     *
-     * @fires KeyringController:unlock
-     */
-    __privateAdd(this, _setUnlocked);
-    /**
-     * Execute the given function after acquiring the controller lock
-     * and save the keyrings to state after it, or rollback to their
-     * previous state in case of error.
-     *
-     * @param fn - The function to execute.
-     * @returns The result of the function.
-     */
-    __privateAdd(this, _persistOrRollback);
-    /**
-     * Execute the given function after acquiring the controller lock
-     * and rollback keyrings and password states in case of error.
-     *
-     * @param fn - The function to execute atomically.
-     * @returns The result of the function.
-     */
-    __privateAdd(this, _withRollback);
-    /**
-     * Assert that the controller mutex is locked.
-     *
-     * @throws If the controller mutex is not locked.
-     */
-    __privateAdd(this, _assertControllerMutexIsLocked);
-    /**
-     * Lock the controller mutex before executing the given function,
-     * and release it after the function is resolved or after an
-     * error is thrown.
-     *
-     * This wrapper ensures that each mutable operation that interacts with the
-     * controller and that changes its state is executed in a mutually exclusive way,
-     * preventing unsafe concurrent access that could lead to unpredictable behavior.
-     *
-     * @param fn - The function to execute while the controller mutex is locked.
-     * @returns The result of the function.
-     */
-    __privateAdd(this, _withControllerLock);
-    /**
-     * Lock the vault mutex before executing the given function,
-     * and release it after the function is resolved or after an
-     * error is thrown.
-     *
-     * This ensures that each operation that interacts with the vault
-     * is executed in a mutually exclusive way.
-     *
-     * @param fn - The function to execute while the vault mutex is locked.
-     * @returns The result of the function.
-     */
-    __privateAdd(this, _withVaultLock);
-    __privateAdd(this, _controllerOperationMutex, new Mutex());
-    __privateAdd(this, _vaultOperationMutex, new Mutex());
-    __privateAdd(this, _keyringBuilders, void 0);
-    __privateAdd(this, _keyrings, void 0);
-    __privateAdd(this, _unsupportedKeyrings, void 0);
-    __privateAdd(this, _password, void 0);
-    __privateAdd(this, _encryptor, void 0);
-    __privateAdd(this, _cacheEncryptionKey, void 0);
-    __privateAdd(this, _qrKeyringStateListener, void 0);
-    __privateSet(this, _keyringBuilders, keyringBuilders ? defaultKeyringBuilders.concat(keyringBuilders) : defaultKeyringBuilders);
-    __privateSet(this, _encryptor, encryptor);
-    __privateSet(this, _keyrings, []);
-    __privateSet(this, _unsupportedKeyrings, []);
-    __privateSet(this, _cacheEncryptionKey, Boolean(options.cacheEncryptionKey));
-    if (__privateGet(this, _cacheEncryptionKey)) {
-      assertIsExportableKeyEncryptor(encryptor);
-    }
-    __privateMethod(this, _registerMessageHandlers, registerMessageHandlers_fn).call(this);
-  }
-  /**
-   * Adds a new account to the default (first) HD seed phrase keyring.
-   *
-   * @param accountCount - Number of accounts before adding a new one, used to
-   * make the method idempotent.
-   * @returns Promise resolving to the added account address.
-   */
-  async addNewAccount(accountCount) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
-      if (!primaryKeyring) {
-        throw new Error("No HD keyring found");
-      }
-      const oldAccounts = await primaryKeyring.getAccounts();
-      if (accountCount && oldAccounts.length !== accountCount) {
-        if (accountCount > oldAccounts.length) {
-          throw new Error("Account out of sequence");
-        }
-        const existingAccount = oldAccounts[accountCount];
-        if (!existingAccount) {
-          throw new Error(`Can't find account at index ${accountCount}`);
-        }
-        return existingAccount;
-      }
-      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
-      await this.verifySeedPhrase();
-      return addedAccountAddress;
-    });
-  }
-  /**
-   * Adds a new account to the specified keyring.
-   *
-   * @param keyring - Keyring to add the account to.
-   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.
-   * @returns Promise resolving to the added account address
-   */
-  async addNewAccountForKeyring(keyring, accountCount) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const oldAccounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      if (accountCount && oldAccounts.length !== accountCount) {
-        if (accountCount > oldAccounts.length) {
-          throw new Error("Account out of sequence");
-        }
-        const existingAccount = oldAccounts[accountCount];
-        assertIsStrictHexString(existingAccount);
-        return existingAccount;
-      }
-      await keyring.addAccounts(1);
-      const addedAccountAddress = (await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this)).find(
-        (selectedAddress) => !oldAccounts.includes(selectedAddress)
-      );
-      assertIsStrictHexString(addedAccountAddress);
-      return addedAccountAddress;
-    });
-  }
-  /**
-   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.
-   *
-   * @returns Promise resolving to the added account address.
-   */
-  async addNewAccountWithoutUpdate() {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const primaryKeyring = this.getKeyringsByType("HD Key Tree")[0];
-      if (!primaryKeyring) {
-        throw new Error("No HD keyring found");
-      }
-      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);
-      await this.verifySeedPhrase();
-      return addedAccountAddress;
-    });
-  }
-  /**
-   * Effectively the same as creating a new keychain then populating it
-   * using the given seed phrase.
-   *
-   * @param password - Password to unlock keychain.
-   * @param seed - A BIP39-compliant seed phrase as Uint8Array,
-   * either as a string or an array of UTF-8 bytes that represent the string.
-   * @returns Promise resolving when the operation ends successfully.
-   */
-  async createNewVaultAndRestore(password, seed) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      assertIsValidPassword(password);
-      await __privateMethod(this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
-        type: "HD Key Tree" /* hd */,
-        opts: {
-          mnemonic: seed,
-          numberOfAccounts: 1
-        }
-      });
-    });
-  }
-  /**
-   * Create a new primary keychain and wipe any previous keychains.
-   *
-   * @param password - Password to unlock the new vault.
-   * @returns Promise resolving when the operation ends successfully.
-   */
-  async createNewVaultAndKeychain(password) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const accounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      if (!accounts.length) {
-        await __privateMethod(this, _createNewVaultWithKeyring, createNewVaultWithKeyring_fn).call(this, password, {
-          type: "HD Key Tree" /* hd */
-        });
-      }
-    });
-  }
-  /**
-   * Adds a new keyring of the given `type`.
-   *
-   * @param type - Keyring type name.
-   * @param opts - Keyring options.
-   * @throws If a builder for the given `type` does not exist.
-   * @returns Promise resolving to the added keyring.
-   */
-  async addNewKeyring(type, opts) {
-    if (type === "QR Hardware Wallet Device" /* qr */) {
-      return this.getOrAddQRKeyring();
-    }
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => __privateMethod(this, _newKeyring, newKeyring_fn).call(this, type, opts));
-  }
-  /**
-   * Method to verify a given password validity. Throws an
-   * error if the password is invalid.
-   *
-   * @param password - Password of the keyring.
-   */
-  async verifyPassword(password) {
-    if (!this.state.vault) {
-      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
-    }
-    await __privateGet(this, _encryptor).decrypt(password, this.state.vault);
-  }
-  /**
-   * Returns the status of the vault.
-   *
-   * @returns Boolean returning true if the vault is unlocked.
-   */
-  isUnlocked() {
-    return this.state.isUnlocked;
-  }
-  /**
-   * Gets the seed phrase of the HD keyring.
-   *
-   * @param password - Password of the keyring.
-   * @returns Promise resolving to the seed phrase.
-   */
-  async exportSeedPhrase(password) {
-    await this.verifyPassword(password);
-    assertHasUint8ArrayMnemonic(__privateGet(this, _keyrings)[0]);
-    return __privateGet(this, _keyrings)[0].mnemonic;
-  }
-  /**
-   * Gets the private key from the keyring controlling an address.
-   *
-   * @param password - Password of the keyring.
-   * @param address - Address to export.
-   * @returns Promise resolving to the private key for an address.
-   */
-  async exportAccount(password, address) {
-    await this.verifyPassword(password);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.exportAccount) {
-      throw new Error("`KeyringController - The keyring for the current address does not support the method exportAccount" /* UnsupportedExportAccount */);
-    }
-    return await keyring.exportAccount(normalize(address));
-  }
-  /**
-   * Returns the public addresses of all accounts from every keyring.
-   *
-   * @returns A promise resolving to an array of addresses.
-   */
-  async getAccounts() {
-    return this.state.keyrings.reduce(
-      (accounts, keyring) => accounts.concat(keyring.accounts),
-      []
-    );
-  }
-  /**
-   * Get encryption public key.
-   *
-   * @param account - An account address.
-   * @param opts - Additional encryption options.
-   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method
-   * @returns Promise resolving to encyption public key of the `account` if one exists.
-   */
-  async getEncryptionPublicKey(account, opts) {
-    const address = ethNormalize(account);
-    const keyring = await this.getKeyringForAccount(
-      account
-    );
-    if (!keyring.getEncryptionPublicKey) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method getEncryptionPublicKey." /* UnsupportedGetEncryptionPublicKey */);
-    }
-    return await keyring.getEncryptionPublicKey(address, opts);
-  }
-  /**
-   * Attempts to decrypt the provided message parameters.
-   *
-   * @param messageParams - The decryption message parameters.
-   * @param messageParams.from - The address of the account you want to use to decrypt the message.
-   * @param messageParams.data - The encrypted data that you want to decrypt.
-   * @returns The raw decryption result.
-   */
-  async decryptMessage(messageParams) {
-    const address = ethNormalize(messageParams.from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.decryptMessage) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method decryptMessage." /* UnsupportedDecryptMessage */);
-    }
-    return keyring.decryptMessage(address, messageParams.data);
-  }
-  /**
-   * Returns the currently initialized keyring that manages
-   * the specified `address` if one exists.
-   *
-   * @deprecated Use of this method is discouraged as actions executed directly on
-   * keyrings are not being reflected in the KeyringController state and not
-   * persisted in the vault. Use `withKeyring` instead.
-   * @param account - An account address.
-   * @returns Promise resolving to keyring of the `account` if one exists.
-   */
-  async getKeyringForAccount(account) {
-    const address = normalize(account);
-    const candidates = await Promise.all(
-      __privateGet(this, _keyrings).map(async (keyring) => {
-        return Promise.all([keyring, keyring.getAccounts()]);
-      })
-    );
-    const winners = candidates.filter((candidate) => {
-      const accounts = candidate[1].map(normalize);
-      return accounts.includes(address);
-    });
-    if (winners.length && winners[0]?.length) {
-      return winners[0][0];
-    }
-    let errorInfo = "";
-    if (!candidates.length) {
-      errorInfo = "There are no keyrings";
-    } else if (!winners.length) {
-      errorInfo = "There are keyrings, but none match the address";
-    }
-    throw new Error(
-      `${"KeyringController - No keyring found" /* NoKeyring */}. Error info: ${errorInfo}`
-    );
-  }
-  /**
-   * Returns all keyrings of the given type.
-   *
-   * @deprecated Use of this method is discouraged as actions executed directly on
-   * keyrings are not being reflected in the KeyringController state and not
-   * persisted in the vault. Use `withKeyring` instead.
-   * @param type - Keyring type name.
-   * @returns An array of keyrings of the given type.
-   */
-  getKeyringsByType(type) {
-    return __privateGet(this, _keyrings).filter((keyring) => keyring.type === type);
-  }
-  /**
-   * Persist all serialized keyrings in the vault.
-   *
-   * @deprecated This method is being phased out in favor of `withKeyring`.
-   * @returns Promise resolving with `true` value when the
-   * operation completes.
-   */
-  async persistAllKeyrings() {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => true);
-  }
-  /**
-   * Imports an account with the specified import strategy.
-   *
-   * @param strategy - Import strategy name.
-   * @param args - Array of arguments to pass to the underlying stategy.
-   * @throws Will throw when passed an unrecognized strategy.
-   * @returns Promise resolving to the imported account address.
-   */
-  async importAccountWithStrategy(strategy, args) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      let privateKey;
-      switch (strategy) {
-        case "privateKey":
-          const [importedKey] = args;
-          if (!importedKey) {
-            throw new Error("Cannot import an empty key.");
-          }
-          const prefixed = add0x(importedKey);
-          let bufferedPrivateKey;
-          try {
-            bufferedPrivateKey = toBuffer(prefixed);
-          } catch {
-            throw new Error("Cannot import invalid private key.");
-          }
-          if (!isValidPrivate(bufferedPrivateKey) || // ensures that the key is 64 bytes long
-          getBinarySize(prefixed) !== 64 + "0x".length) {
-            throw new Error("Cannot import invalid private key.");
-          }
-          privateKey = remove0x(prefixed);
-          break;
-        case "json":
-          let wallet;
-          const [input, password] = args;
-          try {
-            wallet = importers.fromEtherWallet(input, password);
-          } catch (e) {
-            wallet = wallet || await Wallet.fromV3(input, password, true);
-          }
-          privateKey = bytesToHex(wallet.getPrivateKey());
-          break;
-        default:
-          throw new Error(`Unexpected import strategy: '${strategy}'`);
-      }
-      const newKeyring = await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, "Simple Key Pair" /* simple */, [
-        privateKey
-      ]);
-      const accounts = await newKeyring.getAccounts();
-      return accounts[0];
-    });
-  }
-  /**
-   * Removes an account from keyring state.
-   *
-   * @param address - Address of the account to remove.
-   * @fires KeyringController:accountRemoved
-   * @returns Promise resolving when the account is removed.
-   */
-  async removeAccount(address) {
-    await __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = await this.getKeyringForAccount(
-        address
-      );
-      if (!keyring.removeAccount) {
-        throw new Error("`KeyringController - The keyring for the current address does not support the method removeAccount" /* UnsupportedRemoveAccount */);
-      }
-      await keyring.removeAccount(address);
-      const accounts = await keyring.getAccounts();
-      if (accounts.length === 0) {
-        await __privateMethod(this, _removeEmptyKeyrings, removeEmptyKeyrings_fn).call(this);
-      }
-    });
-    this.messagingSystem.publish(`${name}:accountRemoved`, address);
-  }
-  /**
-   * Deallocates all secrets and locks the wallet.
-   *
-   * @returns Promise resolving when the operation completes.
-   */
-  async setLocked() {
-    return __privateMethod(this, _withRollback, withRollback_fn).call(this, async () => {
-      __privateMethod(this, _unsubscribeFromQRKeyringsEvents, unsubscribeFromQRKeyringsEvents_fn).call(this);
-      __privateSet(this, _password, void 0);
-      await __privateMethod(this, _clearKeyrings, clearKeyrings_fn).call(this);
-      this.update((state) => {
-        state.isUnlocked = false;
-        state.keyrings = [];
-      });
-      this.messagingSystem.publish(`${name}:lock`);
-    });
-  }
-  /**
-   * Signs message by calling down into a specific keyring.
-   *
-   * @param messageParams - PersonalMessageParams object to sign.
-   * @returns Promise resolving to a signed message string.
-   */
-  async signMessage(messageParams) {
-    if (!messageParams.data) {
-      throw new Error("Can't sign an empty message");
-    }
-    const address = ethNormalize(messageParams.from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signMessage) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signMessage." /* UnsupportedSignMessage */);
-    }
-    return await keyring.signMessage(address, messageParams.data);
-  }
-  /**
-   * Signs personal message by calling down into a specific keyring.
-   *
-   * @param messageParams - PersonalMessageParams object to sign.
-   * @returns Promise resolving to a signed message string.
-   */
-  async signPersonalMessage(messageParams) {
-    const address = ethNormalize(messageParams.from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signPersonalMessage) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signPersonalMessage." /* UnsupportedSignPersonalMessage */);
-    }
-    const normalizedData = normalize(messageParams.data);
-    return await keyring.signPersonalMessage(address, normalizedData);
-  }
-  /**
-   * Signs typed message by calling down into a specific keyring.
-   *
-   * @param messageParams - TypedMessageParams object to sign.
-   * @param version - Compatibility version EIP712.
-   * @throws Will throw when passed an unrecognized version.
-   * @returns Promise resolving to a signed message string or an error if any.
-   */
-  async signTypedMessage(messageParams, version) {
-    try {
-      if (![
-        "V1" /* V1 */,
-        "V3" /* V3 */,
-        "V4" /* V4 */
-      ].includes(version)) {
-        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
-      }
-      const address = ethNormalize(messageParams.from);
-      const keyring = await this.getKeyringForAccount(
-        address
-      );
-      if (!keyring.signTypedData) {
-        throw new Error("KeyringController - The keyring for the current address does not support the method signTypedMessage." /* UnsupportedSignTypedMessage */);
-      }
-      return await keyring.signTypedData(
-        address,
-        version !== "V1" /* V1 */ && typeof messageParams.data === "string" ? JSON.parse(messageParams.data) : messageParams.data,
-        { version }
-      );
-    } catch (error) {
-      throw new Error(`Keyring Controller signTypedMessage: ${error}`);
-    }
-  }
-  /**
-   * Signs a transaction by calling down into a specific keyring.
-   *
-   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
-   * @param from - Address to sign from, should be in keychain.
-   * @param opts - An optional options object.
-   * @returns Promise resolving to a signed transaction string.
-   */
-  async signTransaction(transaction, from, opts) {
-    const address = ethNormalize(from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signTransaction) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signTransaction." /* UnsupportedSignTransaction */);
-    }
-    return await keyring.signTransaction(address, transaction, opts);
-  }
-  /**
-   * Convert a base transaction to a base UserOperation.
-   *
-   * @param from - Address of the sender.
-   * @param transactions - Base transactions to include in the UserOperation.
-   * @param executionContext - The execution context to use for the UserOperation.
-   * @returns A pseudo-UserOperation that can be used to construct a real.
-   */
-  async prepareUserOperation(from, transactions, executionContext) {
-    const address = ethNormalize(from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.prepareUserOperation) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method prepareUserOperation." /* UnsupportedPrepareUserOperation */);
-    }
-    return await keyring.prepareUserOperation(
-      address,
-      transactions,
-      executionContext
-    );
-  }
-  /**
-   * Patches properties of a UserOperation. Currently, only the
-   * `paymasterAndData` can be patched.
-   *
-   * @param from - Address of the sender.
-   * @param userOp - UserOperation to patch.
-   * @param executionContext - The execution context to use for the UserOperation.
-   * @returns A patch to apply to the UserOperation.
-   */
-  async patchUserOperation(from, userOp, executionContext) {
-    const address = ethNormalize(from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.patchUserOperation) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method patchUserOperation." /* UnsupportedPatchUserOperation */);
-    }
-    return await keyring.patchUserOperation(address, userOp, executionContext);
-  }
-  /**
-   * Signs an UserOperation.
-   *
-   * @param from - Address of the sender.
-   * @param userOp - UserOperation to sign.
-   * @param executionContext - The execution context to use for the UserOperation.
-   * @returns The signature of the UserOperation.
-   */
-  async signUserOperation(from, userOp, executionContext) {
-    const address = ethNormalize(from);
-    const keyring = await this.getKeyringForAccount(
-      address
-    );
-    if (!keyring.signUserOperation) {
-      throw new Error("KeyringController - The keyring for the current address does not support the method signUserOperation." /* UnsupportedSignUserOperation */);
-    }
-    return await keyring.signUserOperation(address, userOp, executionContext);
-  }
-  /**
-   * Changes the password used to encrypt the vault.
-   *
-   * @param password - The new password.
-   * @returns Promise resolving when the operation completes.
-   */
-  changePassword(password) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      if (!this.state.isUnlocked) {
-        throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
-      }
-      assertIsValidPassword(password);
-      __privateSet(this, _password, password);
-      if (__privateGet(this, _cacheEncryptionKey)) {
-        this.update((state) => {
-          delete state.encryptionKey;
-          delete state.encryptionSalt;
-        });
-      }
-    });
-  }
-  /**
-   * Attempts to decrypt the current vault and load its keyrings,
-   * using the given encryption key and salt.
-   *
-   * @param encryptionKey - Key to unlock the keychain.
-   * @param encryptionSalt - Salt to unlock the keychain.
-   * @returns Promise resolving when the operation completes.
-   */
-  async submitEncryptionKey(encryptionKey, encryptionSalt) {
-    return __privateMethod(this, _withRollback, withRollback_fn).call(this, async () => {
-      __privateSet(this, _keyrings, await __privateMethod(this, _unlockKeyrings, unlockKeyrings_fn).call(this, void 0, encryptionKey, encryptionSalt));
-      __privateMethod(this, _setUnlocked, setUnlocked_fn).call(this);
-    });
-  }
-  /**
-   * Attempts to decrypt the current vault and load its keyrings,
-   * using the given password.
-   *
-   * @param password - Password to unlock the keychain.
-   * @returns Promise resolving when the operation completes.
-   */
-  async submitPassword(password) {
-    return __privateMethod(this, _withRollback, withRollback_fn).call(this, async () => {
-      __privateSet(this, _keyrings, await __privateMethod(this, _unlockKeyrings, unlockKeyrings_fn).call(this, password));
-      __privateMethod(this, _setUnlocked, setUnlocked_fn).call(this);
-    });
-  }
-  /**
-   * Verifies the that the seed phrase restores the current keychain's accounts.
-   *
-   * @returns Promise resolving to the seed phrase as Uint8Array.
-   */
-  async verifySeedPhrase() {
-    const primaryKeyring = this.getKeyringsByType("HD Key Tree" /* hd */)[0];
-    if (!primaryKeyring) {
-      throw new Error("No HD keyring found.");
-    }
-    assertHasUint8ArrayMnemonic(primaryKeyring);
-    const seedWords = primaryKeyring.mnemonic;
-    const accounts = await primaryKeyring.getAccounts();
-    if (accounts.length === 0) {
-      throw new Error("Cannot verify an empty keyring.");
-    }
-    const hdKeyringBuilder = __privateMethod(this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, "HD Key Tree" /* hd */);
-    const hdKeyring = hdKeyringBuilder();
-    await hdKeyring.deserialize({
-      mnemonic: seedWords,
-      numberOfAccounts: accounts.length
-    });
-    const testAccounts = await hdKeyring.getAccounts();
-    if (testAccounts.length !== accounts.length) {
-      throw new Error("Seed phrase imported incorrect number of accounts.");
-    }
-    testAccounts.forEach((account, i) => {
-      if (account.toLowerCase() !== accounts[i].toLowerCase()) {
-        throw new Error("Seed phrase imported different accounts.");
-      }
-    });
-    return seedWords;
-  }
-  async withKeyring(selector, operation, options = {
-    createIfMissing: false
-  }) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      let keyring;
-      if ("address" in selector) {
-        keyring = await this.getKeyringForAccount(selector.address);
-      } else {
-        keyring = this.getKeyringsByType(selector.type)[selector.index || 0];
-        if (!keyring && options.createIfMissing) {
-          keyring = await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, selector.type, options.createWithData);
-        }
-      }
-      if (!keyring) {
-        throw new Error("KeyringController - Keyring not found." /* KeyringNotFound */);
-      }
-      const result = await operation(keyring);
-      if (Object.is(result, keyring)) {
-        throw new Error("KeyringController - Returning keyring instances is unsafe" /* UnsafeDirectKeyringAccess */);
-      }
-      return result;
-    });
-  }
-  // QR Hardware related methods
-  /**
-   * Get QR Hardware keyring.
-   *
-   * @returns The QR Keyring if defined, otherwise undefined
-   */
-  getQRKeyring() {
-    return this.getKeyringsByType("QR Hardware Wallet Device" /* qr */)[0];
-  }
-  /**
-   * Get QR hardware keyring. If it doesn't exist, add it.
-   *
-   * @returns The added keyring
-   */
-  async getOrAddQRKeyring() {
-    return this.getQRKeyring() || await __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this));
-  }
-  // TODO: Replace `any` with type
-  // eslint-disable-next-line @typescript-eslint/no-explicit-any
-  async restoreQRKeyring(serialized) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = this.getQRKeyring() || await __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this);
-      keyring.deserialize(serialized);
-    });
-  }
-  async resetQRKeyringState() {
-    (await this.getOrAddQRKeyring()).resetStore();
-  }
-  async getQRKeyringState() {
-    return (await this.getOrAddQRKeyring()).getMemStore();
-  }
-  async submitQRCryptoHDKey(cryptoHDKey) {
-    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);
-  }
-  async submitQRCryptoAccount(cryptoAccount) {
-    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);
-  }
-  async submitQRSignature(requestId, ethSignature) {
-    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);
-  }
-  async cancelQRSignRequest() {
-    (await this.getOrAddQRKeyring()).cancelSignRequest();
-  }
-  /**
-   * Cancels qr keyring sync.
-   */
-  async cancelQRSynchronization() {
-    (await this.getOrAddQRKeyring()).cancelSync();
-  }
-  async connectQRHardware(page) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      try {
-        const keyring = this.getQRKeyring() || await __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this);
-        let accounts;
-        switch (page) {
-          case -1:
-            accounts = await keyring.getPreviousPage();
-            break;
-          case 1:
-            accounts = await keyring.getNextPage();
-            break;
-          default:
-            accounts = await keyring.getFirstPage();
-        }
-        return accounts.map((account) => {
-          return {
-            ...account,
-            balance: "0x0"
-          };
-        });
-      } catch (e) {
-        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);
-      }
-    });
-  }
-  async unlockQRHardwareWalletAccount(index) {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = this.getQRKeyring() || await __privateMethod(this, _addQRKeyring, addQRKeyring_fn).call(this);
-      keyring.setAccountToUnlock(index);
-      await keyring.addAccounts(1);
-    });
-  }
-  async getAccountKeyringType(account) {
-    const keyring = await this.getKeyringForAccount(
-      account
-    );
-    return keyring.type;
-  }
-  async forgetQRDevice() {
-    return __privateMethod(this, _persistOrRollback, persistOrRollback_fn).call(this, async () => {
-      const keyring = this.getQRKeyring();
-      if (!keyring) {
-        return { removedAccounts: [], remainingAccounts: [] };
-      }
-      const allAccounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      keyring.forgetDevice();
-      const remainingAccounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-      const removedAccounts = allAccounts.filter(
-        (address) => !remainingAccounts.includes(address)
-      );
-      return { removedAccounts, remainingAccounts };
-    });
-  }
-};
-_controllerOperationMutex = new WeakMap();
-_vaultOperationMutex = new WeakMap();
-_keyringBuilders = new WeakMap();
-_keyrings = new WeakMap();
-_unsupportedKeyrings = new WeakMap();
-_password = new WeakMap();
-_encryptor = new WeakMap();
-_cacheEncryptionKey = new WeakMap();
-_qrKeyringStateListener = new WeakMap();
-_registerMessageHandlers = new WeakSet();
-registerMessageHandlers_fn = function() {
-  this.messagingSystem.registerActionHandler(
-    `${name}:signMessage`,
-    this.signMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:signPersonalMessage`,
-    this.signPersonalMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:signTypedMessage`,
-    this.signTypedMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:decryptMessage`,
-    this.decryptMessage.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getEncryptionPublicKey`,
-    this.getEncryptionPublicKey.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getAccounts`,
-    this.getAccounts.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getKeyringsByType`,
-    this.getKeyringsByType.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:getKeyringForAccount`,
-    this.getKeyringForAccount.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:persistAllKeyrings`,
-    this.persistAllKeyrings.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:prepareUserOperation`,
-    this.prepareUserOperation.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:patchUserOperation`,
-    this.patchUserOperation.bind(this)
-  );
-  this.messagingSystem.registerActionHandler(
-    `${name}:signUserOperation`,
-    this.signUserOperation.bind(this)
-  );
-};
-_getKeyringBuilderForType = new WeakSet();
-getKeyringBuilderForType_fn = function(type) {
-  return __privateGet(this, _keyringBuilders).find(
-    (keyringBuilder) => keyringBuilder.type === type
-  );
-};
-_addQRKeyring = new WeakSet();
-addQRKeyring_fn = async function() {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  return await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, "QR Hardware Wallet Device" /* qr */);
-};
-_subscribeToQRKeyringEvents = new WeakSet();
-subscribeToQRKeyringEvents_fn = function(qrKeyring) {
-  __privateSet(this, _qrKeyringStateListener, (state) => {
-    this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);
-  });
-  qrKeyring.getMemStore().subscribe(__privateGet(this, _qrKeyringStateListener));
-};
-_unsubscribeFromQRKeyringsEvents = new WeakSet();
-unsubscribeFromQRKeyringsEvents_fn = function() {
-  const qrKeyrings = this.getKeyringsByType(
-    "QR Hardware Wallet Device" /* qr */
-  );
-  qrKeyrings.forEach((qrKeyring) => {
-    if (__privateGet(this, _qrKeyringStateListener)) {
-      qrKeyring.getMemStore().unsubscribe(__privateGet(this, _qrKeyringStateListener));
-    }
-  });
-};
-_createNewVaultWithKeyring = new WeakSet();
-createNewVaultWithKeyring_fn = async function(password, keyring) {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  if (typeof password !== "string") {
-    throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
-  }
-  __privateSet(this, _password, password);
-  await __privateMethod(this, _clearKeyrings, clearKeyrings_fn).call(this);
-  await __privateMethod(this, _createKeyringWithFirstAccount, createKeyringWithFirstAccount_fn).call(this, keyring.type, keyring.opts);
-  __privateMethod(this, _setUnlocked, setUnlocked_fn).call(this);
-};
-_getUpdatedKeyrings = new WeakSet();
-getUpdatedKeyrings_fn = async function() {
-  return Promise.all(__privateGet(this, _keyrings).map(displayForKeyring));
-};
-_getSerializedKeyrings = new WeakSet();
-getSerializedKeyrings_fn = async function({ includeUnsupported } = {
-  includeUnsupported: true
-}) {
-  const serializedKeyrings = await Promise.all(
-    __privateGet(this, _keyrings).map(async (keyring) => {
-      const [type, data] = await Promise.all([
-        keyring.type,
-        keyring.serialize()
-      ]);
-      return { type, data };
-    })
-  );
-  if (includeUnsupported) {
-    serializedKeyrings.push(...__privateGet(this, _unsupportedKeyrings));
-  }
-  return serializedKeyrings;
-};
-_restoreSerializedKeyrings = new WeakSet();
-restoreSerializedKeyrings_fn = async function(serializedKeyrings) {
-  await __privateMethod(this, _clearKeyrings, clearKeyrings_fn).call(this);
-  for (const serializedKeyring of serializedKeyrings) {
-    await __privateMethod(this, _restoreKeyring, restoreKeyring_fn).call(this, serializedKeyring);
-  }
-};
-_unlockKeyrings = new WeakSet();
-unlockKeyrings_fn = async function(password, encryptionKey, encryptionSalt) {
-  return __privateMethod(this, _withVaultLock, withVaultLock_fn).call(this, async ({ releaseLock }) => {
-    const encryptedVault = this.state.vault;
-    if (!encryptedVault) {
-      throw new Error("KeyringController - Cannot unlock without a previous vault." /* VaultError */);
-    }
-    let vault;
-    const updatedState = {};
-    if (__privateGet(this, _cacheEncryptionKey)) {
-      assertIsExportableKeyEncryptor(__privateGet(this, _encryptor));
-      if (password) {
-        const result = await __privateGet(this, _encryptor).decryptWithDetail(
-          password,
-          encryptedVault
-        );
-        vault = result.vault;
-        __privateSet(this, _password, password);
-        updatedState.encryptionKey = result.exportedKeyString;
-        updatedState.encryptionSalt = result.salt;
-      } else {
-        const parsedEncryptedVault = JSON.parse(encryptedVault);
-        if (encryptionSalt !== parsedEncryptedVault.salt) {
-          throw new Error("KeyringController - Encryption key and salt provided are expired" /* ExpiredCredentials */);
-        }
-        if (typeof encryptionKey !== "string") {
-          throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
-        }
-        const key = await __privateGet(this, _encryptor).importKey(encryptionKey);
-        vault = await __privateGet(this, _encryptor).decryptWithKey(
-          key,
-          parsedEncryptedVault
-        );
-        updatedState.encryptionKey = encryptionKey;
-        updatedState.encryptionSalt = encryptionSalt;
-      }
-    } else {
-      if (typeof password !== "string") {
-        throw new TypeError("KeyringController - Password must be of type string." /* WrongPasswordType */);
-      }
-      vault = await __privateGet(this, _encryptor).decrypt(password, encryptedVault);
-      __privateSet(this, _password, password);
-    }
-    if (!isSerializedKeyringsArray(vault)) {
-      throw new Error("KeyringController - The decrypted vault has an unexpected shape." /* VaultDataError */);
-    }
-    await __privateMethod(this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, vault);
-    const updatedKeyrings = await __privateMethod(this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
-    this.update((state) => {
-      state.keyrings = updatedKeyrings;
-      if (updatedState.encryptionKey || updatedState.encryptionSalt) {
-        state.encryptionKey = updatedState.encryptionKey;
-        state.encryptionSalt = updatedState.encryptionSalt;
-      }
-    });
-    if (__privateGet(this, _password) && (!__privateGet(this, _cacheEncryptionKey) || !encryptionKey) && __privateGet(this, _encryptor).isVaultUpdated && !__privateGet(this, _encryptor).isVaultUpdated(encryptedVault)) {
-      releaseLock();
-      await __privateMethod(this, _updateVault, updateVault_fn).call(this);
-    }
-    return __privateGet(this, _keyrings);
-  });
-};
-_updateVault = new WeakSet();
-updateVault_fn = function() {
-  return __privateMethod(this, _withVaultLock, withVaultLock_fn).call(this, async () => {
-    const { encryptionKey, encryptionSalt } = this.state;
-    if (!__privateGet(this, _password) && !encryptionKey) {
-      throw new Error("KeyringController - Cannot persist vault without password and encryption key" /* MissingCredentials */);
-    }
-    const serializedKeyrings = await __privateMethod(this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
-    if (!serializedKeyrings.some((keyring) => keyring.type === "HD Key Tree" /* hd */)) {
-      throw new Error("KeyringController - No HD Keyring found" /* NoHdKeyring */);
-    }
-    const updatedState = {};
-    if (__privateGet(this, _cacheEncryptionKey)) {
-      assertIsExportableKeyEncryptor(__privateGet(this, _encryptor));
-      if (encryptionKey) {
-        const key = await __privateGet(this, _encryptor).importKey(encryptionKey);
-        const vaultJSON = await __privateGet(this, _encryptor).encryptWithKey(
-          key,
-          serializedKeyrings
-        );
-        vaultJSON.salt = encryptionSalt;
-        updatedState.vault = JSON.stringify(vaultJSON);
-      } else if (__privateGet(this, _password)) {
-        const { vault: newVault, exportedKeyString } = await __privateGet(this, _encryptor).encryptWithDetail(
-          __privateGet(this, _password),
-          serializedKeyrings
-        );
-        updatedState.vault = newVault;
-        updatedState.encryptionKey = exportedKeyString;
-      }
-    } else {
-      assertIsValidPassword(__privateGet(this, _password));
-      updatedState.vault = await __privateGet(this, _encryptor).encrypt(
-        __privateGet(this, _password),
-        serializedKeyrings
-      );
-    }
-    if (!updatedState.vault) {
-      throw new Error("KeyringController - Cannot persist vault without vault information" /* MissingVaultData */);
-    }
-    const updatedKeyrings = await __privateMethod(this, _getUpdatedKeyrings, getUpdatedKeyrings_fn).call(this);
-    this.update((state) => {
-      state.vault = updatedState.vault;
-      state.keyrings = updatedKeyrings;
-      if (updatedState.encryptionKey) {
-        state.encryptionKey = updatedState.encryptionKey;
-        state.encryptionSalt = JSON.parse(updatedState.vault).salt;
-      }
-    });
-    return true;
-  });
-};
-_getAccountsFromKeyrings = new WeakSet();
-getAccountsFromKeyrings_fn = async function() {
-  const keyrings = __privateGet(this, _keyrings);
-  const keyringArrays = await Promise.all(
-    keyrings.map(async (keyring) => keyring.getAccounts())
-  );
-  const addresses = keyringArrays.reduce((res, arr) => {
-    return res.concat(arr);
-  }, []);
-  return addresses.map(normalize);
-};
-_createKeyringWithFirstAccount = new WeakSet();
-createKeyringWithFirstAccount_fn = async function(type, opts) {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  const keyring = await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, type, opts);
-  const [firstAccount] = await keyring.getAccounts();
-  if (!firstAccount) {
-    throw new Error("KeyringController - First Account not found." /* NoFirstAccount */);
-  }
-};
-_newKeyring = new WeakSet();
-newKeyring_fn = async function(type, data) {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  const keyringBuilder = __privateMethod(this, _getKeyringBuilderForType, getKeyringBuilderForType_fn).call(this, type);
-  if (!keyringBuilder) {
-    throw new Error(
-      `${"KeyringController - No keyringBuilder found for keyring" /* NoKeyringBuilder */}. Keyring type: ${type}`
-    );
-  }
-  const keyring = keyringBuilder();
-  await keyring.deserialize(data);
-  if (keyring.init) {
-    await keyring.init();
-  }
-  if (type === "HD Key Tree" /* hd */ && (!isObject(data) || !data.mnemonic)) {
-    if (!keyring.generateRandomMnemonic) {
-      throw new Error(
-        "KeyringController - The current keyring does not support the method generateRandomMnemonic." /* UnsupportedGenerateRandomMnemonic */
-      );
-    }
-    keyring.generateRandomMnemonic();
-    await keyring.addAccounts(1);
-  }
-  await __privateMethod(this, _checkForDuplicate, checkForDuplicate_fn).call(this, type, await keyring.getAccounts());
-  if (type === "QR Hardware Wallet Device" /* qr */) {
-    __privateMethod(this, _subscribeToQRKeyringEvents, subscribeToQRKeyringEvents_fn).call(this, keyring);
-  }
-  __privateGet(this, _keyrings).push(keyring);
-  return keyring;
-};
-_clearKeyrings = new WeakSet();
-clearKeyrings_fn = async function() {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  for (const keyring of __privateGet(this, _keyrings)) {
-    await __privateMethod(this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
-  }
-  __privateSet(this, _keyrings, []);
-};
-_restoreKeyring = new WeakSet();
-restoreKeyring_fn = async function(serialized) {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  try {
-    const { type, data } = serialized;
-    return await __privateMethod(this, _newKeyring, newKeyring_fn).call(this, type, data);
-  } catch (_) {
-    __privateGet(this, _unsupportedKeyrings).push(serialized);
-    return void 0;
-  }
-};
-_destroyKeyring = new WeakSet();
-destroyKeyring_fn = async function(keyring) {
-  await keyring.destroy?.();
-};
-_removeEmptyKeyrings = new WeakSet();
-removeEmptyKeyrings_fn = async function() {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  const validKeyrings = [];
-  await Promise.all(
-    __privateGet(this, _keyrings).map(async (keyring) => {
-      const accounts = await keyring.getAccounts();
-      if (accounts.length > 0) {
-        validKeyrings.push(keyring);
-      } else {
-        await __privateMethod(this, _destroyKeyring, destroyKeyring_fn).call(this, keyring);
-      }
-    })
-  );
-  __privateSet(this, _keyrings, validKeyrings);
-};
-_checkForDuplicate = new WeakSet();
-checkForDuplicate_fn = async function(type, newAccountArray) {
-  const accounts = await __privateMethod(this, _getAccountsFromKeyrings, getAccountsFromKeyrings_fn).call(this);
-  switch (type) {
-    case "Simple Key Pair" /* simple */: {
-      const isIncluded = Boolean(
-        accounts.find(
-          (key) => newAccountArray[0] && (key === newAccountArray[0] || key === remove0x(newAccountArray[0]))
-        )
-      );
-      if (isIncluded) {
-        throw new Error("KeyringController - The account you are trying to import is a duplicate" /* DuplicatedAccount */);
-      }
-      return newAccountArray;
-    }
-    default: {
-      return newAccountArray;
-    }
-  }
-};
-_setUnlocked = new WeakSet();
-setUnlocked_fn = function() {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  this.update((state) => {
-    state.isUnlocked = true;
-  });
-  this.messagingSystem.publish(`${name}:unlock`);
-};
-_persistOrRollback = new WeakSet();
-persistOrRollback_fn = async function(fn) {
-  return __privateMethod(this, _withRollback, withRollback_fn).call(this, async ({ releaseLock }) => {
-    const callbackResult = await fn({ releaseLock });
-    await __privateMethod(this, _updateVault, updateVault_fn).call(this);
-    return callbackResult;
-  });
-};
-_withRollback = new WeakSet();
-withRollback_fn = async function(fn) {
-  return __privateMethod(this, _withControllerLock, withControllerLock_fn).call(this, async ({ releaseLock }) => {
-    const currentSerializedKeyrings = await __privateMethod(this, _getSerializedKeyrings, getSerializedKeyrings_fn).call(this);
-    const currentPassword = __privateGet(this, _password);
-    try {
-      return await fn({ releaseLock });
-    } catch (e) {
-      await __privateMethod(this, _restoreSerializedKeyrings, restoreSerializedKeyrings_fn).call(this, currentSerializedKeyrings);
-      __privateSet(this, _password, currentPassword);
-      throw e;
-    }
-  });
-};
-_assertControllerMutexIsLocked = new WeakSet();
-assertControllerMutexIsLocked_fn = function() {
-  if (!__privateGet(this, _controllerOperationMutex).isLocked()) {
-    throw new Error("KeyringController - attempt to update vault during a non mutually exclusive operation" /* ControllerLockRequired */);
-  }
-};
-_withControllerLock = new WeakSet();
-withControllerLock_fn = async function(fn) {
-  return withLock(__privateGet(this, _controllerOperationMutex), fn);
-};
-_withVaultLock = new WeakSet();
-withVaultLock_fn = async function(fn) {
-  __privateMethod(this, _assertControllerMutexIsLocked, assertControllerMutexIsLocked_fn).call(this);
-  return withLock(__privateGet(this, _vaultOperationMutex), fn);
-};
-async function withLock(mutex, fn) {
-  const releaseLock = await mutex.acquire();
-  try {
-    return await fn({ releaseLock });
-  } finally {
-    releaseLock();
-  }
-}
-var KeyringController_default = KeyringController;
-
-export {
-  KeyringTypes,
-  isCustodyKeyring,
-  AccountImportStrategy,
-  SignTypedDataVersion,
-  keyringBuilderFactory,
-  getDefaultKeyringState,
-  KeyringController,
-  KeyringController_default
-};
-//# sourceMappingURL=chunk-STFS4REY.mjs.map
\ No newline at end of file
diff --git a/dist/chunk-STFS4REY.mjs.map b/dist/chunk-STFS4REY.mjs.map
deleted file mode 100644
index 3ed91da3b2a1e05d7fc7decac48e949923ff760c..0000000000000000000000000000000000000000
--- a/dist/chunk-STFS4REY.mjs.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["../src/KeyringController.ts"],"sourcesContent":["import type { TxData, TypedTransaction } from '@ethereumjs/tx';\nimport { isValidPrivate, toBuffer, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport HDKeyring from '@metamask/eth-hd-keyring';\nimport { normalize as ethNormalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthKeyring,\n  EthUserOperation,\n  EthUserOperationPatch,\n  KeyringExecutionContext,\n} from '@metamask/keyring-api';\nimport type {\n  PersonalMessageParams,\n  TypedMessageParams,\n} from '@metamask/message-manager';\nimport type {\n  Eip1024EncryptedData,\n  Hex,\n  Json,\n  KeyringClass,\n} from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  isObject,\n  isStrictHexString,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { MutexInterface } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\n\nimport { KeyringControllerError } from './constants';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * @type KeyringControllerState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n * @property encryptionKey - Keyring encryption key\n * @property encryptionSalt - Keyring encryption salt\n */\nexport type KeyringControllerState = {\n  vault?: string;\n  isUnlocked: boolean;\n  keyrings: KeyringObject[];\n  encryptionKey?: string;\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  never,\n  never\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring<Json>; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * @type KeyringObject\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n */\nexport type KeyringObject = {\n  accounts: string[];\n  type: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor = GenericEncryptor & {\n  /**\n   * Encrypts the given object with the given encryption key.\n   *\n   * @param key - The encryption key to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encryption result.\n   */\n  encryptWithKey: (\n    key: unknown,\n    object: Json,\n  ) => Promise<encryptorUtils.EncryptionResult>;\n  /**\n   * Encrypts the given object with the given password, and returns the\n   * encryption result and the exported key string.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @param salt - The optional salt to use for encryption.\n   * @returns The encrypted string and the exported key string.\n   */\n  encryptWithDetail: (\n    password: string,\n    object: Json,\n    salt?: string,\n  ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n  /**\n   * Decrypts the given encrypted string with the given encryption key.\n   *\n   * @param key - The encryption key to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decryptWithKey: (key: unknown, encryptedString: string) => Promise<unknown>;\n  /**\n   * Decrypts the given encrypted string with the given password, and returns\n   * the decrypted object and the salt and exported key string used for\n   * encryption.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object and the salt and exported key string used for\n   * encryption.\n   */\n  decryptWithDetail: (\n    password: string,\n    encryptedString: string,\n  ) => Promise<encryptorUtils.DetailedDecryptResult>;\n  /**\n   * Generates an encryption key from exported key string.\n   *\n   * @param key - The exported key string.\n   * @returns The encryption key.\n   */\n  importKey: (key: string) => Promise<unknown>;\n};\n\nexport type KeyringSelector =\n  | {\n      type: string;\n      index?: number;\n    }\n  | {\n      address: Hex;\n    };\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<T> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<T>;\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass<Json>) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  keyringBuilderFactory(SimpleKeyring),\n  keyringBuilderFactory(HDKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring<Json>,\n): asserts keyring is EthKeyring<Json> & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(KeyringControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(KeyringControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyring - The keyring to display.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring(\n  keyring: EthKeyring<Json>,\n): Promise<{ type: string; accounts: string[] }> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `string[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    accounts: accounts.map(normalize) as string[],\n  };\n}\n\n/**\n * Check if address is an ethereum address\n *\n * @param address - An address.\n * @returns Returns true if the address is an ethereum one, false otherwise.\n */\nfunction isEthAddress(address: string): boolean {\n  // We first check if it's a matching `Hex` string, so that is narrows down\n  // `address` as an `Hex` type, allowing us to use `isValidHexAddress`\n  return (\n    // NOTE: This function only checks for lowercased strings\n    isStrictHexString(address.toLowerCase()) &&\n    // This checks for lowercased addresses and checksum addresses too\n    isValidHexAddress(address as Hex)\n  );\n}\n\n/**\n * Normalize ethereum or non-EVM address.\n *\n * @param address - Ethereum or non-EVM address.\n * @returns The normalized address.\n */\nfunction normalize(address: string): string | undefined {\n  // Since the `KeyringController` is only dealing with address, we have\n  // no other way to get the associated account type with this address. So we\n  // are down to check the actual address format for now\n  // TODO: Find a better way to not have those runtime checks based on the\n  //       address value!\n  return isEthAddress(address) ? ethNormalize(address) : address;\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  readonly #controllerOperationMutex = new Mutex();\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  #keyringBuilders: { (): EthKeyring<Json>; type: string }[];\n\n  #keyrings: EthKeyring<Json>[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  #cacheEncryptionKey: boolean;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? defaultKeyringBuilders.concat(keyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccount(accountCount?: number): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const oldAccounts = await primaryKeyring.getAccounts();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n        // we return the account already existing at index `accountCount`\n        const existingAccount = oldAccounts[accountCount];\n\n        if (!existingAccount) {\n          throw new Error(`Can't find account at index ${accountCount}`);\n        }\n\n        return existingAccount;\n      }\n\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to the added account address\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring<Json>,\n    accountCount?: number,\n  ): Promise<Hex> {\n    // READ THIS CAREFULLY:\n    // We still uses `Hex` here, since we are not using this method when creating\n    // and account using a \"Snap Keyring\". This function assume the `keyring` is\n    // ethereum compatible, but \"Snap Keyring\" might not be.\n    return this.#persistOrRollback(async () => {\n      const oldAccounts = await this.#getAccountsFromKeyrings();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n\n        const existingAccount = oldAccounts[accountCount];\n        assertIsStrictHexString(existingAccount);\n\n        return existingAccount;\n      }\n\n      await keyring.addAccounts(1);\n\n      const addedAccountAddress = (await this.#getAccountsFromKeyrings()).find(\n        (selectedAddress) => !oldAccounts.includes(selectedAddress),\n      );\n      assertIsStrictHexString(addedAccountAddress);\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccountWithoutUpdate(): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring<Json>\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.verifySeedPhrase();\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n    });\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    return this.#persistOrRollback(async () => {\n      const accounts = await this.#getAccountsFromKeyrings();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n    });\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the added keyring.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<unknown> {\n    if (type === KeyringTypes.qr) {\n      return this.getOrAddQRKeyring();\n    }\n\n    return this.#persistOrRollback(async () => this.#newKeyring(type, opts));\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(password: string): Promise<Uint8Array> {\n    await this.verifyPassword(password);\n    assertHasUint8ArrayMnemonic(this.#keyrings[0]);\n    return this.#keyrings[0].mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts from every keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    return this.state.keyrings.reduce<string[]>(\n      (accounts, keyring) => accounts.concat(keyring.accounts),\n      [],\n    );\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    const address = ethNormalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(address, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    const address = normalize(account);\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(address);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    return this.#keyrings.filter((keyring) => keyring.type === type);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @deprecated This method is being phased out in favor of `withKeyring`.\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#persistOrRollback(async () => true);\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to the imported account address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<string> {\n    return this.#persistOrRollback(async () => {\n      let privateKey;\n      switch (strategy) {\n        case 'privateKey':\n          const [importedKey] = args;\n          if (!importedKey) {\n            throw new Error('Cannot import an empty key.');\n          }\n          const prefixed = add0x(importedKey);\n\n          let bufferedPrivateKey;\n          try {\n            bufferedPrivateKey = toBuffer(prefixed);\n          } catch {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          if (\n            !isValidPrivate(bufferedPrivateKey) ||\n            // ensures that the key is 64 bytes long\n            getBinarySize(prefixed) !== 64 + '0x'.length\n          ) {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          privateKey = remove0x(prefixed);\n          break;\n        case 'json':\n          let wallet;\n          const [input, password] = args;\n          try {\n            wallet = importers.fromEtherWallet(input, password);\n          } catch (e) {\n            wallet = wallet || (await Wallet.fromV3(input, password, true));\n          }\n          privateKey = bytesToHex(wallet.getPrivateKey());\n          break;\n        default:\n          throw new Error(`Unexpected import strategy: '${strategy}'`);\n      }\n      const newKeyring = (await this.#newKeyring(KeyringTypes.simple, [\n        privateKey,\n      ])) as EthKeyring<Json>;\n      const accounts = await newKeyring.getAccounts();\n      return accounts[0];\n    });\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving when the account is removed.\n   */\n  async removeAccount(address: string): Promise<void> {\n    await this.#persistOrRollback(async () => {\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n\n      // Not all the keyrings support this, so we have to check\n      if (!keyring.removeAccount) {\n        throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n      }\n\n      // The `removeAccount` method of snaps keyring is async. We have to update\n      // the interface of the other keyrings to be async as well.\n      // eslint-disable-next-line @typescript-eslint/await-thenable\n      // FIXME: We do cast to `Hex` to makes the type checker happy here, and\n      // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those\n      // type would need to be updated for a full non-EVM support.\n      await keyring.removeAccount(address as Hex);\n\n      const accounts = await keyring.getAccounts();\n      // Check if this was the last/only account\n      if (accounts.length === 0) {\n        await this.#removeEmptyKeyrings();\n      }\n    });\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving when the operation completes.\n   */\n  async setLocked(): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#unsubscribeFromQRKeyringsEvents();\n\n      this.#password = undefined;\n      await this.#clearKeyrings();\n\n      this.update((state) => {\n        state.isUnlocked = false;\n        state.keyrings = [];\n      });\n\n      this.messagingSystem.publish(`${name}:lock`);\n    });\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = ethNormalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(\n        address,\n      )) as EthKeyring<Json>;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TxData> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthBaseUserOperation> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(\n      address,\n      transactions,\n      executionContext,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthUserOperationPatch> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<string> {\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(\n      address,\n    )) as EthKeyring<Json>;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Changes the password used to encrypt the vault.\n   *\n   * @param password - The new password.\n   * @returns Promise resolving when the operation completes.\n   */\n  changePassword(password: string): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      if (!this.state.isUnlocked) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      assertIsValidPassword(password);\n\n      this.#password = password;\n      // We need to clear encryption key and salt from state\n      // to force the controller to re-encrypt the vault using\n      // the new password.\n      if (this.#cacheEncryptionKey) {\n        this.update((state) => {\n          delete state.encryptionKey;\n          delete state.encryptionSalt;\n        });\n      }\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given encryption key and salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Salt to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt: string,\n  ): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(\n        undefined,\n        encryptionKey,\n        encryptionSalt,\n      );\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitPassword(password: string): Promise<void> {\n    return this.#withRollback(async () => {\n      this.#keyrings = await this.#unlockKeyrings(password);\n      this.#setUnlocked();\n    });\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(): Promise<Uint8Array> {\n    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0] as\n      | EthKeyring<Json>\n      | undefined;\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    assertHasUint8ArrayMnemonic(primaryKeyring);\n\n    const seedWords = primaryKeyring.mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @param options - Additional options.\n   * @param options.createIfMissing - Whether to create a new keyring if the selected one is missing.\n   * @param options.createWithData - Optional data to use when creating a new keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   * @deprecated This method overload is deprecated. Use `withKeyring` without options instead.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown },\n  ): Promise<CallbackResult>;\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n  ): Promise<CallbackResult>;\n\n  async withKeyring<\n    SelectedKeyring extends EthKeyring<Json> = EthKeyring<Json>,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: (keyring: SelectedKeyring) => Promise<CallbackResult>,\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown } = {\n      createIfMissing: false,\n    },\n  ): Promise<CallbackResult> {\n    return this.#persistOrRollback(async () => {\n      let keyring: SelectedKeyring | undefined;\n\n      if ('address' in selector) {\n        keyring = (await this.getKeyringForAccount(selector.address)) as\n          | SelectedKeyring\n          | undefined;\n      } else {\n        keyring = this.getKeyringsByType(selector.type)[selector.index || 0] as\n          | SelectedKeyring\n          | undefined;\n\n        if (!keyring && options.createIfMissing) {\n          keyring = (await this.#newKeyring(\n            selector.type,\n            options.createWithData,\n          )) as SelectedKeyring;\n        }\n      }\n\n      if (!keyring) {\n        throw new Error(KeyringControllerError.KeyringNotFound);\n      }\n\n      const result = await operation(keyring);\n\n      if (Object.is(result, keyring)) {\n        // Access to a keyring instance outside of controller safeguards\n        // should be discouraged, as it can lead to unexpected behavior.\n        // This error is thrown to prevent consumers using `withKeyring`\n        // as a way to get a reference to a keyring instance.\n        throw new Error(KeyringControllerError.UnsafeDirectKeyringAccess);\n      }\n\n      return result;\n    });\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    return (\n      this.getQRKeyring() ||\n      (await this.#persistOrRollback(async () => this.#addQRKeyring()))\n    );\n  }\n\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n      keyring.deserialize(serialized);\n    });\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    // eslint-disable-next-line n/no-sync\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    return this.#persistOrRollback(async () => {\n      try {\n        const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n        let accounts;\n        switch (page) {\n          case -1:\n            accounts = await keyring.getPreviousPage();\n            break;\n          case 1:\n            accounts = await keyring.getNextPage();\n            break;\n          default:\n            accounts = await keyring.getFirstPage();\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return accounts.map((account: any) => {\n          return {\n            ...account,\n            balance: '0x0',\n          };\n        });\n      } catch (e) {\n        // TODO: Add test case for when keyring throws\n        /* istanbul ignore next */\n        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n      }\n    });\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n\n      keyring.setAccountToUnlock(index);\n      await keyring.addAccounts(1);\n    });\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    const keyring = (await this.getKeyringForAccount(\n      account,\n    )) as EthKeyring<Json>;\n    return keyring.type;\n  }\n\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring();\n\n      if (!keyring) {\n        return { removedAccounts: [], remainingAccounts: [] };\n      }\n\n      const allAccounts = (await this.#getAccountsFromKeyrings()) as string[];\n      keyring.forgetDevice();\n      const remainingAccounts =\n        (await this.#getAccountsFromKeyrings()) as string[];\n      const removedAccounts = allAccounts.filter(\n        (address: string) => !remainingAccounts.includes(address),\n      );\n      return { removedAccounts, remainingAccounts };\n    });\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring<Json>; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return (await this.#newKeyring(KeyringTypes.qr)) as unknown as QRKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n  }\n\n  /**\n   * Get the updated array of each keyring's type and\n   * accounts list.\n   *\n   * @returns A promise resolving to the updated keyrings array.\n   */\n  async #getUpdatedKeyrings(): Promise<KeyringObject[]> {\n    return Promise.all(this.#keyrings.map(displayForKeyring));\n  }\n\n  /**\n   * Serialize the current array of keyring instances,\n   * including unsupported keyrings by default.\n   *\n   * @param options - Method options.\n   * @param options.includeUnsupported - Whether to include unsupported keyrings.\n   * @returns The serialized keyrings.\n   */\n  async #getSerializedKeyrings(\n    { includeUnsupported }: { includeUnsupported: boolean } = {\n      includeUnsupported: true,\n    },\n  ): Promise<SerializedKeyring[]> {\n    const serializedKeyrings = await Promise.all(\n      this.#keyrings.map(async (keyring) => {\n        const [type, data] = await Promise.all([\n          keyring.type,\n          keyring.serialize(),\n        ]);\n        return { type, data };\n      }),\n    );\n\n    if (includeUnsupported) {\n      serializedKeyrings.push(...this.#unsupportedKeyrings);\n    }\n\n    return serializedKeyrings;\n  }\n\n  /**\n   * Restore a serialized keyrings array.\n   *\n   * @param serializedKeyrings - The serialized keyrings array.\n   */\n  async #restoreSerializedKeyrings(\n    serializedKeyrings: SerializedKeyring[],\n  ): Promise<void> {\n    await this.#clearKeyrings();\n\n    for (const serializedKeyring of serializedKeyrings) {\n      await this.#restoreKeyring(serializedKeyring);\n    }\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<EthKeyring<Json>[]> {\n    return this.#withVaultLock(async ({ releaseLock }) => {\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(KeyringControllerError.VaultError);\n      }\n\n      let vault;\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (password) {\n          const result = await this.#encryptor.decryptWithDetail(\n            password,\n            encryptedVault,\n          );\n          vault = result.vault;\n          this.#password = password;\n\n          updatedState.encryptionKey = result.exportedKeyString;\n          updatedState.encryptionSalt = result.salt;\n        } else {\n          const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n          if (encryptionSalt !== parsedEncryptedVault.salt) {\n            throw new Error(KeyringControllerError.ExpiredCredentials);\n          }\n\n          if (typeof encryptionKey !== 'string') {\n            throw new TypeError(KeyringControllerError.WrongPasswordType);\n          }\n\n          const key = await this.#encryptor.importKey(encryptionKey);\n          vault = await this.#encryptor.decryptWithKey(\n            key,\n            parsedEncryptedVault,\n          );\n\n          // This call is required on the first call because encryptionKey\n          // is not yet inside the memStore\n          updatedState.encryptionKey = encryptionKey;\n          // we can safely assume that encryptionSalt is defined here\n          // because we compare it with the salt from the vault\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          updatedState.encryptionSalt = encryptionSalt!;\n        }\n      } else {\n        if (typeof password !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        vault = await this.#encryptor.decrypt(password, encryptedVault);\n        this.#password = password;\n      }\n\n      if (!isSerializedKeyringsArray(vault)) {\n        throw new Error(KeyringControllerError.VaultDataError);\n      }\n\n      await this.#restoreSerializedKeyrings(vault);\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey || updatedState.encryptionSalt) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = updatedState.encryptionSalt;\n        }\n      });\n\n      if (\n        this.#password &&\n        (!this.#cacheEncryptionKey || !encryptionKey) &&\n        this.#encryptor.isVaultUpdated &&\n        !this.#encryptor.isVaultUpdated(encryptedVault)\n      ) {\n        // The lock needs to be released before persisting the keyrings\n        // to avoid deadlock\n        releaseLock();\n        // Re-encrypt the vault with safer method if one is available\n        await this.#updateVault();\n      }\n\n      return this.#keyrings;\n    });\n  }\n\n  /**\n   * Update the vault with the current keyrings.\n   *\n   * @returns A promise resolving to `true` if the operation is successful.\n   */\n  #updateVault(): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      const { encryptionKey, encryptionSalt } = this.state;\n\n      if (!this.#password && !encryptionKey) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      const serializedKeyrings = await this.#getSerializedKeyrings();\n\n      if (\n        !serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)\n      ) {\n        throw new Error(KeyringControllerError.NoHdKeyring);\n      }\n\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (encryptionKey) {\n          const key = await this.#encryptor.importKey(encryptionKey);\n          const vaultJSON = await this.#encryptor.encryptWithKey(\n            key,\n            serializedKeyrings,\n          );\n          vaultJSON.salt = encryptionSalt;\n          updatedState.vault = JSON.stringify(vaultJSON);\n        } else if (this.#password) {\n          const { vault: newVault, exportedKeyString } =\n            await this.#encryptor.encryptWithDetail(\n              this.#password,\n              serializedKeyrings,\n            );\n\n          updatedState.vault = newVault;\n          updatedState.encryptionKey = exportedKeyString;\n        }\n      } else {\n        assertIsValidPassword(this.#password);\n        updatedState.vault = await this.#encryptor.encrypt(\n          this.#password,\n          serializedKeyrings,\n        );\n      }\n\n      if (!updatedState.vault) {\n        throw new Error(KeyringControllerError.MissingVaultData);\n      }\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n      this.update((state) => {\n        state.vault = updatedState.vault;\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = JSON.parse(updatedState.vault as string).salt;\n        }\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Retrieves all the accounts from keyrings instances\n   * that are currently in memory.\n   *\n   * @returns A promise resolving to an array of accounts.\n   */\n  async #getAccountsFromKeyrings(): Promise<string[]> {\n    const keyrings = this.#keyrings;\n\n    const keyringArrays = await Promise.all(\n      keyrings.map(async (keyring) => keyring.getAccounts()),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `string[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    return addresses.map(normalize) as string[];\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = (await this.#newKeyring(type, opts)) as EthKeyring<Json>;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   *\n   * @param type - The type of keyring to add.\n   * @param data - The data to restore a previously serialized keyring.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #newKeyring(type: string, data?: unknown): Promise<EthKeyring<Json>> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n\n    // @ts-expect-error Enforce data type after updating clients\n    await keyring.deserialize(data);\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    if (type === KeyringTypes.hd && (!isObject(data) || !data.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    await this.#checkForDuplicate(type, await keyring.getAccounts());\n\n    if (type === KeyringTypes.qr) {\n      // In case of a QR keyring type, we need to subscribe\n      // to its events after creating it\n      this.#subscribeToQRKeyringEvents(keyring as unknown as QRKeyring);\n    }\n\n    this.#keyrings.push(keyring);\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    this.#assertControllerMutexIsLocked();\n    for (const keyring of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<EthKeyring<Json> | undefined> {\n    this.#assertControllerMutexIsLocked();\n\n    try {\n      const { type, data } = serialized;\n      return await this.#newKeyring(type, data);\n    } catch (_) {\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring<Json>) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n    const validKeyrings: EthKeyring<Json>[] = [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async (keyring: EthKeyring<Json>) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push(keyring);\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Checks for duplicate keypairs, using the the first account in the given\n   * array. Rejects if a duplicate is found.\n   *\n   * Only supports 'Simple Key Pair'.\n   *\n   * @param type - The key pair type to check for.\n   * @param newAccountArray - Array of new accounts.\n   * @returns The account, if no duplicate is found.\n   */\n  async #checkForDuplicate(\n    type: string,\n    newAccountArray: string[],\n  ): Promise<string[]> {\n    const accounts = await this.#getAccountsFromKeyrings();\n\n    switch (type) {\n      case KeyringTypes.simple: {\n        const isIncluded = Boolean(\n          accounts.find(\n            (key) =>\n              newAccountArray[0] &&\n              (key === newAccountArray[0] ||\n                key === remove0x(newAccountArray[0])),\n          ),\n        );\n\n        if (isIncluded) {\n          throw new Error(KeyringControllerError.DuplicatedAccount);\n        }\n        return newAccountArray;\n      }\n\n      default: {\n        return newAccountArray;\n      }\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.#assertControllerMutexIsLocked();\n\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and save the keyrings to state after it, or rollback to their\n   * previous state in case of error.\n   *\n   * @param fn - The function to execute.\n   * @returns The result of the function.\n   */\n  async #persistOrRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withRollback(async ({ releaseLock }) => {\n      const callbackResult = await fn({ releaseLock });\n      // State is committed only if the operation is successful\n      await this.#updateVault();\n\n      return callbackResult;\n    });\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and rollback keyrings and password states in case of error.\n   *\n   * @param fn - The function to execute atomically.\n   * @returns The result of the function.\n   */\n  async #withRollback<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return this.#withControllerLock(async ({ releaseLock }) => {\n      const currentSerializedKeyrings = await this.#getSerializedKeyrings();\n      const currentPassword = this.#password;\n\n      try {\n        return await fn({ releaseLock });\n      } catch (e) {\n        // Keyrings and password are restored to their previous state\n        await this.#restoreSerializedKeyrings(currentSerializedKeyrings);\n        this.#password = currentPassword;\n\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Assert that the controller mutex is locked.\n   *\n   * @throws If the controller mutex is not locked.\n   */\n  #assertControllerMutexIsLocked() {\n    if (!this.#controllerOperationMutex.isLocked()) {\n      throw new Error(KeyringControllerError.ControllerLockRequired);\n    }\n  }\n\n  /**\n   * Lock the controller mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This wrapper ensures that each mutable operation that interacts with the\n   * controller and that changes its state is executed in a mutually exclusive way,\n   * preventing unsafe concurrent access that could lead to unpredictable behavior.\n   *\n   * @param fn - The function to execute while the controller mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withControllerLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    return withLock(this.#controllerOperationMutex, fn);\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param fn - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<T>(fn: MutuallyExclusiveCallback<T>): Promise<T> {\n    this.#assertControllerMutexIsLocked();\n\n    return withLock(this.#vaultOperationMutex, fn);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param fn - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<T>(\n  mutex: Mutex,\n  fn: MutuallyExclusiveCallback<T>,\n): Promise<T> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await fn({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n\nexport default KeyringController;\n"],"mappings":"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","names":["KeyringTypes","AccountImportStrategy","SignTypedDataVersion"]}
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index bf8713e2da2130714d42b1fa102fca536a58bd13..ee3560b42837d47440a3957c6403bb98e9e6330c 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -6,7 +6,7 @@
 
 
 
-var _chunkBRS27QHFjs = require('./chunk-BRS27QHF.js');
+var _chunkL4UUWIZAjs = require('./chunk-L4UUWIZA.js');
 require('./chunk-NOCGQCUM.js');
 
 
@@ -16,5 +16,5 @@ require('./chunk-NOCGQCUM.js');
 
 
 
-exports.AccountImportStrategy = _chunkBRS27QHFjs.AccountImportStrategy; exports.KeyringController = _chunkBRS27QHFjs.KeyringController; exports.KeyringTypes = _chunkBRS27QHFjs.KeyringTypes; exports.SignTypedDataVersion = _chunkBRS27QHFjs.SignTypedDataVersion; exports.getDefaultKeyringState = _chunkBRS27QHFjs.getDefaultKeyringState; exports.isCustodyKeyring = _chunkBRS27QHFjs.isCustodyKeyring; exports.keyringBuilderFactory = _chunkBRS27QHFjs.keyringBuilderFactory;
+exports.AccountImportStrategy = _chunkL4UUWIZAjs.AccountImportStrategy; exports.KeyringController = _chunkL4UUWIZAjs.KeyringController; exports.KeyringTypes = _chunkL4UUWIZAjs.KeyringTypes; exports.SignTypedDataVersion = _chunkL4UUWIZAjs.SignTypedDataVersion; exports.getDefaultKeyringState = _chunkL4UUWIZAjs.getDefaultKeyringState; exports.isCustodyKeyring = _chunkL4UUWIZAjs.isCustodyKeyring; exports.keyringBuilderFactory = _chunkL4UUWIZAjs.keyringBuilderFactory;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/index.mjs b/dist/index.mjs
index 8bbc57c7e56445cfea5b1ef6134d7b53ab941c9c..3b1a052f121db8ee7f10650f81332a2bbc0ae83d 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -6,7 +6,7 @@ import {
   getDefaultKeyringState,
   isCustodyKeyring,
   keyringBuilderFactory
-} from "./chunk-STFS4REY.mjs";
+} from "./chunk-7A7D7THR.mjs";
 import "./chunk-F64I344Z.mjs";
 export {
   AccountImportStrategy,
diff --git a/dist/tsconfig.build.tsbuildinfo b/dist/tsconfig.build.tsbuildinfo
index 6cdcb0f629fb0ec66d4d98132e42d9d2dda0fbb2..9642fe3738f9b52ac9acc1a22f8dd81190372ddb 100644
--- a/dist/tsconfig.build.tsbuildinfo
+++ b/dist/tsconfig.build.tsbuildinfo
@@ -1 +1 @@
-{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createProvider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asyncEventEmitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacyTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/baseTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionFactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/patchCBOR.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/lib/DataItem.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/lib/cbor-sync.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/lib/index.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/ur.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urEncoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainEncoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainDecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urDecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/RegistryType.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/RegistryItem.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoCoinInfo.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/PathComponent.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoKeypath.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/types.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoHDKey.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoECKey.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/Bytes.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/MultiKey.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/ScriptExpression.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoOutput.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoPSBT.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoAccount.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/Decoder/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/CryptoMultiAccounts.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/errors/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/DerivationSchema.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/KeyDerivation.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/QRHardwareCall.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/utils.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/EthSignRequest.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/EthSignature.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/ETHNFTItem.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/utlis.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/InteractionProvider.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/BaseKeyring.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/index.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@metamask/safe-event-emitter/dist/cjs/index.d.ts","../../../node_modules/@metamask/obs-store/dist/ObservableStore.d.ts","../../../node_modules/@metamask/obs-store/dist/asStream.d.ts","../../../node_modules/@metamask/obs-store/dist/ComposedStore.d.ts","../../../node_modules/@metamask/obs-store/dist/MergedStore.d.ts","../../../node_modules/@metamask/obs-store/dist/transform.d.ts","../../../node_modules/@metamask/obs-store/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/MetaMaskInteractionProvider.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/MetaMaskKeyring.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.d.ts","../../base-controller/dist/types/BaseControllerV1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerClass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/RestrictedControllerMessenger.d.ts","../../base-controller/dist/types/ControllerMessenger.d.ts","../../base-controller/dist/types/BaseControllerV2.d.ts","../../base-controller/dist/types/index.d.ts","../../../node_modules/@metamask/browser-passworder/dist/index.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/personal-sign.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/sign-typed-data.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/encryption.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/utils.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/index.d.ts","../../../node_modules/@metamask/eth-simple-keyring/dist/simple-keyring.d.ts","../../../node_modules/@metamask/eth-simple-keyring/dist/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/base-types.d.ts","../../../node_modules/@metamask/keyring-api/dist/btc/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/btc/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/superstruct.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/contexts.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/EthKeyring.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/rpc.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/JsonRpcRequest.d.ts","../../../node_modules/@metamask/keyring-api/dist/KeyringClient.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../json-rpc-engine/src/JsonRpcEngine.ts","../../json-rpc-engine/src/createAsyncMiddleware.ts","../../json-rpc-engine/src/createScaffoldMiddleware.ts","../../json-rpc-engine/src/getUniqueId.ts","../../json-rpc-engine/src/idRemapMiddleware.ts","../../json-rpc-engine/src/mergeMiddleware.ts","../../json-rpc-engine/src/index.ts","../../../node_modules/@metamask/providers/dist/types/utils.d.ts","../../../node_modules/@metamask/providers/dist/types/BaseProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/EIP6963.d.ts","../../../node_modules/@metamask/providers/dist/types/StreamProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/extension-provider/createExternalExtensionProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/MetaMaskInpageProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/initializeInpageProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/shimWeb3.d.ts","../../../node_modules/@metamask/providers/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/KeyringSnapRpcClient.d.ts","../../../node_modules/@metamask/keyring-api/dist/rpc-handler.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/helpers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/structs.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/create-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/dialog.d.ts","../../../node_modules/@metamask/key-tree/dist/constants.d.cts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/modular.d.ts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/utils.d.ts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/curve.d.ts","../../../node_modules/@metamask/key-tree/dist/curves/ed25519.d.cts","../../../node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.cts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/weierstrass.d.ts","../../../node_modules/@metamask/key-tree/dist/curves/secp256k1.d.cts","../../../node_modules/@metamask/key-tree/dist/curves/curve.d.cts","../../../node_modules/@metamask/key-tree/dist/curves/index.d.cts","../../../node_modules/@metamask/key-tree/dist/utils.d.cts","../../../node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts","../../../node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts","../../../node_modules/@metamask/key-tree/dist/BIP44Node.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/index.d.cts","../../../node_modules/@metamask/key-tree/dist/index.d.cts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/caip.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/permissions.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-public-key.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip44-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-client-status.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-file.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Box.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Button.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Field.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Form.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/formatting/Bold.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/formatting/Italic.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/formatting/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Link.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/jsx-runtime.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/jsx-dev-runtime.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/validation.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/nodes.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/panel.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/button.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/form.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-interface-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-locale.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-accounts.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/notify.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/request-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/update-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/methods.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/provider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/global.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/cronjob.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/home-page.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/lifecycle.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/name-lookup.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/rpc-request.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/transaction.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/signature.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/user-input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/jsx.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/svg.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/snap-utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/index.d.ts","../../message-manager/dist/types/AbstractMessageManager.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/utils.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../message-manager/dist/types/PersonalMessageManager.d.ts","../../message-manager/dist/types/TypedMessageManager.d.ts","../../message-manager/dist/types/EncryptionPublicKeyManager.d.ts","../../message-manager/dist/types/DecryptMessageManager.d.ts","../../message-manager/dist/types/index.d.ts","../../../node_modules/async-mutex/lib/MutexInterface.d.ts","../../../node_modules/async-mutex/lib/Mutex.d.ts","../../../node_modules/async-mutex/lib/SemaphoreInterface.d.ts","../../../node_modules/async-mutex/lib/Semaphore.d.ts","../../../node_modules/async-mutex/lib/withTimeout.d.ts","../../../node_modules/async-mutex/lib/tryAcquire.d.ts","../../../node_modules/async-mutex/lib/errors.d.ts","../../../node_modules/async-mutex/lib/index.d.ts","../../../node_modules/ethereumjs-wallet/dist/hdkey.d.ts","../../../node_modules/ethereumjs-wallet/dist/thirdparty.d.ts","../../../node_modules/ethereumjs-wallet/dist/index.d.ts","../src/constants.ts","../src/KeyringController.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupSemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/diffLines.d.ts","../../../node_modules/jest-diff/build/printDiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","5b3cd03ae354ea96eff1f74d7c410fe4852e6382227e8b0ecf87ab5e3a5bbcd4","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"056097110efd16869ec118cedb44ecbac9a019576eee808d61304ca6d5cb2cbe","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"6fb8358e10ed92a7f515b7d79da3904c955a3ffd4e14aa9df6f0ea113041f1cf","affectsGlobalScope":true},"45c831238c6dac21c72da5f335747736a56a3847192bf03c84b958a7e9ec93e2","661a11d16ad2e3543a77c53bcd4017ee9a450f47ab7def3ab493a86eae4d550c",{"version":"8cdc646cec7819581ef343b83855b1bfe4fe674f2c84f4fb8dc90d82fb56bd3a","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","9dd56225cc2d8cb8fe5ceb0043ff386987637e12fecc6078896058a99deae284","2375ed4b439215aa3b6d0c6fd175c78a4384b30cb43cbadaecbf0a18954c98cb","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","41231da15bb5e3e806a8395bd15c7befd2ec90f9f4e3c9d0ae1356bccb76dbb0","fccfef201d057cb407fa515311bd608549bab6c7b8adcf8f2df31f5d3b796478",{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true},"5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"464762c6213566d072f1ced5e8e9a954785ec5e53883b7397198abb5ef5b8f71","affectsGlobalScope":true},"6387920dc3e18927335b086deec75bf8e50f879a5e273d32ee7bb7a55ba50572","9bba37424094688c4663c177a1379b229f919b8912889a472f32fdc5f08ddb4d","29a4be13b3a30d3e66667b75c58ec61fb2df8fa0422534fdee3cfb30c5dbf450","83366d901beda79d6eb37aaaf6ca248dcd88946302b2a7d975590783be51e88e","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","43ec77c369473e92e2ecebf0554a0fdaa9c256644a6070f28228dfcceec77351",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"95ed02bacb4502c985b69742ec82a4576d4ff4a6620ecc91593f611d502ae546","bf755525c4e6f85a970b98c4755d98e8aa1b6dbd83a5d8fcc57d3d497351b936","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"28084e15b63e6211769db2fe646d8bc5c4c6776321e0deffe2d12eefd52cb6b9","affectsGlobalScope":true},{"version":"aed37dabf86c99d6c8508700576ecede86688397bc12523541858705a0c737c2","affectsGlobalScope":true},"cc6ef5733d4ea6d2e06310a32dffd2c16418b467c5033d49cecc4f3a25de7497","94768454c3348b6ebe48e45fbad8c92e2bb7af4a35243edbe2b90823d0bd7f9a","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","84da3c28344e621fd1d591f2c09e9595292d2b70018da28a553268ac122597d4","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","6e191fea1db6e9e4fa828259cf489e820ec9170effff57fb081a2f3295db4722","aed943465fbce1efe49ee16b5ea409050f15cd8eaf116f6fadb64ef0772e7d95","70d08483a67bf7050dbedace398ef3fee9f436fcd60517c97c4c1e22e3c6f3e8","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"e933de8143e1d12dd51d89b398760fd5a9081896be366dad88a922d0b29f3c69","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b38d55d08708c2410a3039687db70b4a5bfa69fc4845617c313b5a10d9c5c637","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"a05e2d784c9be7051c4ac87a407c66d2106e23490c18c038bbd0712bde7602fd","affectsGlobalScope":true},{"version":"df90b9d0e9980762da8daf8adf6ffa0c853e76bfd269c377be0d07a9ad87acd2","affectsGlobalScope":true},"cf434b5c04792f62d6f4bdd5e2c8673f36e638e910333c172614d5def9b17f98","1d65d4798df9c2df008884035c41d3e67731f29db5ecb64cd7378797c7c53a2f","0faee6b555890a1cb106e2adc5d3ffd89545b1da894d474e9d436596d654998f","c6c01ea1c42508edf11a36d13b70f6e35774f74355ba5d358354d4a77cc67ea1","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"b0297b09e607bec9698cac7cf55463d6731406efb1161ee4d448293b47397c84","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","25139d6a726e0e19d9fc4fa3197367b4a82ec34a08a5ecf23963e142c202c0f3","e3328bffc8eab74665a4fe9c59d6f12f4c8570c3d858497e241eb37efe17dfcf","29389551e426a46421134b55182d6fcf5b143670998bf81db2619c1228235392","c18f7e16982695bdd04e3e183a327d116185f77f1a37b9b2e849d7d93269cd74","2cfb37011989c21dc70b91d521a2d5a4e0f18507f5f536b5dfe504edb15916e8","bb5e02df7aaec7a4ea642639a9963b24b8d9fd6798351f07d8c58616942fbcbf","299a899cb4d061f5d83843ec453e936e9659b2c435746823f90c40eddaef4745","d5610c0fd12870f644b0f42c1bcc4fa2295ac3e3ca01916bdb42c3bdc4c80c36","2c56a8e249b1f45dbdf973100cd37fe2ea68709573cf1fdf2e3052c593be68d8","3553da417ee7b07e388b13bd12a70a1c03e65a6132ba5427fe68f5b362373e6f","612358502042d351c227ba779fdcf6d875d827e424930e60297c533524e50668","d2b5be376ef162aa0c24a826e7dd2d77671a045c085e16d1c1276db4bdccbac7","c4138d8dcccedaff6621e009cf0a54a7bed2a5ad4c509a3513bccc4f417ef939","ad8747fe978dff3e80f4b12b48d37cc8dff11b61d04c035aefbc982ce21201ce","b154f789fd65298e1ba6cbba6944ea892d564c95f3d3700ed85baf8f80748473","c660265aedd7c5b236e2017e53095cb98da66200eb0e8d023b5bf713c36494e8","0efc36bf5c0daca6217fec7063359ccdab8c3a23bb405d25340fae22cf72d74f","5abff0c87d4f9c89715107042d4c73b68ef7a128759f451c8a0fc450cbaaf660","5a03308fbd1af441065149a84c692931bebc7e7735afc23be8684f4e10d3aa06","c787bf4f8f0abbf815cfbd348be41046f2b8f270be24fe7aa8a8fcdd2b7df8c2","e7a5191c663a3228f30104961d548b372e51c5936c01ffc8eddd262bb98d7d7c","43fdc9abe6f8640fda4cdc55a1ee5f666d3fce554277043df925c383137ddf69","f0b09665c9d52de465687fbd3cfb65111d3ffc59ae00c6f42654150f3db05518","72f8c078d06cff690e24ff2b0e118a9de2833dcebf7c53e762dcb505ddf36a68","9705efb0fd901180de84ca4dd11d86f87fd73f99d6a5660a664c048a7487e385","f9b9d0950fdfb90f57e3f045fe73dce7fa6e7921b37622fc12e64fcd90afbd0f","e61b36e7fde608f8bb4b9c973d81556553a715eaef42a181a16ddd7a28da4ac7","03b8389b222af729eae0fb3c33366dcbb1f5a0102ce319bf1d7d5ee987e59fd0","2bf6be7c04db280fdd9b786764f8650c23f9f4d533791cb25a11b25314b76a55","dbb5fc7edd36bfba95cc4dd564e4458276ced30eed18bc05fbda948b3fda8686","c2b556c7cff0dabce2e31cb373ac61c14d8ebc35f1086dff30b39e9ec5357d0d","f958af01131076e8af55d28c4835a51063226ab488ca8738fdee38aeef7d0d33","9f3797b01e3d83d4e4b875699ae984f380ca86aa0a0c9df43ac5bba1cb1f8b7b","752b15ad1b34887adeaa838fc55f5d4ca399026afd266d4ed4db0e3db02eae4e","778331eaea1093451e50be9844bd2b6937c3bb81b0b1ee700624c9774ecfcf2b","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","5c746f034288e6842dd1589b169dcfcc16c5ce5abbd928889ab67aea4fe0b501","92ce6dbbcc135cffd09a58e19fef34bf351391bec92c40d849e4e9997d475769","99e77d092fed72b6b8578d00c7af004f76e98b30ba99f1947535eb4c04a51676","5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","b5ef52a9f9083724decc5d060f0b34e3a480deed71c32d55ca16c214eb4cc928","5d3d7938b2d7d0a9f851276741327c2ae4c013e7eb420fc3f7caed3b79c8f37f","14df6b81e50a035e9e391558cf30a0420d03e2eb42c7db9c57f44b818e5d5179","f100912a3785eed4a3d29c12f5910b101af9353454de5ddba9b4d43456c56dd1","446439eacf81a163fd7dfc53b28f80deca3d13b250d67639739aa25aa4491090","98034cd285344125f7165a3bb68246d38ab35fabe7f6d6a7c8f80407d31f548d","06b4a23064991251512df4edc12341d5bc69a17b942da18372312d383c90eee7","0f898802705f9a534b537f1be6c57265080e0abd6993d935554c255e6d56cc1a","745efa7b6e27b7216cccede166a822b56acc41b10a8090966c8cf2c96239cb83","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","5615ccf831db2ffc82145243081ebdb60ea8e1005ee8f975d1c0c1401a9c894e","38682ed3630bb6ecdace80d5a9adc811fc20a419f1940446e306c3a020d083b9","cc182e6e4f691cd6f7bf7cb491247a4c7818f9f1cb2db1d45c65ff906e3f741b","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","e0eda929c6b9b628cdeb0e54cd3582cb97e64f28aab34612fc1431c545899584","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","b3d48529ae61dc27d0bfbfa2cb3e0dff8189644bd155bdf5df1e8e14669f7043","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","68cc8d6fcc2f270d7108f02f3ebc59480a54615be3e09a47e14527f349e9d53e","3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","277983d414aa99d78655186c3ee1e1c38c302e336aff1d77b47fcdc39d8273fe","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","6ab2a6257ae7bb05559841100c786c845fe465a90be7b904db9096c2fb14696b","e87de5e2e71fe0513d6fbd5951a5f8e35595243bbb88fe00b6b2d9383f62fe59","ebb4f551ea58b96443365f487e5c49396c4811dc51e2fd5c3c45928e93047278","7cd0fabd9e9ae5a8faabc2f70d6d9ddd89c65719a30917eacdae9049c16e8a16","bb665725dcc2e2406c572a63038791a7118802ebd947c0e76b0eb38ccd99926c","0c58b5a414a48f68bfea86556a22f505bac4ce0e67ddd5e40e387a4641ce2b78","13de2d120d9122bbff92dca664ebd180241a856d23e705598eb259621a838f0f","2d072cf71b05c374b0406736ae1f402f4ebac96fab8e9e4d6a2ea4d147b1c26e","1507881fb12592d860e8b731a79cccd5880a9e3a3fdb71c8eeb08987420f7c8d","63e64a301fdbb7fb0b58e81b282608594b700e1af51d509de949e88e711a70e8","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","50aa290ee8f3ba75c7a3653613ead6594e2e034a7627b249c9a400858cac79f5","9138338d4fff57ba42d57c7316ad1d055b72b90c9e1acbbfa6cfe16db201802a","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","863416d62eb7dfa12b63b23c112fd0831aa330816c39d64ca88898ebe5fd62a3","9325a5ce0f09132607e27e599b568e3a67f80ea932f6bbb08bdc1bb7727e11a3","6a8649609161e2794b383ba275b0a6cb4a072dde7b954648f83dc6cdf1bfe4a8","6d3101b183ea67ef606b93fe42127f30b2db5ac3b72c34ca9d6d8b00eb85d0f6","f5d7a36ff056cc314b0f61c89a03c4c36a24183b246e61d958e75e86521304cd","f961ddb0abe88c9815a81132cc9984f0294fd920174fccbdde73d156b8a4ab39","6c951235cbf3c324a20c0e2dfdd013d7b226b0c2a72dbd84925682a8d7199237","aba578ce97acb630b406ffb6ed31302dbd8d2ffcfd671194b1d8704825086e05","3a971ea3e36685b96f24fbd53a94ad8dc061711b84e51fde4cf201f7041e618d","77234d8682b67d78748cb61a63407104dc2c8e3196dcf15a454aae26b42f3ee7","c8be9283a381044a392a0687af5d98d3f51cbada2320b1801a82c948b6e39499","d5cdc145bf5ec321674e31804c075ad408a68c86877ce293970e03634d3709f1","85052c71d72b9b017c88179f57a464d66e22619c7acd7d83b117a79cf1608979","9b6c162d20e2ad4abdcff61a24082564ac59e63092220618162aef6e440c9228","b0874729266d9f7fafb9ff1127fcbad2cf7972b5dcc1fdc104be79266a708bc2","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","e9d61a89974e5d8231edab199fe1a5f912a344febc74146611c013435f906de3","813e6dc3098dc7b331ed17bb4a3f96cda83748e989a41c469160ef23776af0f4","3c0913724967da385abf69e4f50dc51d5de5ad7c13d8bedd6746063aab7dd6e0","1fdd00179cddca98c8cfa1c403016f6703a8c34858cfeda33769d86da188ff8d","47ca123995420c8579f010179d3d5e61399ce538fc6386f2438193d48c0013b9","599d6ebec95d21df7ee33d8eb8f0b791ffac4a32026f32cf91fdf417153be473","323a75e01c89a50bb8827d1d624e72c20b0d81d4647a30ee6a695dbb4d76f3b5","d1f010c19eb9c8190bd0859fa3b6f4975543b912b8b85e20bbb0b5bfbdf4d2b3","de4ccc96cef3f97fab148640799abb32a24b567a902a8233913f98481e3131bf",{"version":"801934aa449fe6df584bccdcc5d5b9280295cb7ac84918b6014fc5086e6f9ff6","affectsGlobalScope":true},"6af760fb9ea02dc807c5053d8aee86389c4fce72fbb26af7b9568cac6c4710d5","c62c4ba5e910b4523f7e7adf4a55ec45c2bac99d9d8e9b0fe0c2a800a6f641b9","92131434f876fdd6fcbc40bd54a9d7500c66974362b16bd42641f990468587f4","8cf023c0bd57992fdd2ce6a7030a1874f49c8edc62eaffa9bfffcf18d2a2a1a2","8ea8f3040e38fb50d7dc3653f3b8a0dbb5244e82111576f99ce096bdc0fbf94c","48ed788ad126545a6156fcc37cd3bcf17de18a3e3fe6b6ef62cfb8140d1a45a2","63c271a745f628ffd4bd7ad0a63b021c362c9bd6bf8b18441a7162892395a214","a867ba47f71fe3993cef54246893ff8f01411e12e411d8cf1bd038a448b36404","6a8096993458a3d71229031aa7415974eb5b47b320213e29660adfb519d6a3f4","cb7996a1af5b1d276483cd0c9b9de6540eff021abc90a720511ff4464519a2ff","9df6ec68878d65bc690ea3a33ce3ef5aa8254c36bc5f8346c0c2fd1f3b88a35c","a4fad04c4acc8a4b195cbbccef4c55019104753d547d5c94441643ccc89108a0","0244c23ea642361f7c192c1f0cfff9c12cfa5f51f9b155edd5c0a89fef308d34","ac5da520487547013c3abae0933d6366f51db6df31d1993ddb931ce04b083269","3c69a83bde847af6fc3a53e1bb6b13cd06d38a27a142814b8dacc374f3b93284","5b46f7113f54565e7ffc83f2b474f557a1f54c7e5946769d5be220454656be73","fb58035d39c5759283cb73cfb3548aefe370aa3ad4e81fdb4e46f0979eb7669f","1311c325948b2d5576cebc70b1bf968d3446b4630802bef54120daf04ce1f625","d0b3609e8e7afed0fd0570152255458407e67249b94f6603afdfd68599423f21","17f4c5a1d6eaa87ea27eadcdff9085af3190533d98f799dda79a3af6f9a630ea","3e6f734ddf40e2e99ff7fff9568b7d9720663af9a0632c26a352c8d3270a3f0e","ec13f78303abcf550c5569dfae1446b8ceb89050f68ce04491481e72e8122ae2","a3fc57dbaa7f1efb010399ad4ef4fd9b462aa4e93bf74a9a34b099b97ffcc9cb","ffddd7ec6a450b0cb6f2f73f80de1df963ead312d7c81a8440268f34146ecb87","5d6a36ca0087fd6876df654d1b4192f0e402adfde994ad47e5c065da33692f9c","eb157a09c5f543d98644e2a99a785f9e0e91f054f9fecbf1c3e15831ff5d63a7","edd5530e2b1ccdf65093296e40a8634fcb11ecda3c164c31383a8c34cb04bc9d","9dfaf96d090fe8d96143465d85b4837661ae535143eea9ef99cd20df2e66338e","209d45c27e03c1417c42985252de6c25a2ec23abdc199d88e6139c88b93abd11","0ee5cdba58cfde3012bb9ff2e9edcc4e35a651373a2aa2c83ff9eb7df635419a","540f4dca27ea5a232828b6d91e1b2fce2720bdabaa4c1f3fbf59b672cc58bd8a","ba086b99d545ec6c9ff356989f076b5652ea1b09bcc65b87dfc43a5195a2efcc","c85d9776b36166b928ab1488d9224ebf970d41b0a35f09a3ee0b9bee3e698061","683196f606c5dab1c8c4a24a66d26e00f16f2d4b2a5abe25ebedd37d2954f930","9c3a1b01cba1238fb723ce06b6c163ef6c53be755394406782564d5c42c636b2","6e795e6270d39e918c7a0e62ac73793cda06fcf4b3692ee46583e15f5bf57ab8","0e821ef1eb67fa6144ea4de4277d913f5b1982d7407afd5f93754a8239d41554","5c09195ef359ffa9c6bbdb4fefb101d87ede4b9e9c28213faf5b45d102e4c609","80b4d93a4dcc90a12f6f4bb7c6851a8182ae29e556716d0d80b5c012a5ef554a","2556ef9d1820e0b6bbca6dd65a50ea64f525c4d8247ab50dff44c3f0d14a5643","cbd1c836db190d6e3add07165afc228f04e1f6170e1fe3aa5e6fc24a7e9573a3","9b13881feb958237232586d888a10a39d47cdffe3ee34688ed41888fa7baad94","122fe82cf5af80f0b26832b258b537b7dfe3ec28449c301b259ab10204b50d45","c467dada8fea6d60dff8a8be2675f737cacc76e14e50b72daa0f0710376df84b","9cb80bba611c2dd155a446ce424fe4bb1df2129751bc9416b7e42c055d1ddbff","44f41abb29bf3f4c52270d8119a96c935131e42a9186da15216a76b35e793b4e","043783bebe87efb440183c9ebc8c4fdc1bb92060a5a0f7ce847e30dee7013ac3","e3dc0a97a59dea936b4fb7b1f6f4117b4aac9c86d0cd08b69bab2d0532a8a5e3","5d897601f8a4fe913057019d8211b99b06e3138f625a0cfb601d074f4278271d","cfde5d194dd858ad68f910defaed5b0d28730f8bf38359a9265a93ab29bc7bef","16b21bbe6ad41019c071677877b8fc5dbc8d39a8b0406f020261c5f6f3894be3","f20aae41b169cddcbf3fde8ac380443182c8d7225194e788c404d9e11e6dc75d","87fd9a98cb1e689320ab89adc65e85d140a61260b4f66d12c777f4bd7cae2060","c48566cb13403fca44192b4528e3f2ac993869d39526bd42cd2f2167c0285add","efae20e0c581240c7522e04829da4f0453ca263068596554d4b0e27878c7dfac","3af68ef927788cda7daab34be513fa4508229fdc6e5130d564a0a1ccb3fefafe","bbbd2cbb15a37d5f4dd54ad8c7c537d3df8352117523030fcec7dcbe62a05a58","b50d24ebc117f8805332e7e260e9587f572bb7b2ff0ca1ff6cfafb38015781f3","5cc8b8e18fe7fefab4b3c53a39467b5a0deb4200abae7f063ff0624b9e856c51","8e990781eb0107c25429b1274a31a4f3866a9a46290cce40f354b2a6e71c6c21","8616706e4bd72987bd86c1b4afafa90fa2d4ef2f71708de03a823ab4e9b48e60","b9ce4613536386a98897f1e3d8f61a851ce6cb34dc3c9db4f2ef5f55f007e9e1","77fe56751d7615743937268c72d797fba28309f13ec9079c018b232040fca86a","31b5f53e3d57470830e87f9e03c02d4569ac81d4a758fdda75092f9a3f58beba","d765fbab22fd7003a65ed670100362ec1c90d55a772e6773a774135594e7ea41","1bf86149ef215f258d479695aa35ac89a3d34a6356a6df04e1b5db869289e563","58f4da9e99a4bdbd2f54eeb9303d5b5634b25423d729d44abb3fc55c925495b3","f75cd30f162c2af5e5aca39c01c1a521bfa034fae523793de872815a3468bc08","0cf1123db73dabd86466a462375a6addae52f58d23030c6033f8aadc23539a36","e29cef4158591ed213b1c2cba8988237b1ff369f7a6ecd8cb8ac0302bad1fba8","5307876e4d0021ea01235eb2f7c24671f3d8b37590f4b446cd132a4e1dc9a335","92550acd737790dc60c4c130e6aac78656dd48a8334a4882f40e7f86bdf7a590","3df821880914f8bb3c8107b1107be75c8ddbe2120a2cefabbaf9b65936b5f4dd","20626e4260b7d621745b2e78e883d9de7cc94ec346ef13344dd96eb479813870","078b7043bea0968860374bf4671ed74dd9f6be4e28ab659517d81f74be463c51","68b139ebb9a7f3ee4ded6286d74f978a47968727665120f3bfc560476ce33c4d","56d02c29b2fd39b1b1a1265df291f3f98e6ec3e6119aff9f4cfa44fe888efaa7","2d01884891da6495cb4a2f060e4898209a507e711464c4c1480df85264e863ed","620eb3b3aafe33839ee0f50e2cb237450f066fd88c8367cd15d75d02f7c9146f","6a5a3a7ae4e448668f8986632d2b6adfeebfdc06b0f9256f35c10ec148fa01f0","080b1aa93227952b4dd74b9d2c6e4f6002eb8403533749116a1c53bb9961c02d","874087eec1d457f6e3baf5ac46c42ea200e55040b394fac667aa3a64c49f5f6c","6e8a5b04a18abb192abc89d7219b9c6f633cb3136777ec808673a65f111ca749","6db505486e882a6688c5525cb65f6f06d3c5f16f03f329fbdec01dd379c97f96","d74d2a92b54f95e47d2b76bd5ee516aab7ae93afb79cd34c6681dd29eb09e72a","747e6326a724bc54f799a466a5b5c4978a601a04a063a5bdabe150af2f25b9e2","b57e22e53b56cca7a57bfcfb234aa6a66f9b9e4c07159d7388f94f17a3eaee2c","e47709ec4d1618ef429648cd8ef967aef2005526b34fcbfac33037add347dc71","b81abb3e47fbbb3af41fa75bada89bbcfa4b0feed9a0d6d4b19ed1ce1033b53c","15b330546e9784461058e5fd6e2346bf272140fa6f0cda34e193ae501d8b17b1","4d8ce72fd080bf9a46bdcc274bcbacccedd66d84e203966b197ac25a96932183","73327e6ae34e3f6591877fb75b451cf620cbbd76ee2b678213a9f793633cd0d3","3f1ba2f69944fa346789db7f60d53c9bec00032de0d797967978dea42e77b941","3f5df31539fee4816b97d4e45b4344fbdaf3ca59f6df941f8d780ee441e92cc1","50aaf44eb4d0e086af13729b3471a0a7dce95ea35ebd21c762ba26e203134b2e","3857c1773b8503c3ca45b7bc09ac89c3930c85ce93021054503f73d5d9101b5c","72702bd07fd6fb3ef64aadbcb909103aadfe71ee76e9fdeb11e0c92693cff6cb","f0dd6f7c9783637655478db7d7caf6becd41a79d54482aa59578ce88ab38e9bf",{"version":"cd756ccdabf433dd02b84d755383e489f14b3c1aede0477783aa04830fd5d695","affectsGlobalScope":true},"a4c88dbecdf8ee0c79f5b7c2bf31cd77e593f5d78384e2b674f67d754a549a9e","9cbdff04326da794ba008c0fc977ab062d1fe3fa2e9759654c72ffbe54b64a7c","aa60f8d20d36116fe05edaab24adee3c275209f71b65e272692cf99daf9489e1","150855f967a6490161d5aeed4cc4adf31fcb8f5dbe54b75799c12b8687fc9cc2","cf08b7139adc21b94204e3d4b3daf9946e3462a9e3fdc3e94c87e767e7936e20","47ddb601df40bfa01cebdd06ee8b87d0b72aa1259a4ceba3ad3b5cf68130112a","6b6392704ddb3f50e647dbbb716782bdd0cf8ea9cc134aae256a26223e632b47","afc3ad2a50f7f4de908e26fcf467e09ab8528c0e90f91e602b4865d953839228","df90b0c6b1d81851364c4d97fa23b91a993482bcf4a7bed7c7a24aa41632d494","03c0bc80f67c6f75b02341fbeb9f6ee92c66b90597729377f478885e6ad15a88","11ee9ab699b4619d217c640d917ca198f58066a86bd58c2917197d62aa6601e0","cf9d589d9e73bf32c8e7a6cae6b4a1cf9bef39e5594072533fdce985581a6ddc","959544feb1ca2df29eec6c500f27ea10f4885df245ebd8418fb4b87914614383","6548ab4b57eb9d092471a04513091673345f2fd95d5b876f600402ea8d603ee0","2793e8c6a023d26f78d6777a6d7f20fae3a9a8169863d46d8d54c73071851232","d0f11e830aa1350a31d9c00a0197243e9711e4882947aef53a96c629f405cb10","6610b9f45f1f71d2b1fb67df49cbcabe3f9e668a1ccb7d8328a51407b259ffb3","abbcc437e0792ab2fe08797ceca1ec85a95ec413c51612313b18ab8e75f690f6","e29d76ef1183ac0edf94b4712b6e51730c447c7e773e75ceb44a720b0c9a9fd9","4ee6dc3424998eede9a2a9b114acaaf7969cdda67baf82ba2c9cf88a8eec0ab1","26958d6f77e6db2425ca65df0fbfaba439396ef7f4457f5643fc32e4b62568a6","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","89b040dec8fcfc1de98827e1f4d4977e6ff5d3302c6790e9f10b54b916e1c742","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","299567f84bfedd1468dca2755a829cb19e607a6811673788807dc8921e211bc9","795d9fb85aad92221504db74dd179b506bd189bba0c104426f7e7bb8a66ffee5","1311bc194e0a69fe61031e852c1c0b439e2a2a3d1d5e2d8ff795499b9f283459","4b7ce19369d7e7fae76720c2c6c7f671bf3fa0f7093edb864f1ac358ca7c456c","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","30285a1011c6d6b52f3ba3abb0a984be8148c05cdefb8eb6eb562335a3991f35","e0de9f50e80fed1cc161b50e8e68dc056e38df75a4ef667a06b1922e372de169","6a8b31be08b212d1fc96de0ddd1ea49f32382ba712fea24c70bb56447f643f82","19ac6d624e4c18de4584db4bbdbc55387dbe3d19b3c134e50346bdf165658a17","54e3798c2801e8f3bc7a825d3d26c6a80ce763e19e6cb0b714594c430ef72332","70b8333214aadaccda8d38435911d3e3a686e503837dfda6b8c3f8c83e05729b","f3815045e126ec1b9d224782805a915ae01876a1c7d1eb9b3e320ffadbd63535","d07557f21b2ad690bfe37864aa28090bd7d01c7152b77938d92d97c8419c7144","b843ea5227a9873512aa1226b546a7e52ea5e922b89461f8b202a2f2a3f0b013","64b4d440f905da272e0568224ef8d62c5cd730755c6d453043f2e606e060ec5a","d6b58d955981bc1742501b792f1ab9f4cba0c4611f28dcf1c99376c1c33c9f9c","f0b9f6d5db82c3d1679f71b187c4451dbc2875ba734ce416a4804ad47390970a","a5c38939c3e22954a7166d80ab931ac6757283737b000f1e6dc924c6f4402b88","31a863da9da2a3edec16665695bdbc3134e853195f82dafec58e98c8e1bb3119","b382a659f417df3606f2fbd2d39a02f0aa81d846cd361e79656e135a7896b779","af21e37363b40696508be1e0f1189664d17bc215ac5e64c05f7eb086a6f2ea72","df470b1c65fc51db9486ced8ff89d19c5fa2cfc5c6b3eb32d6cbab354499801e",{"version":"a6703b8328a763c5148eddf07c5801c4b67de507bc25459532d0c0c6622d11c2","signature":"68260f4ebe8f11c39b1d43d6ea75d76da4e81e2965414db9b3bd5ef2a21cdf0e"},{"version":"47b156c2b6951459da66a7dad60da07fee0f3f5e15096362e01fb2c67b99f641","signature":"acf1e448964971d594529ec272a231c39326bafde595da38cd0797266d3b446f"},"40d81f5f052d5954b51f4f5ec258a2231cdba79232e823ba93dc6dce2af4a7ff","4489c6a9fde8934733aa7df6f7911461ee6e9e4ad092736bd416f6b2cc20b2c6","2c8e55457aaf4902941dfdba4061935922e8ee6e120539c9801cd7b400fae050","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","9d38964b57191567a14b396422c87488cecd48f405c642daa734159875ee81d9","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9","8c95f96ccd4be0674944077aec1e4f2cccd515ca06d4327562dd017250e7d3fc",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","bc3cba7b0af2d52e7425299aee518db479d44004eff6fbbd206d1ee7e5ec3fb5","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","b8442e9db28157344d1bc5d8a5a256f1692de213f0c0ddeb84359834015a008c","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","6f294731b495c65ecf46a5694f0082954b961cf05463bea823f8014098eaffa0","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","68a0d0c508e1b6d8d23a519a8a0a3303dc5baa4849ca049f21e5bad41945e3fc","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","4f6a12044ee6f458db11964153830abbc499e73d065c51c329ec97407f4b13dd","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","254d9fb8c872d73d34594be8a200fd7311dbfa10a4116bfc465fba408052f2b3","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","2ccea88888048bbfcacbc9531a5596ea48a3e7dcd0a25f531a81bb717903ba4f","d8f7109e14f20eb735225a62fd3f8366da1a8349e90331cdad57f4b04caf6c5a","cf3d384d082b933d987c4e2fe7bfb8710adfd9dc8155190056ed6695a25a559e","9871b7ee672bc16c78833bdab3052615834b08375cb144e4d2cba74473f4a589","c863198dae89420f3c552b5a03da6ed6d0acfa3807a64772b895db624b0de707","8b03a5e327d7db67112ebbc93b4f744133eda2c1743dbb0a990c61a8007823ef","86c73f2ee1752bac8eeeece234fd05dfcf0637a4fbd8032e4f5f43102faa8eec","42fad1f540271e35ca37cecda12c4ce2eef27f0f5cf0f8dd761d723c744d3159","ff3743a5de32bee10906aff63d1de726f6a7fd6ee2da4b8229054dfa69de2c34","83acd370f7f84f203e71ebba33ba61b7f1291ca027d7f9a662c6307d74e4ac22","1445cec898f90bdd18b2949b9590b3c012f5b7e1804e6e329fb0fe053946d5ec","0e5318ec2275d8da858b541920d9306650ae6ac8012f0e872fe66eb50321a669","cf530297c3fb3a92ec9591dd4fa229d58b5981e45fe6702a0bd2bea53a5e59be","c1f6f7d08d42148ddfe164d36d7aba91f467dbcb3caa715966ff95f55048b3a4","f4e9bf9103191ef3b3612d3ec0044ca4044ca5be27711fe648ada06fad4bcc85","0c1ee27b8f6a00097c2d6d91a21ee4d096ab52c1e28350f6362542b55380059a","7677d5b0db9e020d3017720f853ba18f415219fb3a9597343b1b1012cfd699f7","bc1c6bc119c1784b1a2be6d9c47addec0d83ef0d52c8fbe1f14a51b4dfffc675","52cf2ce99c2a23de70225e252e9822a22b4e0adb82643ab0b710858810e00bf1","770625067bb27a20b9826255a8d47b6b5b0a2d3dfcbd21f89904c731f671ba77","d1ed6765f4d7906a05968fb5cd6d1db8afa14dbe512a4884e8ea5c0f5e142c80","799c0f1b07c092626cf1efd71d459997635911bb5f7fc1196efe449bba87e965","2a184e4462b9914a30b1b5c41cf80c6d3428f17b20d3afb711fff3f0644001fd","9eabde32a3aa5d80de34af2c2206cdc3ee094c6504a8d0c2d6d20c7c179503cc","397c8051b6cfcb48aa22656f0faca2553c5f56187262135162ee79d2b2f6c966","a8ead142e0c87dcd5dc130eba1f8eeed506b08952d905c47621dc2f583b1bff9","a02f10ea5f73130efca046429254a4e3c06b5475baecc8f7b99a0014731be8b3","c2576a4083232b0e2d9bd06875dd43d371dee2e090325a9eac0133fd5650c1cb","4c9a0564bb317349de6a24eb4efea8bb79898fa72ad63a1809165f5bd42970dd","f40ac11d8859092d20f953aae14ba967282c3bb056431a37fced1866ec7a2681","cc11e9e79d4746cc59e0e17473a59d6f104692fd0eeea1bdb2e206eabed83b03","b444a410d34fb5e98aa5ee2b381362044f4884652e8bc8a11c8fe14bbd85518e","c35808c1f5e16d2c571aa65067e3cb95afeff843b259ecfa2fc107a9519b5392","14d5dc055143e941c8743c6a21fa459f961cbc3deedf1bfe47b11587ca4b3ef5","a3ad4e1fc542751005267d50a6298e6765928c0c3a8dce1572f2ba6ca518661c","f237e7c97a3a89f4591afd49ecb3bd8d14f51a1c4adc8fcae3430febedff5eb6","3ffdfbec93b7aed71082af62b8c3e0cc71261cc68d796665faa1e91604fbae8f","662201f943ed45b1ad600d03a90dffe20841e725203ced8b708c91fcd7f9379a","c9ef74c64ed051ea5b958621e7fb853fe3b56e8787c1587aefc6ea988b3c7e79","2462ccfac5f3375794b861abaa81da380f1bbd9401de59ffa43119a0b644253d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","7d8ddf0f021c53099e34ee831a06c394d50371816caa98684812f089b4c6b3d4","7d2a0ba1297be385a89b5515b88cd31b4a1eeef5236f710166dc1b36b1741e1b","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e","bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","ae271d475b632ce7b03fea6d9cf6da72439e57a109672671cbc79f54e1386938"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[434],[72,108,109,110,125],[109,110,126,127],[108,109],[108,125,128,131],[108,128,131,132],[129,130,131,133,134],[108,131],[108,125,128,129,130,133],[108,116],[108],[72,108],[60,108],[112,113,114,115,116,117,118,119,120,121,122,123,124],[108,114,115],[108,114,116],[108,135,172,173],[172],[173,174],[108,167],[167,168,169,170,171],[108,139,146,147],[108,139,146,147,167],[108,139,146,147,151],[108,139,146,147,148,150,151],[108,139,146,147,149],[108,139,146,147,152,153,155,156],[145,167],[137,146,147,152,153],[139,145,146],[108,139,146,147,152],[108,139,146,147,150],[108,139,146,147,163],[108,139,146,147,164],[111,136,139,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166],[137],[137,138],[72,108,172,175,184],[175,185],[185,186],[242,243,244,245],[108,125],[247],[135,219,246],[300,309,310,313],[300,309,312],[300,309,311,313],[301,304,305,307],[301,302,303],[304,305,307,308],[301,302,306],[312,318],[300,309,312,318],[309,312,318],[309,312,314,315,316,317],[300,309,310,311,312,313,318],[300,309],[301],[196,219,252],[219,266,268],[219,268,269,290],[196,219,249,251,252,265],[196,219],[250],[253],[196,252],[254,255,264],[263],[251,252,257,263,265,266,267,269,291,292,402],[196,219,403],[219,257,265],[258],[256,259,260,261,262],[196,219,250,252,255],[219,267,401],[190,196],[179],[178],[108,177,179],[179,180,181,182,183],[108,177],[178,219,281,282],[283],[108,177,219,283,285],[108,177,178,219,281,283],[285],[282,283,284,285,286,287,288,289],[108,177,284,287],[282,287],[219,281],[219,270],[270,271],[270,271,272,273],[219],[108,219,293],[219,398],[367],[219,293,367,395,398,399,400],[108,219,274,293],[294,295,296,297,396,397],[190,196,395],[190,196,296],[328],[328,340],[328,329,342,344],[328,340,343],[328,334],[328,333,335],[333,334,335,336],[338,339],[329,330,331,332,337,340,341,342,343,344,345,346],[328,347,348,349,350],[328,347,398],[382],[395],[385,386,387,388,389,390,391,392,393],[219,320],[367,391,398],[320,395,398],[196],[320,321,368,371,381,382,383,394],[196,351,367],[395,398],[319,321],[321],[398],[368],[219,371],[298,299,322,323,324,325,326,327,369,370,372,373,374,375,376,377,378,379,380],[219,373],[298,299,322,323,324,325,326,327,369,370,372,373,374,375,376,377,378,379,398],[219,319,320],[290,381],[219,321],[365],[196,352],[353,354,355,356,357,358,359,360,361,362,363,364],[352,365,366],[199],[196,199],[197,198,199,200,201,202,203,204,205,206,207,208,211,212,213,214,215,216,217,218],[190,196,197],[135,199,205,207],[210],[199,200],[196,214],[108,142],[140,141,144],[140,143],[108,140],[410,411],[434,435,436,437,438],[434,436],[209],[441,442,443],[73,108],[446],[447],[458],[452,457],[461,463,464,465,466,467,468,469,470,471,472,473],[461,462,464,465,466,467,468,469,470,471,472,473],[462,463,464,465,466,467,468,469,470,471,472,473],[461,462,463,465,466,467,468,469,470,471,472,473],[461,462,463,464,466,467,468,469,470,471,472,473],[461,462,463,464,465,467,468,469,470,471,472,473],[461,462,463,464,465,466,468,469,470,471,472,473],[461,462,463,464,465,466,467,469,470,471,472,473],[461,462,463,464,465,466,467,468,470,471,472,473],[461,462,463,464,465,466,467,468,469,471,472,473],[461,462,463,464,465,466,467,468,469,470,472,473],[461,462,463,464,465,466,467,468,469,470,471,473],[461,462,463,464,465,466,467,468,469,470,471,472],[56],[59],[60,65,92],[61,72,73,80,89,100],[61,62,72,80],[63,101],[64,65,73,81],[65,89,97],[66,68,72,80],[67],[68,69],[72],[71,72],[59,72],[72,73,74,89,100],[72,73,74,89],[72,75,80,89,100],[72,73,75,76,80,89,97,100],[75,77,89,97,100],[56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107],[72,78],[79,100,105],[68,72,80,89],[81],[82],[59,83],[84,99,105],[85],[86],[72,87],[87,88,101,103],[60,72,89,90,91],[60,89,91],[89,90],[92],[93],[72,95,96],[95,96],[65,80,89,97],[98],[80,99],[60,75,86,100],[65,101],[89,102],[103],[104],[60,65,72,74,83,89,100,103,105],[89,106],[108,176],[480,519],[480,504,519],[519],[480],[480,505,519],[480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518],[505,519],[520],[524],[420],[422],[420,421,422,423,424,425,426],[420,422],[108,430],[108,428,429],[430],[231],[231,232,233,234,235],[220,221,222,223,224,225,226,227,228,229,230],[450,453],[450,453,454,455],[452],[449,456],[451],[189,191,192,193,194,195],[189,190],[191],[190,191],[189,191],[219,236,237,238],[237],[238],[188,237,238,239],[405],[405,406,409,413],[412],[219,407,408],[178,219,274],[219,275],[219,275,278],[275,276,277,278,279,280],[48,49,125,135,187,219,236,240,241,246,403,419,427,430,431],[432],[72,108,219,240],[404],[404,414],[404,415,416,417,418],[135,187,219,236,240,241,403,419]],"referencedMap":[[436,1],[126,2],[128,3],[110,4],[132,5],[133,6],[129,6],[135,7],[130,6],[134,8],[131,9],[117,10],[114,11],[121,12],[115,10],[112,13],[125,14],[119,11],[116,15],[118,16],[174,17],[173,18],[175,19],[170,20],[168,20],[169,20],[172,21],[154,22],[159,23],[148,22],[153,24],[152,25],[150,26],[157,27],[158,22],[160,28],[155,29],[147,30],[161,31],[163,32],[164,33],[165,34],[167,35],[138,36],[139,37],[185,38],[186,39],[187,40],[246,41],[242,42],[243,11],[245,42],[248,43],[247,44],[311,45],[313,46],[312,47],[308,48],[304,49],[305,49],[309,50],[307,51],[314,52],[315,53],[316,54],[318,55],[317,52],[319,56],[310,57],[303,58],[306,49],[268,59],[269,60],[291,61],[266,62],[249,63],[251,64],[250,63],[254,65],[253,66],[265,67],[255,63],[264,68],[403,69],[256,70],[258,71],[259,72],[260,63],[263,73],[262,74],[292,60],[402,75],[252,76],[181,77],[182,77],[179,78],[180,79],[184,80],[183,81],[283,82],[284,83],[287,84],[285,85],[286,86],[290,87],[288,88],[289,89],[282,90],[271,91],[272,92],[274,93],[270,94],[178,12],[399,95],[293,96],[400,97],[401,98],[294,99],[295,94],[296,94],[398,100],[396,101],[297,102],[328,94],[329,103],[330,103],[331,103],[332,103],[341,103],[342,103],[343,104],[345,105],[346,103],[344,106],[333,103],[335,107],[336,108],[334,103],[337,109],[338,103],[339,103],[340,110],[347,111],[351,112],[349,103],[348,103],[350,113],[383,114],[385,94],[386,115],[394,116],[387,94],[388,94],[389,117],[390,94],[392,118],[391,119],[393,120],[395,121],[368,122],[298,115],[299,123],[322,124],[323,125],[324,124],[326,94],[327,126],[369,127],[372,128],[381,129],[374,130],[373,94],[375,94],[376,96],[380,131],[377,126],[378,128],[379,115],[321,132],[382,133],[371,134],[366,135],[353,136],[362,136],[354,136],[355,136],[364,136],[356,136],[357,136],[365,137],[363,136],[358,136],[361,136],[359,136],[360,136],[367,138],[352,120],[197,120],[198,120],[200,139],[201,120],[202,120],[203,140],[199,120],[219,141],[207,142],[208,143],[211,144],[217,145],[218,146],[143,147],[142,11],[145,148],[140,11],[144,149],[141,150],[412,151],[439,152],[435,1],[437,153],[438,1],[408,11],[210,154],[444,155],[445,156],[447,157],[448,158],[459,159],[458,160],[462,161],[463,162],[461,163],[464,164],[465,165],[466,166],[467,167],[468,168],[469,169],[470,170],[471,171],[472,172],[473,173],[56,174],[57,174],[59,175],[60,176],[61,177],[62,178],[63,179],[64,180],[65,181],[66,182],[67,183],[68,184],[69,184],[70,185],[71,186],[72,187],[73,188],[74,189],[75,190],[76,191],[77,192],[108,193],[78,194],[79,195],[80,196],[81,197],[82,198],[83,199],[84,200],[85,201],[86,202],[87,203],[88,204],[89,205],[91,206],[90,207],[92,208],[93,209],[95,210],[96,211],[97,212],[98,213],[99,214],[100,215],[101,216],[102,217],[103,218],[104,219],[105,220],[106,221],[476,11],[177,222],[479,11],[504,223],[505,224],[480,225],[483,225],[502,223],[503,223],[493,223],[492,226],[490,223],[485,223],[498,223],[496,223],[500,223],[484,223],[497,223],[501,223],[486,223],[487,223],[499,223],[481,223],[488,223],[489,223],[491,223],[495,223],[506,227],[494,223],[482,223],[519,228],[513,227],[515,229],[514,227],[507,227],[508,227],[510,227],[512,227],[516,229],[517,229],[509,229],[511,229],[521,230],[525,231],[421,232],[423,233],[427,234],[425,235],[424,235],[428,236],[430,237],[429,238],[227,239],[229,239],[228,239],[226,239],[236,240],[231,241],[222,239],[223,239],[224,239],[225,239],[454,242],[456,243],[455,242],[453,244],[457,245],[452,246],[196,247],[191,248],[192,249],[193,249],[194,250],[195,250],[190,251],[239,252],[238,253],[237,254],[240,255],[406,256],[414,257],[413,258],[409,259],[275,260],[276,261],[277,261],[279,262],[281,263],[280,261],[432,264],[433,265],[404,266],[418,267],[417,267],[415,268],[416,267],[419,269]],"exportedModulesMap":[[436,1],[126,2],[128,3],[110,4],[132,5],[133,6],[129,6],[135,7],[130,6],[134,8],[131,9],[117,10],[114,11],[121,12],[115,10],[112,13],[125,14],[119,11],[116,15],[118,16],[174,17],[173,18],[175,19],[170,20],[168,20],[169,20],[172,21],[154,22],[159,23],[148,22],[153,24],[152,25],[150,26],[157,27],[158,22],[160,28],[155,29],[147,30],[161,31],[163,32],[164,33],[165,34],[167,35],[138,36],[139,37],[185,38],[186,39],[187,40],[246,41],[242,42],[243,11],[245,42],[248,43],[247,44],[311,45],[313,46],[312,47],[308,48],[304,49],[305,49],[309,50],[307,51],[314,52],[315,53],[316,54],[318,55],[317,52],[319,56],[310,57],[303,58],[306,49],[268,59],[269,60],[291,61],[266,62],[249,63],[251,64],[250,63],[254,65],[253,66],[265,67],[255,63],[264,68],[403,69],[256,70],[258,71],[259,72],[260,63],[263,73],[262,74],[292,60],[402,75],[252,76],[181,77],[182,77],[179,78],[180,79],[184,80],[183,81],[283,82],[284,83],[287,84],[285,85],[286,86],[290,87],[288,88],[289,89],[282,90],[271,91],[272,92],[274,93],[270,94],[178,12],[399,95],[293,96],[400,97],[401,98],[294,99],[295,94],[296,94],[398,100],[396,101],[297,102],[328,94],[329,103],[330,103],[331,103],[332,103],[341,103],[342,103],[343,104],[345,105],[346,103],[344,106],[333,103],[335,107],[336,108],[334,103],[337,109],[338,103],[339,103],[340,110],[347,111],[351,112],[349,103],[348,103],[350,113],[383,114],[385,94],[386,115],[394,116],[387,94],[388,94],[389,117],[390,94],[392,118],[391,119],[393,120],[395,121],[368,122],[298,115],[299,123],[322,124],[323,125],[324,124],[326,94],[327,126],[369,127],[372,128],[381,129],[374,130],[373,94],[375,94],[376,96],[380,131],[377,126],[378,128],[379,115],[321,132],[382,133],[371,134],[366,135],[353,136],[362,136],[354,136],[355,136],[364,136],[356,136],[357,136],[365,137],[363,136],[358,136],[361,136],[359,136],[360,136],[367,138],[352,120],[197,120],[198,120],[200,139],[201,120],[202,120],[203,140],[199,120],[219,141],[207,142],[208,143],[211,144],[217,145],[218,146],[143,147],[142,11],[145,148],[140,11],[144,149],[141,150],[412,151],[439,152],[435,1],[437,153],[438,1],[408,11],[210,154],[444,155],[445,156],[447,157],[448,158],[459,159],[458,160],[462,161],[463,162],[461,163],[464,164],[465,165],[466,166],[467,167],[468,168],[469,169],[470,170],[471,171],[472,172],[473,173],[56,174],[57,174],[59,175],[60,176],[61,177],[62,178],[63,179],[64,180],[65,181],[66,182],[67,183],[68,184],[69,184],[70,185],[71,186],[72,187],[73,188],[74,189],[75,190],[76,191],[77,192],[108,193],[78,194],[79,195],[80,196],[81,197],[82,198],[83,199],[84,200],[85,201],[86,202],[87,203],[88,204],[89,205],[91,206],[90,207],[92,208],[93,209],[95,210],[96,211],[97,212],[98,213],[99,214],[100,215],[101,216],[102,217],[103,218],[104,219],[105,220],[106,221],[476,11],[177,222],[479,11],[504,223],[505,224],[480,225],[483,225],[502,223],[503,223],[493,223],[492,226],[490,223],[485,223],[498,223],[496,223],[500,223],[484,223],[497,223],[501,223],[486,223],[487,223],[499,223],[481,223],[488,223],[489,223],[491,223],[495,223],[506,227],[494,223],[482,223],[519,228],[513,227],[515,229],[514,227],[507,227],[508,227],[510,227],[512,227],[516,229],[517,229],[509,229],[511,229],[521,230],[525,231],[421,232],[423,233],[427,234],[425,235],[424,235],[428,236],[430,237],[429,238],[227,239],[229,239],[228,239],[226,239],[236,240],[231,241],[222,239],[223,239],[224,239],[225,239],[454,242],[456,243],[455,242],[453,244],[457,245],[452,246],[196,247],[191,248],[192,249],[193,249],[194,250],[195,250],[190,251],[239,252],[238,253],[237,254],[240,255],[406,256],[414,257],[413,258],[409,259],[275,260],[276,261],[277,261],[279,262],[281,263],[280,261],[432,270],[433,265],[404,266],[418,267],[417,267],[415,268],[416,267],[419,269]],"semanticDiagnosticsPerFile":[436,434,126,109,128,110,127,132,133,129,135,130,134,131,117,114,121,115,112,120,125,122,123,124,119,116,113,118,174,173,175,170,168,169,172,171,154,159,148,153,152,150,157,158,160,155,149,147,146,156,162,161,163,164,165,167,137,138,139,136,151,166,185,186,187,241,407,244,246,242,243,245,248,247,311,313,312,300,308,304,305,309,307,314,315,316,318,317,319,310,303,301,302,306,268,269,291,266,249,251,250,257,254,253,265,255,264,267,403,256,258,259,260,263,261,262,292,402,252,181,182,179,180,184,183,283,284,287,285,286,290,288,289,282,271,273,272,274,270,178,399,293,400,401,294,295,296,398,396,297,397,328,329,330,331,332,341,342,343,345,346,344,333,335,336,334,337,338,339,340,347,351,349,348,350,320,383,385,386,394,387,388,389,390,392,391,393,384,395,368,298,299,322,323,324,325,326,327,369,370,372,381,374,373,375,376,380,377,378,379,321,382,371,366,353,362,354,355,364,356,357,365,363,358,361,359,360,367,352,197,198,200,201,202,203,204,205,206,199,219,207,208,211,212,213,214,215,216,217,218,143,142,145,140,144,141,410,412,411,439,435,437,438,408,210,440,441,444,442,445,446,447,448,459,458,443,460,462,463,461,464,465,466,467,468,469,470,471,472,473,474,209,56,57,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,58,107,75,76,77,108,78,79,80,81,82,83,84,85,86,87,88,89,91,90,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,475,476,477,478,177,176,479,504,505,480,483,502,503,493,492,490,485,498,496,500,484,497,501,486,487,499,481,488,489,491,495,506,494,482,519,518,513,515,514,507,508,510,512,516,517,509,511,521,520,522,523,524,525,421,420,423,422,426,427,425,424,111,449,428,430,429,230,227,229,228,226,236,231,235,232,234,233,222,223,224,220,221,225,450,454,456,455,453,457,452,451,189,196,191,192,193,194,195,190,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,188,239,238,237,240,406,414,413,405,409,275,276,277,278,279,281,280,432,431,433,404,418,417,415,416,419,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
+{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../types/eth-ens-namehash.d.ts","../../../types/ethereum-ens-network-map.d.ts","../../../types/global.d.ts","../../../types/single-call-balance-checker-abi.d.ts","../../../types/@metamask/contract-metadata.d.ts","../../../types/@metamask/eth-hd-keyring.d.ts","../../../types/@metamask/eth-simple-keyring.d.ts","../../../types/@metamask/ethjs-provider-http.d.ts","../../../types/@metamask/ethjs-unit.d.ts","../../../types/@metamask/metamask-eth-abis.d.ts","../../../types/eth-json-rpc-infura/src/createProvider.d.ts","../../../types/eth-phishing-detect/src/config.json.d.ts","../../../types/eth-phishing-detect/src/detector.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@ethereumjs/common/dist/enums.d.ts","../../../node_modules/@ethereumjs/common/dist/types.d.ts","../../../node_modules/buffer/index.d.ts","../../../node_modules/@ethereumjs/util/dist/constants.d.ts","../../../node_modules/@ethereumjs/util/dist/units.d.ts","../../../node_modules/@ethereumjs/util/dist/address.d.ts","../../../node_modules/@ethereumjs/util/dist/bytes.d.ts","../../../node_modules/@ethereumjs/util/dist/types.d.ts","../../../node_modules/@ethereumjs/util/dist/account.d.ts","../../../node_modules/@ethereumjs/util/dist/withdrawal.d.ts","../../../node_modules/@ethereumjs/util/dist/signature.d.ts","../../../node_modules/@ethereumjs/util/dist/encoding.d.ts","../../../node_modules/@ethereumjs/util/dist/asyncEventEmitter.d.ts","../../../node_modules/@ethereumjs/util/dist/internal.d.ts","../../../node_modules/@ethereumjs/util/dist/lock.d.ts","../../../node_modules/@ethereumjs/util/dist/provider.d.ts","../../../node_modules/@ethereumjs/util/dist/index.d.ts","../../../node_modules/@ethereumjs/common/dist/common.d.ts","../../../node_modules/@ethereumjs/common/dist/utils.d.ts","../../../node_modules/@ethereumjs/common/dist/index.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip2930Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/legacyTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/types.d.ts","../../../node_modules/@ethereumjs/tx/dist/baseTransaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/eip1559Transaction.d.ts","../../../node_modules/@ethereumjs/tx/dist/transactionFactory.d.ts","../../../node_modules/@ethereumjs/tx/dist/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/patchCBOR.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/lib/DataItem.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/lib/cbor-sync.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/lib/index.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/ur.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urEncoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainEncoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/fountainDecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/urDecoder.d.ts","../../../node_modules/@ngraveio/bc-ur/dist/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/RegistryType.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/RegistryItem.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoCoinInfo.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/PathComponent.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoKeypath.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/types.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoHDKey.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoECKey.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/Bytes.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/MultiKey.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/ScriptExpression.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoOutput.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoPSBT.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/CryptoAccount.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/Decoder/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/CryptoMultiAccounts.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/errors/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/DerivationSchema.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/KeyDerivation.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/extended/QRHardwareCall.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/utils.d.ts","../../../node_modules/@keystonehq/bc-ur-registry/dist/index.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/EthSignRequest.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/EthSignature.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/ETHNFTItem.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/utlis.d.ts","../../../node_modules/@keystonehq/bc-ur-registry-eth/dist/index.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/InteractionProvider.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/BaseKeyring.d.ts","../../../node_modules/@keystonehq/base-eth-keyring/dist/index.d.ts","../../../node_modules/@types/readable-stream/node_modules/safe-buffer/index.d.ts","../../../node_modules/@types/readable-stream/index.d.ts","../../../node_modules/@metamask/safe-event-emitter/dist/cjs/index.d.ts","../../../node_modules/@metamask/obs-store/dist/ObservableStore.d.ts","../../../node_modules/@metamask/obs-store/dist/asStream.d.ts","../../../node_modules/@metamask/obs-store/dist/ComposedStore.d.ts","../../../node_modules/@metamask/obs-store/dist/MergedStore.d.ts","../../../node_modules/@metamask/obs-store/dist/transform.d.ts","../../../node_modules/@metamask/obs-store/dist/index.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/MetaMaskInteractionProvider.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/MetaMaskKeyring.d.ts","../../../node_modules/@keystonehq/metamask-airgapped-keyring/dist/index.d.ts","../../base-controller/dist/types/BaseControllerV1.d.ts","../../../node_modules/superstruct/dist/error.d.ts","../../../node_modules/superstruct/dist/utils.d.ts","../../../node_modules/superstruct/dist/struct.d.ts","../../../node_modules/superstruct/dist/structs/coercions.d.ts","../../../node_modules/superstruct/dist/structs/refinements.d.ts","../../../node_modules/superstruct/dist/structs/types.d.ts","../../../node_modules/superstruct/dist/structs/utilities.d.ts","../../../node_modules/superstruct/dist/index.d.ts","../../../node_modules/@metamask/utils/dist/types/assert.d.ts","../../../node_modules/@metamask/utils/dist/types/base64.d.ts","../../../node_modules/@metamask/utils/dist/types/hex.d.ts","../../../node_modules/@metamask/utils/dist/types/bytes.d.ts","../../../node_modules/@metamask/utils/dist/types/caip-types.d.ts","../../../node_modules/@metamask/utils/dist/types/checksum.d.ts","../../../node_modules/@metamask/utils/dist/types/coercers.d.ts","../../../node_modules/@metamask/utils/dist/types/collections.d.ts","../../../node_modules/@metamask/utils/dist/types/encryption-types.d.ts","../../../node_modules/@metamask/utils/dist/types/errors.d.ts","../../../node_modules/@metamask/utils/dist/types/json.d.ts","../../../node_modules/@metamask/utils/dist/types/keyring.d.ts","../../../node_modules/@types/ms/index.d.ts","../../../node_modules/@types/debug/index.d.ts","../../../node_modules/@metamask/utils/dist/types/logging.d.ts","../../../node_modules/@metamask/utils/dist/types/misc.d.ts","../../../node_modules/@metamask/utils/dist/types/number.d.ts","../../../node_modules/@metamask/utils/dist/types/opaque.d.ts","../../../node_modules/@metamask/utils/dist/types/promise.d.ts","../../../node_modules/@metamask/utils/dist/types/time.d.ts","../../../node_modules/@metamask/utils/dist/types/transaction-types.d.ts","../../../node_modules/@metamask/utils/dist/types/versions.d.ts","../../../node_modules/@metamask/utils/dist/types/index.d.ts","../../../node_modules/immer/dist/utils/env.d.ts","../../../node_modules/immer/dist/utils/errors.d.ts","../../../node_modules/immer/dist/types/types-external.d.ts","../../../node_modules/immer/dist/types/types-internal.d.ts","../../../node_modules/immer/dist/utils/common.d.ts","../../../node_modules/immer/dist/utils/plugins.d.ts","../../../node_modules/immer/dist/core/scope.d.ts","../../../node_modules/immer/dist/core/finalize.d.ts","../../../node_modules/immer/dist/core/proxy.d.ts","../../../node_modules/immer/dist/core/immerClass.d.ts","../../../node_modules/immer/dist/core/current.d.ts","../../../node_modules/immer/dist/internal.d.ts","../../../node_modules/immer/dist/plugins/es5.d.ts","../../../node_modules/immer/dist/plugins/patches.d.ts","../../../node_modules/immer/dist/plugins/mapset.d.ts","../../../node_modules/immer/dist/plugins/all.d.ts","../../../node_modules/immer/dist/immer.d.ts","../../base-controller/dist/types/RestrictedControllerMessenger.d.ts","../../base-controller/dist/types/ControllerMessenger.d.ts","../../base-controller/dist/types/BaseControllerV2.d.ts","../../base-controller/dist/types/index.d.ts","../../../node_modules/@metamask/browser-passworder/dist/index.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/personal-sign.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/sign-typed-data.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/encryption.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/utils.d.ts","../../../node_modules/@metamask/eth-sig-util/dist/index.d.ts","../../../node_modules/@metamask/eth-simple-keyring/dist/simple-keyring.d.ts","../../../node_modules/@metamask/eth-simple-keyring/dist/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/base-types.d.ts","../../../node_modules/@metamask/keyring-api/dist/btc/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/btc/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/superstruct.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/erc4337/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/contexts.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/EthKeyring.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/rpc.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/types.d.ts","../../../node_modules/@metamask/keyring-api/dist/internal/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/eth/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/api.d.ts","../../../node_modules/@metamask/keyring-api/dist/events.d.ts","../../../node_modules/@metamask/keyring-api/dist/JsonRpcRequest.d.ts","../../../node_modules/@metamask/keyring-api/dist/KeyringClient.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/utils.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/classes.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/errors.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/error-constants.d.ts","../../../node_modules/@metamask/rpc-errors/dist/types/index.d.ts","../../json-rpc-engine/src/JsonRpcEngine.ts","../../json-rpc-engine/src/createAsyncMiddleware.ts","../../json-rpc-engine/src/createScaffoldMiddleware.ts","../../json-rpc-engine/src/getUniqueId.ts","../../json-rpc-engine/src/idRemapMiddleware.ts","../../json-rpc-engine/src/mergeMiddleware.ts","../../json-rpc-engine/src/index.ts","../../../node_modules/@metamask/providers/dist/types/utils.d.ts","../../../node_modules/@metamask/providers/dist/types/BaseProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/EIP6963.d.ts","../../../node_modules/@metamask/providers/dist/types/StreamProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/extension-provider/createExternalExtensionProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/MetaMaskInpageProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/initializeInpageProvider.d.ts","../../../node_modules/@metamask/providers/dist/types/shimWeb3.d.ts","../../../node_modules/@metamask/providers/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/KeyringSnapRpcClient.d.ts","../../../node_modules/@metamask/keyring-api/dist/rpc-handler.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/errors.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/helpers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/structs.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/create-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/dialog.d.ts","../../../node_modules/@metamask/key-tree/dist/constants.d.cts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/modular.d.ts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/utils.d.ts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/curve.d.ts","../../../node_modules/@metamask/key-tree/dist/curves/ed25519.d.cts","../../../node_modules/@metamask/key-tree/dist/curves/ed25519Bip32.d.cts","../../../node_modules/@metamask/key-tree/node_modules/@noble/curves/abstract/weierstrass.d.ts","../../../node_modules/@metamask/key-tree/dist/curves/secp256k1.d.cts","../../../node_modules/@metamask/key-tree/dist/curves/curve.d.cts","../../../node_modules/@metamask/key-tree/dist/curves/index.d.cts","../../../node_modules/@metamask/key-tree/dist/utils.d.cts","../../../node_modules/@metamask/key-tree/dist/BIP44CoinTypeNode.d.cts","../../../node_modules/@metamask/key-tree/dist/SLIP10Node.d.cts","../../../node_modules/@metamask/key-tree/dist/BIP44Node.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/bip32.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/bip39.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/cip3.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/slip10.d.cts","../../../node_modules/@metamask/key-tree/dist/derivers/index.d.cts","../../../node_modules/@metamask/key-tree/dist/index.d.cts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/caip.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/permissions.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip32-public-key.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-bip44-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-client-status.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-entropy.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-file.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Box.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Button.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Field.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/Form.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/form/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/formatting/Bold.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/formatting/Italic.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/formatting/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Link.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/Spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/jsx-runtime.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/jsx-dev-runtime.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/validation.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/jsx/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/nodes.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/address.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/copyable.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/divider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/heading.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/image.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/panel.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/spinner.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/text.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/row.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/button.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/form.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/components/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/component.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/ui/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-interface-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-locale.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/get-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-snap.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/invoke-keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-accounts.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/manage-state.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/notify.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/request-snaps.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/update-interface.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/methods.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/methods/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/provider.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/global.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/cronjob.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/home-page.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/keyring.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/lifecycle.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/name-lookup.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/rpc-request.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/transaction.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/signature.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/user-input.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/handlers/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/types/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/jsx.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/svg.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/internals/index.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/error-wrappers.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/images.d.ts","../../../node_modules/@metamask/snaps-sdk/dist/types/index.d.ts","../../../node_modules/@metamask/keyring-api/dist/snap-utils.d.ts","../../../node_modules/@metamask/keyring-api/dist/index.d.ts","../../message-manager/dist/types/AbstractMessageManager.d.ts","../../controller-utils/dist/types/types.d.ts","../../controller-utils/dist/types/constants.d.ts","../../../node_modules/@metamask/eth-query/index.d.ts","../../../node_modules/@types/bn.js/index.d.ts","../../controller-utils/dist/types/util.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/abnf.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/utils.d.ts","../../../node_modules/@spruceid/siwe-parser/dist/parsers.d.ts","../../controller-utils/dist/types/siwe.d.ts","../../controller-utils/dist/types/index.d.ts","../../message-manager/dist/types/PersonalMessageManager.d.ts","../../message-manager/dist/types/TypedMessageManager.d.ts","../../message-manager/dist/types/EncryptionPublicKeyManager.d.ts","../../message-manager/dist/types/DecryptMessageManager.d.ts","../../message-manager/dist/types/index.d.ts","../../../node_modules/async-mutex/lib/MutexInterface.d.ts","../../../node_modules/async-mutex/lib/Mutex.d.ts","../../../node_modules/async-mutex/lib/SemaphoreInterface.d.ts","../../../node_modules/async-mutex/lib/Semaphore.d.ts","../../../node_modules/async-mutex/lib/withTimeout.d.ts","../../../node_modules/async-mutex/lib/tryAcquire.d.ts","../../../node_modules/async-mutex/lib/errors.d.ts","../../../node_modules/async-mutex/lib/index.d.ts","../../../node_modules/ethereumjs-wallet/dist/hdkey.d.ts","../../../node_modules/ethereumjs-wallet/dist/thirdparty.d.ts","../../../node_modules/ethereumjs-wallet/dist/index.d.ts","../src/constants.ts","../src/KeyringController.ts","../src/index.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/deep-freeze-strict/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/jest-diff/build/cleanupSemantic.d.ts","../../../node_modules/pretty-format/build/types.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/types.d.ts","../../../node_modules/jest-diff/build/diffLines.d.ts","../../../node_modules/jest-diff/build/printDiffs.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/jest-when/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/pbkdf2/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/punycode/index.d.ts","../../../node_modules/@types/secp256k1/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/sinonjs__fake-timers/index.d.ts","../../../node_modules/@types/sinon/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},"70bbfaec021ac4a0c805374225b55d70887f987df8b8dd7711d79464bb7b4385","869089d60b67219f63e6aca810284c89bae1b384b5cbc7ce64e53d82ad223ed5",{"version":"18338b6a4b920ec7d49b4ffafcbf0fa8a86b4bfd432966efd722dab611157cf4","affectsGlobalScope":true},"62a0875a0397b35a2364f1d401c0ce17975dfa4d47bf6844de858ae04da349f9","ee7491d0318d1fafcba97d5b72b450eb52671570f7a4ecd9e8898d40eaae9472","e3e7d217d89b380c1f34395eadc9289542851b0f0a64007dfe1fb7cf7423d24e","fd79909e93b4d50fd0ed9f3d39ddf8ba0653290bac25c295aac49f6befbd081b","345a9cc2945406f53051cd0e9b51f82e1e53929848eab046fdda91ee8aa7da31","9debe2de883da37a914e5e784a7be54c201b8f1d783822ad6f443ff409a5ea21","dee5d5c5440cda1f3668f11809a5503c30db0476ad117dd450f7ba5a45300e8f","f5e396c1424c391078c866d6f84afe0b4d2f7f85a160b9c756cd63b5b1775d93","5caa6f4fff16066d377d4e254f6c34c16540da3809cd66cd626a303bc33c419f","730d055528bdf12c8524870bb33d237991be9084c57634e56e5d8075f6605e02","5b3cd03ae354ea96eff1f74d7c410fe4852e6382227e8b0ecf87ab5e3a5bbcd4","7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419",{"version":"056097110efd16869ec118cedb44ecbac9a019576eee808d61304ca6d5cb2cbe","affectsGlobalScope":true},"f51b4042a3ac86f1f707500a9768f88d0b0c1fc3f3e45a73333283dea720cdc6",{"version":"6fb8358e10ed92a7f515b7d79da3904c955a3ffd4e14aa9df6f0ea113041f1cf","affectsGlobalScope":true},"45c831238c6dac21c72da5f335747736a56a3847192bf03c84b958a7e9ec93e2","661a11d16ad2e3543a77c53bcd4017ee9a450f47ab7def3ab493a86eae4d550c",{"version":"8cdc646cec7819581ef343b83855b1bfe4fe674f2c84f4fb8dc90d82fb56bd3a","affectsGlobalScope":true},"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","9dd56225cc2d8cb8fe5ceb0043ff386987637e12fecc6078896058a99deae284","2375ed4b439215aa3b6d0c6fd175c78a4384b30cb43cbadaecbf0a18954c98cb","7693b90b3075deaccafd5efb467bf9f2b747a3075be888652ef73e64396d8628","41231da15bb5e3e806a8395bd15c7befd2ec90f9f4e3c9d0ae1356bccb76dbb0","fccfef201d057cb407fa515311bd608549bab6c7b8adcf8f2df31f5d3b796478",{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true},"5f20d20b7607174caf1a6da9141aeb9f2142159ae2410ca30c7a0fccd1d19c99",{"version":"464762c6213566d072f1ced5e8e9a954785ec5e53883b7397198abb5ef5b8f71","affectsGlobalScope":true},"6387920dc3e18927335b086deec75bf8e50f879a5e273d32ee7bb7a55ba50572","9bba37424094688c4663c177a1379b229f919b8912889a472f32fdc5f08ddb4d","29a4be13b3a30d3e66667b75c58ec61fb2df8fa0422534fdee3cfb30c5dbf450","83366d901beda79d6eb37aaaf6ca248dcd88946302b2a7d975590783be51e88e","bf268a0aea37ad4ae3b7a9b58559190b6fc01ea16a31e35cd05817a0a60f895a","43ec77c369473e92e2ecebf0554a0fdaa9c256644a6070f28228dfcceec77351",{"version":"d7dad6db394a3d9f7b49755e4b610fbf8ed6eb0c9810ae5f1a119f6b5d76de45","affectsGlobalScope":true},"95ed02bacb4502c985b69742ec82a4576d4ff4a6620ecc91593f611d502ae546","bf755525c4e6f85a970b98c4755d98e8aa1b6dbd83a5d8fcc57d3d497351b936","dd67d2b5e4e8a182a38de8e69fb736945eaa4588e0909c14e01a14bd3cc1fd1e",{"version":"28084e15b63e6211769db2fe646d8bc5c4c6776321e0deffe2d12eefd52cb6b9","affectsGlobalScope":true},{"version":"aed37dabf86c99d6c8508700576ecede86688397bc12523541858705a0c737c2","affectsGlobalScope":true},"cc6ef5733d4ea6d2e06310a32dffd2c16418b467c5033d49cecc4f3a25de7497","94768454c3348b6ebe48e45fbad8c92e2bb7af4a35243edbe2b90823d0bd7f9a","0be79b3ff0f16b6c2f9bc8c4cc7097ea417d8d67f8267f7e1eec8e32b548c2ff","1c61ffa3a71b77363b30d19832c269ef62fba787f5610cac7254728d3b69ab2e","84da3c28344e621fd1d591f2c09e9595292d2b70018da28a553268ac122597d4","269929a24b2816343a178008ac9ae9248304d92a8ba8e233055e0ed6dbe6ef71","6e191fea1db6e9e4fa828259cf489e820ec9170effff57fb081a2f3295db4722","aed943465fbce1efe49ee16b5ea409050f15cd8eaf116f6fadb64ef0772e7d95","70d08483a67bf7050dbedace398ef3fee9f436fcd60517c97c4c1e22e3c6f3e8","c40fdf7b2e18df49ce0568e37f0292c12807a0748be79e272745e7216bed2606",{"version":"e933de8143e1d12dd51d89b398760fd5a9081896be366dad88a922d0b29f3c69","affectsGlobalScope":true},"4e228e78c1e9b0a75c70588d59288f63a6258e8b1fe4a67b0c53fe03461421d9","b38d55d08708c2410a3039687db70b4a5bfa69fc4845617c313b5a10d9c5c637","205d50c24359ead003dc537b9b65d2a64208dfdffe368f403cf9e0357831db9e","1265fddcd0c68be9d2a3b29805d0280484c961264dd95e0b675f7bd91f777e78",{"version":"a05e2d784c9be7051c4ac87a407c66d2106e23490c18c038bbd0712bde7602fd","affectsGlobalScope":true},{"version":"df90b9d0e9980762da8daf8adf6ffa0c853e76bfd269c377be0d07a9ad87acd2","affectsGlobalScope":true},"cf434b5c04792f62d6f4bdd5e2c8673f36e638e910333c172614d5def9b17f98","1d65d4798df9c2df008884035c41d3e67731f29db5ecb64cd7378797c7c53a2f","0faee6b555890a1cb106e2adc5d3ffd89545b1da894d474e9d436596d654998f","c6c01ea1c42508edf11a36d13b70f6e35774f74355ba5d358354d4a77cc67ea1","867f95abf1df444aab146b19847391fc2f922a55f6a970a27ed8226766cee29f",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"b0297b09e607bec9698cac7cf55463d6731406efb1161ee4d448293b47397c84","175323e2a79a6076e0bada8a390d535a3ea817158bf1b1f46e31efca9028a0a2","7a10053aadc19335532a4d02756db4865974fd69bea5439ddcc5bfdf062d9476","4967529644e391115ca5592184d4b63980569adf60ee685f968fd59ab1557188","aed9e712a9b168345362e8f3a949f16c99ca1e05d21328f05735dfdbb24414ef","b04fe6922ed3db93afdbd49cdda8576aa75f744592fceea96fb0d5f32158c4f5","ed8d6c8de90fc2a4faaebc28e91f2469928738efd5208fb75ade0fa607e892b7","d7c52b198d680fe65b1a8d1b001f0173ffa2536ca2e7082431d726ce1f6714cd","c07f251e1c4e415a838e5498380b55cfea94f3513229de292d2aa85ae52fc3e9","0ed401424892d6bf294a5374efe512d6951b54a71e5dd0290c55b6d0d915f6f7","b945be6da6a3616ef3a250bfe223362b1c7c6872e775b0c4d82a1bf7a28ff902","beea49237dd7c7110fabf3c7509919c9cb9da841d847c53cac162dc3479e2f87","0f45f8a529c450d8f394106cc622bff79e44a1716e1ac9c3cc68b43f7ecf65ee","c624ce90b04c27ce4f318ba6330d39bde3d4e306f0f497ce78d4bda5ab8e22ca","9b8253aa5cb2c82d505f72afdbf96e83b15cc6b9a6f4fadbbbab46210d5f1977","86a8f52e4b1ac49155e889376bcfa8528a634c90c27fec65aa0e949f77b740c5","aab5dd41c1e2316cc0b42a7dd15684f8582d5a1d16c0516276a2a8a7d0fecd9c","59948226626ee210045296ba1fc6cb0fe748d1ff613204e08e7157ab6862dee7","ec3e54d8b713c170fdc8110a7e4a6a97513a7ab6b05ac9e1100cb064d2bb7349","43beb30ecb39a603fde4376554887310b0699f25f7f39c5c91e3147b51bb3a26","666b77d7f06f49da114b090a399abbfa66d5b6c01a3fd9dc4f063a52ace28507","31997714a93fbc570f52d47d6a8ebfb021a34a68ea9ba58bbb69cdec9565657e","6032e4262822160128e644de3fc4410bcd7517c2f137525fd2623d2bb23cb0d3","8bd5c9b1016629c144fd228983395b9dbf0676a576716bc3d316cab612c33cd5","2ed90bd3925b23aed8f859ffd0e885250be0424ca2b57e9866dabef152e1d6b7","93f6bd17d92dab9db7897e1430a5aeaa03bcf51623156213d8397710367a76ce","3f62b770a42e8c47c7008726f95aa383e69d97e85e680d237b99fcb0ee601dd8","5b84cfe78028c35c3bb89c042f18bf08d09da11e82d275c378ae4d07d8477e6c","8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","25139d6a726e0e19d9fc4fa3197367b4a82ec34a08a5ecf23963e142c202c0f3","e3328bffc8eab74665a4fe9c59d6f12f4c8570c3d858497e241eb37efe17dfcf","29389551e426a46421134b55182d6fcf5b143670998bf81db2619c1228235392","c18f7e16982695bdd04e3e183a327d116185f77f1a37b9b2e849d7d93269cd74","2cfb37011989c21dc70b91d521a2d5a4e0f18507f5f536b5dfe504edb15916e8","bb5e02df7aaec7a4ea642639a9963b24b8d9fd6798351f07d8c58616942fbcbf","299a899cb4d061f5d83843ec453e936e9659b2c435746823f90c40eddaef4745","d5610c0fd12870f644b0f42c1bcc4fa2295ac3e3ca01916bdb42c3bdc4c80c36","2c56a8e249b1f45dbdf973100cd37fe2ea68709573cf1fdf2e3052c593be68d8","3553da417ee7b07e388b13bd12a70a1c03e65a6132ba5427fe68f5b362373e6f","612358502042d351c227ba779fdcf6d875d827e424930e60297c533524e50668","d2b5be376ef162aa0c24a826e7dd2d77671a045c085e16d1c1276db4bdccbac7","c4138d8dcccedaff6621e009cf0a54a7bed2a5ad4c509a3513bccc4f417ef939","ad8747fe978dff3e80f4b12b48d37cc8dff11b61d04c035aefbc982ce21201ce","b154f789fd65298e1ba6cbba6944ea892d564c95f3d3700ed85baf8f80748473","c660265aedd7c5b236e2017e53095cb98da66200eb0e8d023b5bf713c36494e8","0efc36bf5c0daca6217fec7063359ccdab8c3a23bb405d25340fae22cf72d74f","5abff0c87d4f9c89715107042d4c73b68ef7a128759f451c8a0fc450cbaaf660","5a03308fbd1af441065149a84c692931bebc7e7735afc23be8684f4e10d3aa06","c787bf4f8f0abbf815cfbd348be41046f2b8f270be24fe7aa8a8fcdd2b7df8c2","e7a5191c663a3228f30104961d548b372e51c5936c01ffc8eddd262bb98d7d7c","43fdc9abe6f8640fda4cdc55a1ee5f666d3fce554277043df925c383137ddf69","f0b09665c9d52de465687fbd3cfb65111d3ffc59ae00c6f42654150f3db05518","72f8c078d06cff690e24ff2b0e118a9de2833dcebf7c53e762dcb505ddf36a68","9705efb0fd901180de84ca4dd11d86f87fd73f99d6a5660a664c048a7487e385","f9b9d0950fdfb90f57e3f045fe73dce7fa6e7921b37622fc12e64fcd90afbd0f","e61b36e7fde608f8bb4b9c973d81556553a715eaef42a181a16ddd7a28da4ac7","03b8389b222af729eae0fb3c33366dcbb1f5a0102ce319bf1d7d5ee987e59fd0","2bf6be7c04db280fdd9b786764f8650c23f9f4d533791cb25a11b25314b76a55","dbb5fc7edd36bfba95cc4dd564e4458276ced30eed18bc05fbda948b3fda8686","c2b556c7cff0dabce2e31cb373ac61c14d8ebc35f1086dff30b39e9ec5357d0d","f958af01131076e8af55d28c4835a51063226ab488ca8738fdee38aeef7d0d33","9f3797b01e3d83d4e4b875699ae984f380ca86aa0a0c9df43ac5bba1cb1f8b7b","752b15ad1b34887adeaa838fc55f5d4ca399026afd266d4ed4db0e3db02eae4e","778331eaea1093451e50be9844bd2b6937c3bb81b0b1ee700624c9774ecfcf2b","0ca0dfc9f657d0822eca9530c7870b22a1d2a5fc48182bdd4d0e6e88e4ad9c35","5c746f034288e6842dd1589b169dcfcc16c5ce5abbd928889ab67aea4fe0b501","92ce6dbbcc135cffd09a58e19fef34bf351391bec92c40d849e4e9997d475769","99e77d092fed72b6b8578d00c7af004f76e98b30ba99f1947535eb4c04a51676","5e379df3d61561c2ed7789b5995b9ba2143bbba21a905e2381e16efe7d1fa424","f07a137bbe2de7a122c37bfea00e761975fb264c49f18003d398d71b3fb35a5f","fcc8beef29f39f09b1d9c9f99c42f9fed605ab1c28d2a630185f732b9ba53763","b5ef52a9f9083724decc5d060f0b34e3a480deed71c32d55ca16c214eb4cc928","5d3d7938b2d7d0a9f851276741327c2ae4c013e7eb420fc3f7caed3b79c8f37f","14df6b81e50a035e9e391558cf30a0420d03e2eb42c7db9c57f44b818e5d5179","f100912a3785eed4a3d29c12f5910b101af9353454de5ddba9b4d43456c56dd1","446439eacf81a163fd7dfc53b28f80deca3d13b250d67639739aa25aa4491090","98034cd285344125f7165a3bb68246d38ab35fabe7f6d6a7c8f80407d31f548d","06b4a23064991251512df4edc12341d5bc69a17b942da18372312d383c90eee7","0f898802705f9a534b537f1be6c57265080e0abd6993d935554c255e6d56cc1a","745efa7b6e27b7216cccede166a822b56acc41b10a8090966c8cf2c96239cb83","75b22c74010ba649de1a1676a4c4b8b5bb4294fecd05089e2094429b16d7840c","5615ccf831db2ffc82145243081ebdb60ea8e1005ee8f975d1c0c1401a9c894e","38682ed3630bb6ecdace80d5a9adc811fc20a419f1940446e306c3a020d083b9","cc182e6e4f691cd6f7bf7cb491247a4c7818f9f1cb2db1d45c65ff906e3f741b","a50599c08934a62f11657bdbe0dc929ab66da1b1f09974408fd9a33ec1bb8060","5a20e7d6c630b91be15e9b837853173829d00273197481dc8d3e94df61105a71","8d478048d71cc16f806d4b71b252ecb67c7444ccf4f4b09b29a312712184f859","e0eda929c6b9b628cdeb0e54cd3582cb97e64f28aab34612fc1431c545899584","9df4662ca3dbc2522bc115833ee04faa1afbb4e249a85ef4a0a09c621346bd08","b25d9065cf1c1f537a140bbc508e953ed2262f77134574c432d206ff36f4bdbf","1b103313097041aa9cd705a682c652f08613cb5cf8663321061c0902f845e81c","68ccec8662818911d8a12b8ed028bc5729fb4f1d34793c4701265ba60bc73cf4","5f85b8b79dc4d36af672c035b2beb71545de63a5d60bccbeee64c260941672ab","b3d48529ae61dc27d0bfbfa2cb3e0dff8189644bd155bdf5df1e8e14669f7043","40fe4b689225816b31fe5794c0fbf3534568819709e40295ead998a2bc1ab237","f65b5e33b9ad545a1eebbd6afe857314725ad42aaf069913e33f928ab3e4990a","fb6f2a87beb7fb1f4c2b762d0c76a9459fc91f557231569b0ee21399e22aa13d","31c858dc85996fac4b7fa944e1016d5c72f514930a72357ab5001097bf6511c7","3de30a871b3340be8b679c52aa12f90dd1c8c60874517be58968fdbcc4d79445","6fd985bd31eaf77542625306fb0404d32bff978990f0a06428e5f0b9a3b58109","980d21b0081cbf81774083b1e3a46f4bbdcd2b68858df0f66d7fad9c82bc34bc","68cc8d6fcc2f270d7108f02f3ebc59480a54615be3e09a47e14527f349e9d53e","3eb11dbf3489064a47a2e1cf9d261b1f100ef0b3b50ffca6c44dd99d6dd81ac1","b17f3bb7d8333479c7e45e5f3d876761b9bca58f97594eca3f6a944fd825e632","3c1f1236cce6d6e0c4e2c1b4371e6f72d7c14842ecd76a98ed0748ee5730c8f3","6d7f58d5ea72d7834946fd7104a734dc7d40661be8b2e1eaced1ddce3268ebaf","4c26222991e6c97d5a8f541d4f2c67585eda9e8b33cf9f52931b098045236e88","277983d414aa99d78655186c3ee1e1c38c302e336aff1d77b47fcdc39d8273fe","47383b45796d525a4039cd22d2840ac55a1ff03a43d027f7f867ba7314a9cf53","6548773b3abbc18de29176c2141f766d4e437e40596ee480447abf83575445ad","6ddd27af0436ce59dd4c1896e2bfdb2bdb2529847d078b83ce67a144dff05491","816264799aef3fd5a09a3b6c25217d5ec26a9dfc7465eac7d6073bcdc7d88f3f","4df0891b133884cd9ed752d31c7d0ec0a09234e9ed5394abffd3c660761598db","b603b62d3dcd31ef757dc7339b4fa8acdbca318b0fb9ac485f9a1351955615f9","e642bd47b75ad6b53cbf0dfd7ddfa0f120bd10193f0c58ec37d87b59bf604aca","be90b24d2ee6f875ce3aaa482e7c41a54278856b03d04212681c4032df62baf9","78f5ff400b3cb37e7b90eef1ff311253ed31c8cb66505e9828fad099bffde021","372c47090e1131305d163469a895ff2938f33fa73aad988df31cd31743f9efb6","71c67dc6987bdbd5599353f90009ff825dd7db0450ef9a0aee5bb0c574d18512","6f12403b5eca6ae7ca8e3efe3eeb9c683b06ce3e3844ccfd04098d83cd7e4957","282c535df88175d64d9df4550d2fd1176fd940c1c6822f1e7584003237f179d3","c3a4752cf103e4c6034d5bd449c8f9d5e7b352d22a5f8f9a41a8efb11646f9c2","11a9e38611ac3c77c74240c58b6bd64a0032128b29354e999650f1de1e034b1c","4ed103ca6fff9cb244f7c4b86d1eb28ce8069c32db720784329946731badb5bb","d738f282842970e058672663311c6875482ee36607c88b98ffb6604fba99cb2a","ec859cd8226aa623e41bbb47c249a55ee16dc1b8647359585244d57d3a5ed0c7","8891c6e959d253a66434ff5dc9ae46058fb3493e84b4ca39f710ef2d350656b1","c4463cf02535444dcbc3e67ecd29f1972490f74e49957d6fd4282a1013796ba6","0cb0a957ff02de0b25fd0f3f37130ca7f22d1e0dea256569c714c1f73c6791f8","2f5075dc512d51786b1ba3b1696565641dfaae3ac854f5f13d61fa12ef81a47e","ca3353cc82b1981f0d25d71d7432d583a6ef882ccdea82d65fbe49af37be51cb","50679a8e27aacf72f8c40bcab15d7ef5e83494089b4726b83eec4554344d5cdc","45351e0d51780b6f4088277a4457b9879506ee2720a887de232df0f1efcb33d8","6ab2a6257ae7bb05559841100c786c845fe465a90be7b904db9096c2fb14696b","e87de5e2e71fe0513d6fbd5951a5f8e35595243bbb88fe00b6b2d9383f62fe59","ebb4f551ea58b96443365f487e5c49396c4811dc51e2fd5c3c45928e93047278","7cd0fabd9e9ae5a8faabc2f70d6d9ddd89c65719a30917eacdae9049c16e8a16","bb665725dcc2e2406c572a63038791a7118802ebd947c0e76b0eb38ccd99926c","0c58b5a414a48f68bfea86556a22f505bac4ce0e67ddd5e40e387a4641ce2b78","13de2d120d9122bbff92dca664ebd180241a856d23e705598eb259621a838f0f","2d072cf71b05c374b0406736ae1f402f4ebac96fab8e9e4d6a2ea4d147b1c26e","1507881fb12592d860e8b731a79cccd5880a9e3a3fdb71c8eeb08987420f7c8d","63e64a301fdbb7fb0b58e81b282608594b700e1af51d509de949e88e711a70e8","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","50aa290ee8f3ba75c7a3653613ead6594e2e034a7627b249c9a400858cac79f5","9138338d4fff57ba42d57c7316ad1d055b72b90c9e1acbbfa6cfe16db201802a","d5c19655468e29f60c871b21e73af8ebc653f736e7123ade916f22c4a5f80ce5","863416d62eb7dfa12b63b23c112fd0831aa330816c39d64ca88898ebe5fd62a3","9325a5ce0f09132607e27e599b568e3a67f80ea932f6bbb08bdc1bb7727e11a3","6a8649609161e2794b383ba275b0a6cb4a072dde7b954648f83dc6cdf1bfe4a8","6d3101b183ea67ef606b93fe42127f30b2db5ac3b72c34ca9d6d8b00eb85d0f6","f5d7a36ff056cc314b0f61c89a03c4c36a24183b246e61d958e75e86521304cd","f961ddb0abe88c9815a81132cc9984f0294fd920174fccbdde73d156b8a4ab39","6c951235cbf3c324a20c0e2dfdd013d7b226b0c2a72dbd84925682a8d7199237","aba578ce97acb630b406ffb6ed31302dbd8d2ffcfd671194b1d8704825086e05","3a971ea3e36685b96f24fbd53a94ad8dc061711b84e51fde4cf201f7041e618d","77234d8682b67d78748cb61a63407104dc2c8e3196dcf15a454aae26b42f3ee7","c8be9283a381044a392a0687af5d98d3f51cbada2320b1801a82c948b6e39499","d5cdc145bf5ec321674e31804c075ad408a68c86877ce293970e03634d3709f1","85052c71d72b9b017c88179f57a464d66e22619c7acd7d83b117a79cf1608979","9b6c162d20e2ad4abdcff61a24082564ac59e63092220618162aef6e440c9228","b0874729266d9f7fafb9ff1127fcbad2cf7972b5dcc1fdc104be79266a708bc2","9f9e5bae412fa5909fae636d6733aee27a108cc2ed5b13980611016336774d3c","662fe197bba64bd3f17ee118058cd2d0d2dbe33d7c0c865fd6365d90bfc44e1e","030519c351f800551cac2658038804969ca4584d2c0175a710602ac234ca1340","0278a6939ca83cd040b08ff8c5fc7838b6693ddc52f22526bf158e6b10e0246c","c2d6206e5ba4fd3063b01218c2b3b997afc1cfbeb49fcee991fa8595842ce53d","e9d61a89974e5d8231edab199fe1a5f912a344febc74146611c013435f906de3","813e6dc3098dc7b331ed17bb4a3f96cda83748e989a41c469160ef23776af0f4","3c0913724967da385abf69e4f50dc51d5de5ad7c13d8bedd6746063aab7dd6e0","1fdd00179cddca98c8cfa1c403016f6703a8c34858cfeda33769d86da188ff8d","47ca123995420c8579f010179d3d5e61399ce538fc6386f2438193d48c0013b9","599d6ebec95d21df7ee33d8eb8f0b791ffac4a32026f32cf91fdf417153be473","323a75e01c89a50bb8827d1d624e72c20b0d81d4647a30ee6a695dbb4d76f3b5","d1f010c19eb9c8190bd0859fa3b6f4975543b912b8b85e20bbb0b5bfbdf4d2b3","de4ccc96cef3f97fab148640799abb32a24b567a902a8233913f98481e3131bf",{"version":"801934aa449fe6df584bccdcc5d5b9280295cb7ac84918b6014fc5086e6f9ff6","affectsGlobalScope":true},"6af760fb9ea02dc807c5053d8aee86389c4fce72fbb26af7b9568cac6c4710d5","c62c4ba5e910b4523f7e7adf4a55ec45c2bac99d9d8e9b0fe0c2a800a6f641b9","92131434f876fdd6fcbc40bd54a9d7500c66974362b16bd42641f990468587f4","8cf023c0bd57992fdd2ce6a7030a1874f49c8edc62eaffa9bfffcf18d2a2a1a2","8ea8f3040e38fb50d7dc3653f3b8a0dbb5244e82111576f99ce096bdc0fbf94c","48ed788ad126545a6156fcc37cd3bcf17de18a3e3fe6b6ef62cfb8140d1a45a2","63c271a745f628ffd4bd7ad0a63b021c362c9bd6bf8b18441a7162892395a214","a867ba47f71fe3993cef54246893ff8f01411e12e411d8cf1bd038a448b36404","6a8096993458a3d71229031aa7415974eb5b47b320213e29660adfb519d6a3f4","cb7996a1af5b1d276483cd0c9b9de6540eff021abc90a720511ff4464519a2ff","9df6ec68878d65bc690ea3a33ce3ef5aa8254c36bc5f8346c0c2fd1f3b88a35c","a4fad04c4acc8a4b195cbbccef4c55019104753d547d5c94441643ccc89108a0","0244c23ea642361f7c192c1f0cfff9c12cfa5f51f9b155edd5c0a89fef308d34","ac5da520487547013c3abae0933d6366f51db6df31d1993ddb931ce04b083269","3c69a83bde847af6fc3a53e1bb6b13cd06d38a27a142814b8dacc374f3b93284","5b46f7113f54565e7ffc83f2b474f557a1f54c7e5946769d5be220454656be73","fb58035d39c5759283cb73cfb3548aefe370aa3ad4e81fdb4e46f0979eb7669f","1311c325948b2d5576cebc70b1bf968d3446b4630802bef54120daf04ce1f625","d0b3609e8e7afed0fd0570152255458407e67249b94f6603afdfd68599423f21","17f4c5a1d6eaa87ea27eadcdff9085af3190533d98f799dda79a3af6f9a630ea","3e6f734ddf40e2e99ff7fff9568b7d9720663af9a0632c26a352c8d3270a3f0e","ec13f78303abcf550c5569dfae1446b8ceb89050f68ce04491481e72e8122ae2","a3fc57dbaa7f1efb010399ad4ef4fd9b462aa4e93bf74a9a34b099b97ffcc9cb","ffddd7ec6a450b0cb6f2f73f80de1df963ead312d7c81a8440268f34146ecb87","5d6a36ca0087fd6876df654d1b4192f0e402adfde994ad47e5c065da33692f9c","eb157a09c5f543d98644e2a99a785f9e0e91f054f9fecbf1c3e15831ff5d63a7","edd5530e2b1ccdf65093296e40a8634fcb11ecda3c164c31383a8c34cb04bc9d","9dfaf96d090fe8d96143465d85b4837661ae535143eea9ef99cd20df2e66338e","209d45c27e03c1417c42985252de6c25a2ec23abdc199d88e6139c88b93abd11","0ee5cdba58cfde3012bb9ff2e9edcc4e35a651373a2aa2c83ff9eb7df635419a","540f4dca27ea5a232828b6d91e1b2fce2720bdabaa4c1f3fbf59b672cc58bd8a","ba086b99d545ec6c9ff356989f076b5652ea1b09bcc65b87dfc43a5195a2efcc","c85d9776b36166b928ab1488d9224ebf970d41b0a35f09a3ee0b9bee3e698061","683196f606c5dab1c8c4a24a66d26e00f16f2d4b2a5abe25ebedd37d2954f930","9c3a1b01cba1238fb723ce06b6c163ef6c53be755394406782564d5c42c636b2","6e795e6270d39e918c7a0e62ac73793cda06fcf4b3692ee46583e15f5bf57ab8","0e821ef1eb67fa6144ea4de4277d913f5b1982d7407afd5f93754a8239d41554","5c09195ef359ffa9c6bbdb4fefb101d87ede4b9e9c28213faf5b45d102e4c609","80b4d93a4dcc90a12f6f4bb7c6851a8182ae29e556716d0d80b5c012a5ef554a","2556ef9d1820e0b6bbca6dd65a50ea64f525c4d8247ab50dff44c3f0d14a5643","cbd1c836db190d6e3add07165afc228f04e1f6170e1fe3aa5e6fc24a7e9573a3","9b13881feb958237232586d888a10a39d47cdffe3ee34688ed41888fa7baad94","122fe82cf5af80f0b26832b258b537b7dfe3ec28449c301b259ab10204b50d45","c467dada8fea6d60dff8a8be2675f737cacc76e14e50b72daa0f0710376df84b","9cb80bba611c2dd155a446ce424fe4bb1df2129751bc9416b7e42c055d1ddbff","44f41abb29bf3f4c52270d8119a96c935131e42a9186da15216a76b35e793b4e","043783bebe87efb440183c9ebc8c4fdc1bb92060a5a0f7ce847e30dee7013ac3","e3dc0a97a59dea936b4fb7b1f6f4117b4aac9c86d0cd08b69bab2d0532a8a5e3","5d897601f8a4fe913057019d8211b99b06e3138f625a0cfb601d074f4278271d","cfde5d194dd858ad68f910defaed5b0d28730f8bf38359a9265a93ab29bc7bef","16b21bbe6ad41019c071677877b8fc5dbc8d39a8b0406f020261c5f6f3894be3","f20aae41b169cddcbf3fde8ac380443182c8d7225194e788c404d9e11e6dc75d","87fd9a98cb1e689320ab89adc65e85d140a61260b4f66d12c777f4bd7cae2060","c48566cb13403fca44192b4528e3f2ac993869d39526bd42cd2f2167c0285add","efae20e0c581240c7522e04829da4f0453ca263068596554d4b0e27878c7dfac","3af68ef927788cda7daab34be513fa4508229fdc6e5130d564a0a1ccb3fefafe","bbbd2cbb15a37d5f4dd54ad8c7c537d3df8352117523030fcec7dcbe62a05a58","b50d24ebc117f8805332e7e260e9587f572bb7b2ff0ca1ff6cfafb38015781f3","5cc8b8e18fe7fefab4b3c53a39467b5a0deb4200abae7f063ff0624b9e856c51","8e990781eb0107c25429b1274a31a4f3866a9a46290cce40f354b2a6e71c6c21","8616706e4bd72987bd86c1b4afafa90fa2d4ef2f71708de03a823ab4e9b48e60","b9ce4613536386a98897f1e3d8f61a851ce6cb34dc3c9db4f2ef5f55f007e9e1","77fe56751d7615743937268c72d797fba28309f13ec9079c018b232040fca86a","31b5f53e3d57470830e87f9e03c02d4569ac81d4a758fdda75092f9a3f58beba","d765fbab22fd7003a65ed670100362ec1c90d55a772e6773a774135594e7ea41","1bf86149ef215f258d479695aa35ac89a3d34a6356a6df04e1b5db869289e563","58f4da9e99a4bdbd2f54eeb9303d5b5634b25423d729d44abb3fc55c925495b3","f75cd30f162c2af5e5aca39c01c1a521bfa034fae523793de872815a3468bc08","0cf1123db73dabd86466a462375a6addae52f58d23030c6033f8aadc23539a36","e29cef4158591ed213b1c2cba8988237b1ff369f7a6ecd8cb8ac0302bad1fba8","5307876e4d0021ea01235eb2f7c24671f3d8b37590f4b446cd132a4e1dc9a335","92550acd737790dc60c4c130e6aac78656dd48a8334a4882f40e7f86bdf7a590","3df821880914f8bb3c8107b1107be75c8ddbe2120a2cefabbaf9b65936b5f4dd","20626e4260b7d621745b2e78e883d9de7cc94ec346ef13344dd96eb479813870","078b7043bea0968860374bf4671ed74dd9f6be4e28ab659517d81f74be463c51","68b139ebb9a7f3ee4ded6286d74f978a47968727665120f3bfc560476ce33c4d","56d02c29b2fd39b1b1a1265df291f3f98e6ec3e6119aff9f4cfa44fe888efaa7","2d01884891da6495cb4a2f060e4898209a507e711464c4c1480df85264e863ed","620eb3b3aafe33839ee0f50e2cb237450f066fd88c8367cd15d75d02f7c9146f","6a5a3a7ae4e448668f8986632d2b6adfeebfdc06b0f9256f35c10ec148fa01f0","080b1aa93227952b4dd74b9d2c6e4f6002eb8403533749116a1c53bb9961c02d","874087eec1d457f6e3baf5ac46c42ea200e55040b394fac667aa3a64c49f5f6c","6e8a5b04a18abb192abc89d7219b9c6f633cb3136777ec808673a65f111ca749","6db505486e882a6688c5525cb65f6f06d3c5f16f03f329fbdec01dd379c97f96","d74d2a92b54f95e47d2b76bd5ee516aab7ae93afb79cd34c6681dd29eb09e72a","747e6326a724bc54f799a466a5b5c4978a601a04a063a5bdabe150af2f25b9e2","b57e22e53b56cca7a57bfcfb234aa6a66f9b9e4c07159d7388f94f17a3eaee2c","e47709ec4d1618ef429648cd8ef967aef2005526b34fcbfac33037add347dc71","b81abb3e47fbbb3af41fa75bada89bbcfa4b0feed9a0d6d4b19ed1ce1033b53c","15b330546e9784461058e5fd6e2346bf272140fa6f0cda34e193ae501d8b17b1","4d8ce72fd080bf9a46bdcc274bcbacccedd66d84e203966b197ac25a96932183","73327e6ae34e3f6591877fb75b451cf620cbbd76ee2b678213a9f793633cd0d3","3f1ba2f69944fa346789db7f60d53c9bec00032de0d797967978dea42e77b941","3f5df31539fee4816b97d4e45b4344fbdaf3ca59f6df941f8d780ee441e92cc1","50aaf44eb4d0e086af13729b3471a0a7dce95ea35ebd21c762ba26e203134b2e","3857c1773b8503c3ca45b7bc09ac89c3930c85ce93021054503f73d5d9101b5c","72702bd07fd6fb3ef64aadbcb909103aadfe71ee76e9fdeb11e0c92693cff6cb","f0dd6f7c9783637655478db7d7caf6becd41a79d54482aa59578ce88ab38e9bf",{"version":"cd756ccdabf433dd02b84d755383e489f14b3c1aede0477783aa04830fd5d695","affectsGlobalScope":true},"a4c88dbecdf8ee0c79f5b7c2bf31cd77e593f5d78384e2b674f67d754a549a9e","9cbdff04326da794ba008c0fc977ab062d1fe3fa2e9759654c72ffbe54b64a7c","aa60f8d20d36116fe05edaab24adee3c275209f71b65e272692cf99daf9489e1","150855f967a6490161d5aeed4cc4adf31fcb8f5dbe54b75799c12b8687fc9cc2","cf08b7139adc21b94204e3d4b3daf9946e3462a9e3fdc3e94c87e767e7936e20","47ddb601df40bfa01cebdd06ee8b87d0b72aa1259a4ceba3ad3b5cf68130112a","6b6392704ddb3f50e647dbbb716782bdd0cf8ea9cc134aae256a26223e632b47","afc3ad2a50f7f4de908e26fcf467e09ab8528c0e90f91e602b4865d953839228","df90b0c6b1d81851364c4d97fa23b91a993482bcf4a7bed7c7a24aa41632d494","03c0bc80f67c6f75b02341fbeb9f6ee92c66b90597729377f478885e6ad15a88","11ee9ab699b4619d217c640d917ca198f58066a86bd58c2917197d62aa6601e0","cf9d589d9e73bf32c8e7a6cae6b4a1cf9bef39e5594072533fdce985581a6ddc","959544feb1ca2df29eec6c500f27ea10f4885df245ebd8418fb4b87914614383","6548ab4b57eb9d092471a04513091673345f2fd95d5b876f600402ea8d603ee0","2793e8c6a023d26f78d6777a6d7f20fae3a9a8169863d46d8d54c73071851232","d0f11e830aa1350a31d9c00a0197243e9711e4882947aef53a96c629f405cb10","6610b9f45f1f71d2b1fb67df49cbcabe3f9e668a1ccb7d8328a51407b259ffb3","abbcc437e0792ab2fe08797ceca1ec85a95ec413c51612313b18ab8e75f690f6","e29d76ef1183ac0edf94b4712b6e51730c447c7e773e75ceb44a720b0c9a9fd9","4ee6dc3424998eede9a2a9b114acaaf7969cdda67baf82ba2c9cf88a8eec0ab1","26958d6f77e6db2425ca65df0fbfaba439396ef7f4457f5643fc32e4b62568a6","5d697a4b315cc5bb3042ae869abffd10c3b0d7b182cda0e4c45d8819937e5796","89b040dec8fcfc1de98827e1f4d4977e6ff5d3302c6790e9f10b54b916e1c742","6ee58aa536dabb19b09bc036f1abe83feb51e13d63b23d30b2d0631a2de99b8f","8aceb205dcc6f814ad99635baf1e40b6e01d06d3fe27b72fd766c6d0b8c0c600","299567f84bfedd1468dca2755a829cb19e607a6811673788807dc8921e211bc9","795d9fb85aad92221504db74dd179b506bd189bba0c104426f7e7bb8a66ffee5","1311bc194e0a69fe61031e852c1c0b439e2a2a3d1d5e2d8ff795499b9f283459","4b7ce19369d7e7fae76720c2c6c7f671bf3fa0f7093edb864f1ac358ca7c456c","c972ef44deca1fa8fab465915ffa00f82e126aacf3dfc8979c03b1b066ce5bb6","30285a1011c6d6b52f3ba3abb0a984be8148c05cdefb8eb6eb562335a3991f35","e0de9f50e80fed1cc161b50e8e68dc056e38df75a4ef667a06b1922e372de169","6a8b31be08b212d1fc96de0ddd1ea49f32382ba712fea24c70bb56447f643f82","19ac6d624e4c18de4584db4bbdbc55387dbe3d19b3c134e50346bdf165658a17","54e3798c2801e8f3bc7a825d3d26c6a80ce763e19e6cb0b714594c430ef72332","70b8333214aadaccda8d38435911d3e3a686e503837dfda6b8c3f8c83e05729b","f3815045e126ec1b9d224782805a915ae01876a1c7d1eb9b3e320ffadbd63535","d07557f21b2ad690bfe37864aa28090bd7d01c7152b77938d92d97c8419c7144","b843ea5227a9873512aa1226b546a7e52ea5e922b89461f8b202a2f2a3f0b013","64b4d440f905da272e0568224ef8d62c5cd730755c6d453043f2e606e060ec5a","d6b58d955981bc1742501b792f1ab9f4cba0c4611f28dcf1c99376c1c33c9f9c","f0b9f6d5db82c3d1679f71b187c4451dbc2875ba734ce416a4804ad47390970a","a5c38939c3e22954a7166d80ab931ac6757283737b000f1e6dc924c6f4402b88","31a863da9da2a3edec16665695bdbc3134e853195f82dafec58e98c8e1bb3119","b382a659f417df3606f2fbd2d39a02f0aa81d846cd361e79656e135a7896b779","af21e37363b40696508be1e0f1189664d17bc215ac5e64c05f7eb086a6f2ea72","df470b1c65fc51db9486ced8ff89d19c5fa2cfc5c6b3eb32d6cbab354499801e",{"version":"a6703b8328a763c5148eddf07c5801c4b67de507bc25459532d0c0c6622d11c2","signature":"68260f4ebe8f11c39b1d43d6ea75d76da4e81e2965414db9b3bd5ef2a21cdf0e"},{"version":"17ff6bb89c80df67da92a4c4d32ddccef85ce1fc2c56147161d29f638e2a1a87","signature":"acf1e448964971d594529ec272a231c39326bafde595da38cd0797266d3b446f"},"40d81f5f052d5954b51f4f5ec258a2231cdba79232e823ba93dc6dce2af4a7ff","4489c6a9fde8934733aa7df6f7911461ee6e9e4ad092736bd416f6b2cc20b2c6","2c8e55457aaf4902941dfdba4061935922e8ee6e120539c9801cd7b400fae050","8041cfce439ff29d339742389de04c136e3029d6b1817f07b2d7fcbfb7534990","670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","9d38964b57191567a14b396422c87488cecd48f405c642daa734159875ee81d9","069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9","8c95f96ccd4be0674944077aec1e4f2cccd515ca06d4327562dd017250e7d3fc",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"ee7d8894904b465b072be0d2e4b45cf6b887cdba16a467645c4e200982ece7ea","f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","bc3cba7b0af2d52e7425299aee518db479d44004eff6fbbd206d1ee7e5ec3fb5","afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","d8aab31ba8e618cc3eea10b0945de81cb93b7e8150a013a482332263b9305322","462bccdf75fcafc1ae8c30400c9425e1a4681db5d605d1a0edb4f990a54d8094","5923d8facbac6ecf7c84739a5c701a57af94a6f6648d6229a6c768cf28f0f8cb","7adecb2c3238794c378d336a8182d4c3dd2c4fa6fa1785e2797a3db550edea62","dc12dc0e5aa06f4e1a7692149b78f89116af823b9e1f1e4eae140cd3e0e674e6","1bfc6565b90c8771615cd8cfcf9b36efc0275e5e83ac7d9181307e96eb495161","8a8a96898906f065f296665e411f51010b51372fa260d5373bf9f64356703190","7f82ef88bdb67d9a850dd1c7cd2d690f33e0f0acd208e3c9eba086f3670d4f73",{"version":"ccfd8774cd9b929f63ff7dcf657977eb0652e3547f1fcac1b3a1dc5db22d4d58","affectsGlobalScope":true},"d92dc90fecd2552db74d8dc3c6fb4db9145b2aa0efe2c127236ba035969068d4","96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","b8442e9db28157344d1bc5d8a5a256f1692de213f0c0ddeb84359834015a008c","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","6f294731b495c65ecf46a5694f0082954b961cf05463bea823f8014098eaffa0","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","68a0d0c508e1b6d8d23a519a8a0a3303dc5baa4849ca049f21e5bad41945e3fc","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","4f6a12044ee6f458db11964153830abbc499e73d065c51c329ec97407f4b13dd","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","916be7d770b0ae0406be9486ac12eb9825f21514961dd050594c4b250617d5a8","254d9fb8c872d73d34594be8a200fd7311dbfa10a4116bfc465fba408052f2b3","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","2ccea88888048bbfcacbc9531a5596ea48a3e7dcd0a25f531a81bb717903ba4f","d8f7109e14f20eb735225a62fd3f8366da1a8349e90331cdad57f4b04caf6c5a","cf3d384d082b933d987c4e2fe7bfb8710adfd9dc8155190056ed6695a25a559e","9871b7ee672bc16c78833bdab3052615834b08375cb144e4d2cba74473f4a589","c863198dae89420f3c552b5a03da6ed6d0acfa3807a64772b895db624b0de707","8b03a5e327d7db67112ebbc93b4f744133eda2c1743dbb0a990c61a8007823ef","86c73f2ee1752bac8eeeece234fd05dfcf0637a4fbd8032e4f5f43102faa8eec","42fad1f540271e35ca37cecda12c4ce2eef27f0f5cf0f8dd761d723c744d3159","ff3743a5de32bee10906aff63d1de726f6a7fd6ee2da4b8229054dfa69de2c34","83acd370f7f84f203e71ebba33ba61b7f1291ca027d7f9a662c6307d74e4ac22","1445cec898f90bdd18b2949b9590b3c012f5b7e1804e6e329fb0fe053946d5ec","0e5318ec2275d8da858b541920d9306650ae6ac8012f0e872fe66eb50321a669","cf530297c3fb3a92ec9591dd4fa229d58b5981e45fe6702a0bd2bea53a5e59be","c1f6f7d08d42148ddfe164d36d7aba91f467dbcb3caa715966ff95f55048b3a4","f4e9bf9103191ef3b3612d3ec0044ca4044ca5be27711fe648ada06fad4bcc85","0c1ee27b8f6a00097c2d6d91a21ee4d096ab52c1e28350f6362542b55380059a","7677d5b0db9e020d3017720f853ba18f415219fb3a9597343b1b1012cfd699f7","bc1c6bc119c1784b1a2be6d9c47addec0d83ef0d52c8fbe1f14a51b4dfffc675","52cf2ce99c2a23de70225e252e9822a22b4e0adb82643ab0b710858810e00bf1","770625067bb27a20b9826255a8d47b6b5b0a2d3dfcbd21f89904c731f671ba77","d1ed6765f4d7906a05968fb5cd6d1db8afa14dbe512a4884e8ea5c0f5e142c80","799c0f1b07c092626cf1efd71d459997635911bb5f7fc1196efe449bba87e965","2a184e4462b9914a30b1b5c41cf80c6d3428f17b20d3afb711fff3f0644001fd","9eabde32a3aa5d80de34af2c2206cdc3ee094c6504a8d0c2d6d20c7c179503cc","397c8051b6cfcb48aa22656f0faca2553c5f56187262135162ee79d2b2f6c966","a8ead142e0c87dcd5dc130eba1f8eeed506b08952d905c47621dc2f583b1bff9","a02f10ea5f73130efca046429254a4e3c06b5475baecc8f7b99a0014731be8b3","c2576a4083232b0e2d9bd06875dd43d371dee2e090325a9eac0133fd5650c1cb","4c9a0564bb317349de6a24eb4efea8bb79898fa72ad63a1809165f5bd42970dd","f40ac11d8859092d20f953aae14ba967282c3bb056431a37fced1866ec7a2681","cc11e9e79d4746cc59e0e17473a59d6f104692fd0eeea1bdb2e206eabed83b03","b444a410d34fb5e98aa5ee2b381362044f4884652e8bc8a11c8fe14bbd85518e","c35808c1f5e16d2c571aa65067e3cb95afeff843b259ecfa2fc107a9519b5392","14d5dc055143e941c8743c6a21fa459f961cbc3deedf1bfe47b11587ca4b3ef5","a3ad4e1fc542751005267d50a6298e6765928c0c3a8dce1572f2ba6ca518661c","f237e7c97a3a89f4591afd49ecb3bd8d14f51a1c4adc8fcae3430febedff5eb6","3ffdfbec93b7aed71082af62b8c3e0cc71261cc68d796665faa1e91604fbae8f","662201f943ed45b1ad600d03a90dffe20841e725203ced8b708c91fcd7f9379a","c9ef74c64ed051ea5b958621e7fb853fe3b56e8787c1587aefc6ea988b3c7e79","2462ccfac5f3375794b861abaa81da380f1bbd9401de59ffa43119a0b644253d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","7d8ddf0f021c53099e34ee831a06c394d50371816caa98684812f089b4c6b3d4","7d2a0ba1297be385a89b5515b88cd31b4a1eeef5236f710166dc1b36b1741e1b","9d92b037978bb9525bc4b673ebddd443277542e010c0aef019c03a170ccdaa73","ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e","bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","ae271d475b632ce7b03fea6d9cf6da72439e57a109672671cbc79f54e1386938"],"options":{"composite":true,"declaration":true,"declarationMap":true,"emitDeclarationOnly":true,"esModuleInterop":true,"inlineSources":true,"module":1,"outDir":"./types","rootDir":"../src","sourceMap":true,"strict":true,"target":7},"fileIdsList":[[434],[72,108,109,110,125],[109,110,126,127],[108,109],[108,125,128,131],[108,128,131,132],[129,130,131,133,134],[108,131],[108,125,128,129,130,133],[108,116],[108],[72,108],[60,108],[112,113,114,115,116,117,118,119,120,121,122,123,124],[108,114,115],[108,114,116],[108,135,172,173],[172],[173,174],[108,167],[167,168,169,170,171],[108,139,146,147],[108,139,146,147,167],[108,139,146,147,151],[108,139,146,147,148,150,151],[108,139,146,147,149],[108,139,146,147,152,153,155,156],[145,167],[137,146,147,152,153],[139,145,146],[108,139,146,147,152],[108,139,146,147,150],[108,139,146,147,163],[108,139,146,147,164],[111,136,139,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166],[137],[137,138],[72,108,172,175,184],[175,185],[185,186],[242,243,244,245],[108,125],[247],[135,219,246],[300,309,310,313],[300,309,312],[300,309,311,313],[301,304,305,307],[301,302,303],[304,305,307,308],[301,302,306],[312,318],[300,309,312,318],[309,312,318],[309,312,314,315,316,317],[300,309,310,311,312,313,318],[300,309],[301],[196,219,252],[219,266,268],[219,268,269,290],[196,219,249,251,252,265],[196,219],[250],[253],[196,252],[254,255,264],[263],[251,252,257,263,265,266,267,269,291,292,402],[196,219,403],[219,257,265],[258],[256,259,260,261,262],[196,219,250,252,255],[219,267,401],[190,196],[179],[178],[108,177,179],[179,180,181,182,183],[108,177],[178,219,281,282],[283],[108,177,219,283,285],[108,177,178,219,281,283],[285],[282,283,284,285,286,287,288,289],[108,177,284,287],[282,287],[219,281],[219,270],[270,271],[270,271,272,273],[219],[108,219,293],[219,398],[367],[219,293,367,395,398,399,400],[108,219,274,293],[294,295,296,297,396,397],[190,196,395],[190,196,296],[328],[328,340],[328,329,342,344],[328,340,343],[328,334],[328,333,335],[333,334,335,336],[338,339],[329,330,331,332,337,340,341,342,343,344,345,346],[328,347,348,349,350],[328,347,398],[382],[395],[385,386,387,388,389,390,391,392,393],[219,320],[367,391,398],[320,395,398],[196],[320,321,368,371,381,382,383,394],[196,351,367],[395,398],[319,321],[321],[398],[368],[219,371],[298,299,322,323,324,325,326,327,369,370,372,373,374,375,376,377,378,379,380],[219,373],[298,299,322,323,324,325,326,327,369,370,372,373,374,375,376,377,378,379,398],[219,319,320],[290,381],[219,321],[365],[196,352],[353,354,355,356,357,358,359,360,361,362,363,364],[352,365,366],[199],[196,199],[197,198,199,200,201,202,203,204,205,206,207,208,211,212,213,214,215,216,217,218],[190,196,197],[135,199,205,207],[210],[199,200],[196,214],[108,142],[140,141,144],[140,143],[108,140],[410,411],[434,435,436,437,438],[434,436],[209],[441,442,443],[73,108],[446],[447],[458],[452,457],[461,463,464,465,466,467,468,469,470,471,472,473],[461,462,464,465,466,467,468,469,470,471,472,473],[462,463,464,465,466,467,468,469,470,471,472,473],[461,462,463,465,466,467,468,469,470,471,472,473],[461,462,463,464,466,467,468,469,470,471,472,473],[461,462,463,464,465,467,468,469,470,471,472,473],[461,462,463,464,465,466,468,469,470,471,472,473],[461,462,463,464,465,466,467,469,470,471,472,473],[461,462,463,464,465,466,467,468,470,471,472,473],[461,462,463,464,465,466,467,468,469,471,472,473],[461,462,463,464,465,466,467,468,469,470,472,473],[461,462,463,464,465,466,467,468,469,470,471,473],[461,462,463,464,465,466,467,468,469,470,471,472],[56],[59],[60,65,92],[61,72,73,80,89,100],[61,62,72,80],[63,101],[64,65,73,81],[65,89,97],[66,68,72,80],[67],[68,69],[72],[71,72],[59,72],[72,73,74,89,100],[72,73,74,89],[72,75,80,89,100],[72,73,75,76,80,89,97,100],[75,77,89,97,100],[56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107],[72,78],[79,100,105],[68,72,80,89],[81],[82],[59,83],[84,99,105],[85],[86],[72,87],[87,88,101,103],[60,72,89,90,91],[60,89,91],[89,90],[92],[93],[72,95,96],[95,96],[65,80,89,97],[98],[80,99],[60,75,86,100],[65,101],[89,102],[103],[104],[60,65,72,74,83,89,100,103,105],[89,106],[108,176],[480,519],[480,504,519],[519],[480],[480,505,519],[480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518],[505,519],[520],[524],[420],[422],[420,421,422,423,424,425,426],[420,422],[108,430],[108,428,429],[430],[231],[231,232,233,234,235],[220,221,222,223,224,225,226,227,228,229,230],[450,453],[450,453,454,455],[452],[449,456],[451],[189,191,192,193,194,195],[189,190],[191],[190,191],[189,191],[219,236,237,238],[237],[238],[188,237,238,239],[405],[405,406,409,413],[412],[219,407,408],[178,219,274],[219,275],[219,275,278],[275,276,277,278,279,280],[48,49,125,135,187,219,236,240,241,246,403,419,427,430,431],[432],[72,108,219,240],[404],[404,414],[404,415,416,417,418],[135,187,219,236,240,241,403,419]],"referencedMap":[[436,1],[126,2],[128,3],[110,4],[132,5],[133,6],[129,6],[135,7],[130,6],[134,8],[131,9],[117,10],[114,11],[121,12],[115,10],[112,13],[125,14],[119,11],[116,15],[118,16],[174,17],[173,18],[175,19],[170,20],[168,20],[169,20],[172,21],[154,22],[159,23],[148,22],[153,24],[152,25],[150,26],[157,27],[158,22],[160,28],[155,29],[147,30],[161,31],[163,32],[164,33],[165,34],[167,35],[138,36],[139,37],[185,38],[186,39],[187,40],[246,41],[242,42],[243,11],[245,42],[248,43],[247,44],[311,45],[313,46],[312,47],[308,48],[304,49],[305,49],[309,50],[307,51],[314,52],[315,53],[316,54],[318,55],[317,52],[319,56],[310,57],[303,58],[306,49],[268,59],[269,60],[291,61],[266,62],[249,63],[251,64],[250,63],[254,65],[253,66],[265,67],[255,63],[264,68],[403,69],[256,70],[258,71],[259,72],[260,63],[263,73],[262,74],[292,60],[402,75],[252,76],[181,77],[182,77],[179,78],[180,79],[184,80],[183,81],[283,82],[284,83],[287,84],[285,85],[286,86],[290,87],[288,88],[289,89],[282,90],[271,91],[272,92],[274,93],[270,94],[178,12],[399,95],[293,96],[400,97],[401,98],[294,99],[295,94],[296,94],[398,100],[396,101],[297,102],[328,94],[329,103],[330,103],[331,103],[332,103],[341,103],[342,103],[343,104],[345,105],[346,103],[344,106],[333,103],[335,107],[336,108],[334,103],[337,109],[338,103],[339,103],[340,110],[347,111],[351,112],[349,103],[348,103],[350,113],[383,114],[385,94],[386,115],[394,116],[387,94],[388,94],[389,117],[390,94],[392,118],[391,119],[393,120],[395,121],[368,122],[298,115],[299,123],[322,124],[323,125],[324,124],[326,94],[327,126],[369,127],[372,128],[381,129],[374,130],[373,94],[375,94],[376,96],[380,131],[377,126],[378,128],[379,115],[321,132],[382,133],[371,134],[366,135],[353,136],[362,136],[354,136],[355,136],[364,136],[356,136],[357,136],[365,137],[363,136],[358,136],[361,136],[359,136],[360,136],[367,138],[352,120],[197,120],[198,120],[200,139],[201,120],[202,120],[203,140],[199,120],[219,141],[207,142],[208,143],[211,144],[217,145],[218,146],[143,147],[142,11],[145,148],[140,11],[144,149],[141,150],[412,151],[439,152],[435,1],[437,153],[438,1],[408,11],[210,154],[444,155],[445,156],[447,157],[448,158],[459,159],[458,160],[462,161],[463,162],[461,163],[464,164],[465,165],[466,166],[467,167],[468,168],[469,169],[470,170],[471,171],[472,172],[473,173],[56,174],[57,174],[59,175],[60,176],[61,177],[62,178],[63,179],[64,180],[65,181],[66,182],[67,183],[68,184],[69,184],[70,185],[71,186],[72,187],[73,188],[74,189],[75,190],[76,191],[77,192],[108,193],[78,194],[79,195],[80,196],[81,197],[82,198],[83,199],[84,200],[85,201],[86,202],[87,203],[88,204],[89,205],[91,206],[90,207],[92,208],[93,209],[95,210],[96,211],[97,212],[98,213],[99,214],[100,215],[101,216],[102,217],[103,218],[104,219],[105,220],[106,221],[476,11],[177,222],[479,11],[504,223],[505,224],[480,225],[483,225],[502,223],[503,223],[493,223],[492,226],[490,223],[485,223],[498,223],[496,223],[500,223],[484,223],[497,223],[501,223],[486,223],[487,223],[499,223],[481,223],[488,223],[489,223],[491,223],[495,223],[506,227],[494,223],[482,223],[519,228],[513,227],[515,229],[514,227],[507,227],[508,227],[510,227],[512,227],[516,229],[517,229],[509,229],[511,229],[521,230],[525,231],[421,232],[423,233],[427,234],[425,235],[424,235],[428,236],[430,237],[429,238],[227,239],[229,239],[228,239],[226,239],[236,240],[231,241],[222,239],[223,239],[224,239],[225,239],[454,242],[456,243],[455,242],[453,244],[457,245],[452,246],[196,247],[191,248],[192,249],[193,249],[194,250],[195,250],[190,251],[239,252],[238,253],[237,254],[240,255],[406,256],[414,257],[413,258],[409,259],[275,260],[276,261],[277,261],[279,262],[281,263],[280,261],[432,264],[433,265],[404,266],[418,267],[417,267],[415,268],[416,267],[419,269]],"exportedModulesMap":[[436,1],[126,2],[128,3],[110,4],[132,5],[133,6],[129,6],[135,7],[130,6],[134,8],[131,9],[117,10],[114,11],[121,12],[115,10],[112,13],[125,14],[119,11],[116,15],[118,16],[174,17],[173,18],[175,19],[170,20],[168,20],[169,20],[172,21],[154,22],[159,23],[148,22],[153,24],[152,25],[150,26],[157,27],[158,22],[160,28],[155,29],[147,30],[161,31],[163,32],[164,33],[165,34],[167,35],[138,36],[139,37],[185,38],[186,39],[187,40],[246,41],[242,42],[243,11],[245,42],[248,43],[247,44],[311,45],[313,46],[312,47],[308,48],[304,49],[305,49],[309,50],[307,51],[314,52],[315,53],[316,54],[318,55],[317,52],[319,56],[310,57],[303,58],[306,49],[268,59],[269,60],[291,61],[266,62],[249,63],[251,64],[250,63],[254,65],[253,66],[265,67],[255,63],[264,68],[403,69],[256,70],[258,71],[259,72],[260,63],[263,73],[262,74],[292,60],[402,75],[252,76],[181,77],[182,77],[179,78],[180,79],[184,80],[183,81],[283,82],[284,83],[287,84],[285,85],[286,86],[290,87],[288,88],[289,89],[282,90],[271,91],[272,92],[274,93],[270,94],[178,12],[399,95],[293,96],[400,97],[401,98],[294,99],[295,94],[296,94],[398,100],[396,101],[297,102],[328,94],[329,103],[330,103],[331,103],[332,103],[341,103],[342,103],[343,104],[345,105],[346,103],[344,106],[333,103],[335,107],[336,108],[334,103],[337,109],[338,103],[339,103],[340,110],[347,111],[351,112],[349,103],[348,103],[350,113],[383,114],[385,94],[386,115],[394,116],[387,94],[388,94],[389,117],[390,94],[392,118],[391,119],[393,120],[395,121],[368,122],[298,115],[299,123],[322,124],[323,125],[324,124],[326,94],[327,126],[369,127],[372,128],[381,129],[374,130],[373,94],[375,94],[376,96],[380,131],[377,126],[378,128],[379,115],[321,132],[382,133],[371,134],[366,135],[353,136],[362,136],[354,136],[355,136],[364,136],[356,136],[357,136],[365,137],[363,136],[358,136],[361,136],[359,136],[360,136],[367,138],[352,120],[197,120],[198,120],[200,139],[201,120],[202,120],[203,140],[199,120],[219,141],[207,142],[208,143],[211,144],[217,145],[218,146],[143,147],[142,11],[145,148],[140,11],[144,149],[141,150],[412,151],[439,152],[435,1],[437,153],[438,1],[408,11],[210,154],[444,155],[445,156],[447,157],[448,158],[459,159],[458,160],[462,161],[463,162],[461,163],[464,164],[465,165],[466,166],[467,167],[468,168],[469,169],[470,170],[471,171],[472,172],[473,173],[56,174],[57,174],[59,175],[60,176],[61,177],[62,178],[63,179],[64,180],[65,181],[66,182],[67,183],[68,184],[69,184],[70,185],[71,186],[72,187],[73,188],[74,189],[75,190],[76,191],[77,192],[108,193],[78,194],[79,195],[80,196],[81,197],[82,198],[83,199],[84,200],[85,201],[86,202],[87,203],[88,204],[89,205],[91,206],[90,207],[92,208],[93,209],[95,210],[96,211],[97,212],[98,213],[99,214],[100,215],[101,216],[102,217],[103,218],[104,219],[105,220],[106,221],[476,11],[177,222],[479,11],[504,223],[505,224],[480,225],[483,225],[502,223],[503,223],[493,223],[492,226],[490,223],[485,223],[498,223],[496,223],[500,223],[484,223],[497,223],[501,223],[486,223],[487,223],[499,223],[481,223],[488,223],[489,223],[491,223],[495,223],[506,227],[494,223],[482,223],[519,228],[513,227],[515,229],[514,227],[507,227],[508,227],[510,227],[512,227],[516,229],[517,229],[509,229],[511,229],[521,230],[525,231],[421,232],[423,233],[427,234],[425,235],[424,235],[428,236],[430,237],[429,238],[227,239],[229,239],[228,239],[226,239],[236,240],[231,241],[222,239],[223,239],[224,239],[225,239],[454,242],[456,243],[455,242],[453,244],[457,245],[452,246],[196,247],[191,248],[192,249],[193,249],[194,250],[195,250],[190,251],[239,252],[238,253],[237,254],[240,255],[406,256],[414,257],[413,258],[409,259],[275,260],[276,261],[277,261],[279,262],[281,263],[280,261],[432,270],[433,265],[404,266],[418,267],[417,267],[415,268],[416,267],[419,269]],"semanticDiagnosticsPerFile":[436,434,126,109,128,110,127,132,133,129,135,130,134,131,117,114,121,115,112,120,125,122,123,124,119,116,113,118,174,173,175,170,168,169,172,171,154,159,148,153,152,150,157,158,160,155,149,147,146,156,162,161,163,164,165,167,137,138,139,136,151,166,185,186,187,241,407,244,246,242,243,245,248,247,311,313,312,300,308,304,305,309,307,314,315,316,318,317,319,310,303,301,302,306,268,269,291,266,249,251,250,257,254,253,265,255,264,267,403,256,258,259,260,263,261,262,292,402,252,181,182,179,180,184,183,283,284,287,285,286,290,288,289,282,271,273,272,274,270,178,399,293,400,401,294,295,296,398,396,297,397,328,329,330,331,332,341,342,343,345,346,344,333,335,336,334,337,338,339,340,347,351,349,348,350,320,383,385,386,394,387,388,389,390,392,391,393,384,395,368,298,299,322,323,324,325,326,327,369,370,372,381,374,373,375,376,380,377,378,379,321,382,371,366,353,362,354,355,364,356,357,365,363,358,361,359,360,367,352,197,198,200,201,202,203,204,205,206,199,219,207,208,211,212,213,214,215,216,217,218,143,142,145,140,144,141,410,412,411,439,435,437,438,408,210,440,441,444,442,445,446,447,448,459,458,443,460,462,463,461,464,465,466,467,468,469,470,471,472,473,474,209,56,57,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,58,107,75,76,77,108,78,79,80,81,82,83,84,85,86,87,88,89,91,90,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,475,476,477,478,177,176,479,504,505,480,483,502,503,493,492,490,485,498,496,500,484,497,501,486,487,499,481,488,489,491,495,506,494,482,519,518,513,515,514,507,508,510,512,516,517,509,511,521,520,522,523,524,525,421,420,423,422,426,427,425,424,111,449,428,430,429,230,227,229,228,226,236,231,235,232,234,233,222,223,224,220,221,225,450,454,456,455,453,457,452,451,189,196,191,192,193,194,195,190,8,10,9,2,11,12,13,14,15,16,17,18,3,4,22,19,20,21,23,24,25,5,26,27,28,29,6,33,30,31,32,34,7,35,40,41,36,37,38,39,1,42,188,239,238,237,240,406,414,413,405,409,275,276,277,278,279,281,280,432,431,433,404,418,417,415,416,419,47,48,49,50,51,52,43,53,54,55,44,45,46],"latestChangedDtsFile":"./types/index.d.ts"},"version":"4.9.5"}
\ No newline at end of file
diff --git a/dist/types/KeyringController.d.ts.map b/dist/types/KeyringController.d.ts.map
index 310d2853a09b2ce1c4aa6c457ba4450103127868..3715da4a8b1826fed478f8b7c8c3de80dafa9987 100644
--- a/dist/types/KeyringController.d.ts.map
+++ b/dist/types/KeyringController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"KeyringController.d.ts","sourceRoot":"","sources":["../../src/KeyringController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"KeyringController.d.ts","sourceRoot":"","sources":["../../src/KeyringController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
